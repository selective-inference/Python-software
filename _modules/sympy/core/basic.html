

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Selection &mdash; Selection Documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />


</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../algorithms/index.html">Non-randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../randomized/index.html">Randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../learning/index.html">Learning selection</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">selection</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>Selection</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sympy.core.basic</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Base class for all the objects in SymPy&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span>

<span class="kn">from</span> <span class="nn">.assumptions</span> <span class="k">import</span> <span class="n">BasicMeta</span><span class="p">,</span> <span class="n">ManagedProperties</span>
<span class="kn">from</span> <span class="nn">.cache</span> <span class="k">import</span> <span class="n">cacheit</span>
<span class="kn">from</span> <span class="nn">.sympify</span> <span class="k">import</span> <span class="n">_sympify</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">SympifyError</span>
<span class="kn">from</span> <span class="nn">.compatibility</span> <span class="k">import</span> <span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span>
    <span class="n">string_types</span><span class="p">,</span> <span class="n">with_metaclass</span><span class="p">,</span> <span class="n">zip_longest</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">PY3</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.singleton</span> <span class="k">import</span> <span class="n">S</span>

<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">getmro</span>


<span class="k">def</span> <span class="nf">as_Basic</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return expr as a Basic instance using strict sympify</span>
<span class="sd">    or raise a TypeError; this is just a wrapper to _sympify,</span>
<span class="sd">    raising a TypeError instead of a SympifyError.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="k">import</span> <span class="n">func_name</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">SympifyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;Argument must be a Basic object, not `</span><span class="si">%s</span><span class="s1">`&#39;</span> <span class="o">%</span> <span class="n">func_name</span><span class="p">(</span>
            <span class="n">expr</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Basic</span><span class="p">(</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">ManagedProperties</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all objects in SymPy.</span>

<span class="sd">    Conventions:</span>

<span class="sd">    1) Always use ``.args``, when accessing parameters of some instance:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import cot</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">        &gt;&gt;&gt; cot(x).args</span>
<span class="sd">        (x,)</span>

<span class="sd">        &gt;&gt;&gt; cot(x).args[0]</span>
<span class="sd">        x</span>

<span class="sd">        &gt;&gt;&gt; (x*y).args</span>
<span class="sd">        (x, y)</span>

<span class="sd">        &gt;&gt;&gt; (x*y).args[1]</span>
<span class="sd">        y</span>


<span class="sd">    2) Never use internal methods or variables (the ones prefixed with ``_``):</span>

<span class="sd">        &gt;&gt;&gt; cot(x)._args    # do not use this, use cot(x).args instead</span>
<span class="sd">        (x,)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_mhash&#39;</span><span class="p">,</span>              <span class="c1"># hash value</span>
                 <span class="s1">&#39;_args&#39;</span><span class="p">,</span>               <span class="c1"># arguments</span>
                 <span class="s1">&#39;_assumptions&#39;</span>
                <span class="p">]</span>

    <span class="c1"># To be overridden with True in the appropriate subclasses</span>
    <span class="n">is_number</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Atom</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Symbol</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_symbol</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Indexed</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Dummy</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Wild</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Function</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Add</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Mul</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Pow</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Number</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Float</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Rational</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Integer</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_NumberSymbol</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Order</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Derivative</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Piecewise</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Poly</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_AlgebraicNumber</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Relational</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Equality</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Boolean</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Not</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Matrix</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Vector</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Point</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_MatAdd</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_MatMul</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_assumptions</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">default_assumptions</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_mhash</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will be set by __hash__ method.</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="n">args</span>  <span class="c1"># all items in args must be Basic objects</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce_ex__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proto</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Pickling support.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getnewargs__</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># hash cannot be cached using cache_it because infinite recurrence</span>
        <span class="c1"># occurs as hash is needed for setting cache dictionary keys</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mhash</span>
        <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_content</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mhash</span> <span class="o">=</span> <span class="n">h</span>
        <span class="k">return</span> <span class="n">h</span>

    <span class="k">def</span> <span class="nf">_hashable_content</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple of information about self that can be used to</span>
<span class="sd">        compute the hash. If a class defines additional attributes,</span>
<span class="sd">        like ``name`` in Symbol, then this method should be updated</span>
<span class="sd">        accordingly to return such relevant attributes.</span>

<span class="sd">        Defining more than _hashable_content is necessary if __eq__ has</span>
<span class="sd">        been defined by a class. See note about this in Basic.__eq__.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">assumptions0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return object `type` assumptions.</span>

<span class="sd">        For example:</span>

<span class="sd">          Symbol(&#39;x&#39;, real=True)</span>
<span class="sd">          Symbol(&#39;x&#39;, integer=True)</span>

<span class="sd">        are different objects. In other words, besides Python type (Symbol in</span>
<span class="sd">        this case), the initial assumptions are also forming their typeinfo.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; x.assumptions0</span>
<span class="sd">        {&#39;commutative&#39;: True}</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&quot;x&quot;, positive=True)</span>
<span class="sd">        &gt;&gt;&gt; x.assumptions0</span>
<span class="sd">        {&#39;commutative&#39;: True, &#39;complex&#39;: True, &#39;hermitian&#39;: True,</span>
<span class="sd">        &#39;imaginary&#39;: False, &#39;negative&#39;: False, &#39;nonnegative&#39;: True,</span>
<span class="sd">        &#39;nonpositive&#39;: False, &#39;nonzero&#39;: True, &#39;positive&#39;: True, &#39;real&#39;: True,</span>
<span class="sd">        &#39;zero&#39;: False}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return -1, 0, 1 if the object is smaller, equal, or greater than other.</span>

<span class="sd">        Not in the mathematical sense. If the object is of a different type</span>
<span class="sd">        from the &quot;other&quot; then their classes are ordered according to</span>
<span class="sd">        the sorted_classes list.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; x.compare(y)</span>
<span class="sd">        -1</span>
<span class="sd">        &gt;&gt;&gt; x.compare(x)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; y.compare(x)</span>
<span class="sd">        1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># all redefinitions of __cmp__ method should start with the</span>
        <span class="c1"># following lines:</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">n1</span> <span class="o">&gt;</span> <span class="n">n2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n1</span> <span class="o">&lt;</span> <span class="n">n2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span>
        <span class="c1">#</span>
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_content</span><span class="p">()</span>
        <span class="n">ot</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_hashable_content</span><span class="p">()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ot</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ot</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">ot</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">Basic</span><span class="p">(</span><span class="o">*</span><span class="n">l</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">)</span> <span class="k">else</span> <span class="n">l</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">Basic</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">)</span> <span class="k">else</span> <span class="n">r</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">c</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_compare_pretty</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.series.order</span> <span class="k">import</span> <span class="n">Order</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Order</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Order</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Order</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Order</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">p</span> <span class="o">*</span> <span class="n">b</span><span class="o">.</span><span class="n">q</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">q</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="k">import</span> <span class="n">Wild</span>
            <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;p1&quot;</span><span class="p">),</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;p2&quot;</span><span class="p">),</span> <span class="n">Wild</span><span class="p">(</span><span class="s2">&quot;p3&quot;</span><span class="p">)</span>
            <span class="n">r_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p1</span> <span class="o">*</span> <span class="n">p2</span><span class="o">**</span><span class="n">p3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r_a</span> <span class="ow">and</span> <span class="n">p3</span> <span class="ow">in</span> <span class="n">r_a</span><span class="p">:</span>
                <span class="n">a3</span> <span class="o">=</span> <span class="n">r_a</span><span class="p">[</span><span class="n">p3</span><span class="p">]</span>
                <span class="n">r_b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p1</span> <span class="o">*</span> <span class="n">p2</span><span class="o">**</span><span class="n">p3</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">r_b</span> <span class="ow">and</span> <span class="n">p3</span> <span class="ow">in</span> <span class="n">r_b</span><span class="p">:</span>
                    <span class="n">b3</span> <span class="o">=</span> <span class="n">r_b</span><span class="p">[</span><span class="n">p3</span><span class="p">]</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">a3</span><span class="p">,</span> <span class="n">b3</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">c</span>

        <span class="k">return</span> <span class="n">Basic</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromiter</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new object from an iterable.</span>

<span class="sd">        This is a convenience function that allows one to create objects from</span>
<span class="sd">        any iterable, without having to convert to a list or tuple first.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Tuple</span>
<span class="sd">        &gt;&gt;&gt; Tuple.fromiter(i for i in range(5))</span>
<span class="sd">        (0, 1, 2, 3, 4)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">class_key</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Nice order of classes. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a sort key.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.core import S, I</span>

<span class="sd">        &gt;&gt;&gt; sorted([S(1)/2, I, -I], key=lambda x: x.sort_key())</span>
<span class="sd">        [1/2, -I, I]</span>

<span class="sd">        &gt;&gt;&gt; S(&quot;[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]&quot;)</span>
<span class="sd">        [x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]</span>
<span class="sd">        &gt;&gt;&gt; sorted(_, key=lambda x: x.sort_key())</span>
<span class="sd">        [x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># XXX: remove this when issue 5169 is fixed</span>
        <span class="k">def</span> <span class="nf">inner_key</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arg</span>

        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sorted_args</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">inner_key</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_key</span><span class="p">(),</span> <span class="n">args</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a boolean indicating whether a == b on the basis of</span>
<span class="sd">        their symbolic trees.</span>

<span class="sd">        This is the same as a.compare(b) == 0 but faster.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        If a class that overrides __eq__() needs to retain the</span>
<span class="sd">        implementation of __hash__() from a parent class, the</span>
<span class="sd">        interpreter must be told this explicitly by setting __hash__ =</span>
<span class="sd">        &lt;ParentClass&gt;.__hash__. Otherwise the inheritance of __hash__()</span>
<span class="sd">        will be blocked, just as if __hash__ had been explicitly set to</span>
<span class="sd">        None.</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        from http://docs.python.org/dev/reference/datamodel.html#object.__hash__</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">tself</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">tother</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tself</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tother</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="n">tother</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">SympifyError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

            <span class="c1"># As long as we have the ordering of classes (sympy.core),</span>
            <span class="c1"># comparing types will be slow in Python 2, because it uses</span>
            <span class="c1"># __cmp__. Until we can remove it</span>
            <span class="c1"># (https://github.com/sympy/sympy/issues/4269), we only compare</span>
            <span class="c1"># types in Python 2 directly if they actually have __ne__.</span>
            <span class="k">if</span> <span class="n">PY3</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">tself</span><span class="p">)</span><span class="o">.</span><span class="fm">__ne__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__ne__</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tself</span> <span class="o">!=</span> <span class="n">tother</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">tself</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tother</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_content</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_hashable_content</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;a != b  -&gt; Compare two symbolic trees and see whether they are different</span>

<span class="sd">           this is the same as:</span>

<span class="sd">             a.compare(b) != 0</span>

<span class="sd">           but faster</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">dummy_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">symbol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare two expressions and handle dummy symbols.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Dummy</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">        &gt;&gt;&gt; u = Dummy(&#39;u&#39;)</span>

<span class="sd">        &gt;&gt;&gt; (u**2 + 1).dummy_eq(x**2 + 1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (u**2 + 1) == (x**2 + 1)</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; (u**2 + y).dummy_eq(x**2 + y, x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (u**2 + y).dummy_eq(x**2 + y, y)</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>

        <span class="n">dummy_symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Dummy</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dummy_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dummy</span> <span class="o">=</span> <span class="n">dummy_symbols</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span> <span class="o">==</span> <span class="n">o</span>

        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">symbols</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">free_symbols</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">=</span> <span class="n">symbols</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span> <span class="o">==</span> <span class="n">o</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">dummy</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="o">==</span> <span class="n">o</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>

    <span class="c1"># Note, we always use the default ordering (lex) in __str__ and __repr__,</span>
    <span class="c1"># regardless of the global setting.  See issue 5487.</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to return the string representation.</span>
<span class="sd">        Return the expression as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.printing</span> <span class="k">import</span> <span class="n">sstr</span>
        <span class="k">return</span> <span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.printing</span> <span class="k">import</span> <span class="n">sstr</span>
        <span class="k">return</span> <span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># We don&#39;t define _repr_png_ here because it would add a large amount of</span>
    <span class="c1"># data to any notebook containing SymPy expressions, without adding</span>
    <span class="c1"># anything useful to the notebook. It can still enabled manually, e.g.,</span>
    <span class="c1"># for the qtconsole, with init_printing().</span>
    <span class="k">def</span> <span class="nf">_repr_latex_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        IPython/Jupyter LaTeX printing</span>

<span class="sd">        To change the behavior of this (e.g., pass in some settings to LaTeX),</span>
<span class="sd">        use init_printing(). init_printing() will also enable LaTeX printing</span>
<span class="sd">        for built in numeric types like ints and container types that contain</span>
<span class="sd">        SymPy objects, like lists and dictionaries of expressions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.printing.latex</span> <span class="k">import</span> <span class="n">latex</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;plain&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;$</span><span class="se">\\</span><span class="s2">displaystyle </span><span class="si">%s</span><span class="s2">$&quot;</span> <span class="o">%</span> <span class="n">s</span>

    <span class="n">_repr_latex_orig</span> <span class="o">=</span> <span class="n">_repr_latex_</span>

    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">types</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the atoms that form the current object.</span>

<span class="sd">           By default, only objects that are truly atomic and can&#39;t</span>
<span class="sd">           be divided into smaller pieces are returned: symbols, numbers,</span>
<span class="sd">           and number symbols like I and pi. It is possible to request</span>
<span class="sd">           atoms of any type, however, as demonstrated below.</span>

<span class="sd">           Examples</span>
<span class="sd">           ========</span>

<span class="sd">           &gt;&gt;&gt; from sympy import I, pi, sin</span>
<span class="sd">           &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms()</span>
<span class="sd">           {1, 2, I, pi, x, y}</span>

<span class="sd">           If one or more types are given, the results will contain only</span>
<span class="sd">           those types of atoms.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import Number, NumberSymbol, Symbol</span>
<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(Symbol)</span>
<span class="sd">           {x, y}</span>

<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(Number)</span>
<span class="sd">           {1, 2}</span>

<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)</span>
<span class="sd">           {1, 2, pi}</span>

<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)</span>
<span class="sd">           {1, 2, I, pi}</span>

<span class="sd">           Note that I (imaginary unit) and zoo (complex infinity) are special</span>
<span class="sd">           types of number symbols and are not part of the NumberSymbol class.</span>

<span class="sd">           The type can be given implicitly, too:</span>

<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol</span>
<span class="sd">           {x, y}</span>

<span class="sd">           Be careful to check your assumptions when using the implicit option</span>
<span class="sd">           since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type</span>
<span class="sd">           of sympy atom, while ``type(S(2))`` is type ``Integer`` and will find all</span>
<span class="sd">           integers in an expression:</span>

<span class="sd">           &gt;&gt;&gt; from sympy import S</span>
<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(S(1))</span>
<span class="sd">           {1}</span>

<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(S(2))</span>
<span class="sd">           {1, 2}</span>

<span class="sd">           Finally, arguments to atoms() can select more than atomic atoms: any</span>
<span class="sd">           sympy type (loaded in core/__init__.py) can be listed as an argument</span>
<span class="sd">           and those types of &quot;atoms&quot; as found in scanning the arguments of the</span>
<span class="sd">           expression recursively:</span>

<span class="sd">           &gt;&gt;&gt; from sympy import Function, Mul</span>
<span class="sd">           &gt;&gt;&gt; from sympy.core.function import AppliedUndef</span>
<span class="sd">           &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">           &gt;&gt;&gt; (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)</span>
<span class="sd">           {f(x), sin(y + I*pi)}</span>
<span class="sd">           &gt;&gt;&gt; (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)</span>
<span class="sd">           {f(x)}</span>

<span class="sd">           &gt;&gt;&gt; (1 + x + 2*sin(y + I*pi)).atoms(Mul)</span>
<span class="sd">           {I*pi, 2*sin(y + I*pi)}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">types</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span><span class="n">t</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="k">else</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">free_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return from the atoms of self those which are free symbols.</span>

<span class="sd">        For most expressions, all symbols are free symbols. For some classes</span>
<span class="sd">        this is not true. e.g. Integrals use Symbols for the dummy variables</span>
<span class="sd">        which are bound variables, so Integral has a method to return all</span>
<span class="sd">        symbols except those. Derivative keeps track of symbols with respect</span>
<span class="sd">        to which it will perform a derivative; those are</span>
<span class="sd">        bound variables, too, so it has its own free_symbols method.</span>

<span class="sd">        Any other method that uses bound variables should implement a</span>
<span class="sd">        free_symbols method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">expr_free_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([])</span>

    <span class="k">def</span> <span class="nf">as_dummy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the expression with any objects having structurally</span>
<span class="sd">        bound symbols replaced with unique, canonical symbols within</span>
<span class="sd">        the object in which they appear and having only the default</span>
<span class="sd">        assumption for commutativity being True.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Integral, Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; r = Symbol(&#39;r&#39;, real=True)</span>
<span class="sd">        &gt;&gt;&gt; Integral(r, (r, x)).as_dummy()</span>
<span class="sd">        Integral(_0, (_0, x))</span>
<span class="sd">        &gt;&gt;&gt; _.variables[0].is_real is None</span>
<span class="sd">        True</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        Any object that has structural dummy variables should have</span>
<span class="sd">        a property, `bound_symbols` that returns a list of structural</span>
<span class="sd">        dummy symbols of the object itself.</span>

<span class="sd">        Lambda and Subs have bound symbols, but because of how they</span>
<span class="sd">        are cached, they already compare the same regardless of their</span>
<span class="sd">        bound symbols:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Lambda</span>
<span class="sd">        &gt;&gt;&gt; Lambda(x, x + 1) == Lambda(y, y + 1)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">can</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">bound_symbols</span><span class="p">}</span>
            <span class="c1"># mask free that shadow bound</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">canonical_variables</span>
            <span class="c1"># replace bound</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="c1"># undo masking</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;bound_symbols&#39;</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">can</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">canonical_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary mapping any variable defined in</span>
<span class="sd">        ``self.bound_symbols`` to Symbols that do not clash</span>
<span class="sd">        with any existing symbol in the expression.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Lambda</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; Lambda(x, 2*x).canonical_variables</span>
<span class="sd">        {x: _0}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="k">import</span> <span class="n">Symbol</span>
        <span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="k">import</span> <span class="n">numbered_symbols</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;bound_symbols&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="n">dums</span> <span class="o">=</span> <span class="n">numbered_symbols</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_symbols</span>
        <span class="c1"># this free will include bound symbols that are not part of</span>
        <span class="c1"># self&#39;s bound symbols</span>
        <span class="n">free</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">dums</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">free</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">dums</span><span class="p">)</span>
            <span class="n">reps</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">reps</span>

    <span class="k">def</span> <span class="nf">rcall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply on the argument recursively through the expression tree.</span>

<span class="sd">        This method is used to simulate a common abuse of notation for</span>
<span class="sd">        operators. For instance in SymPy the the following will not work:</span>

<span class="sd">        ``(x+Lambda(y, 2*y))(z) == x+2*z``,</span>

<span class="sd">        however you can use</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Lambda</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">        &gt;&gt;&gt; (x + Lambda(y, 2*y)).rcall(z)</span>
<span class="sd">        x + 2*z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Basic</span><span class="o">.</span><span class="n">_recursive_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_recursive_call</span><span class="p">(</span><span class="n">expr_to_call</span><span class="p">,</span> <span class="n">on_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper for rcall method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span>
        <span class="k">def</span> <span class="nf">the_call_method_is_overridden</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">getmro</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)):</span>
                <span class="k">if</span> <span class="s1">&#39;__call__&#39;</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">cls</span> <span class="o">!=</span> <span class="n">Basic</span>

        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">expr_to_call</span><span class="p">)</span> <span class="ow">and</span> <span class="n">the_call_method_is_overridden</span><span class="p">(</span><span class="n">expr_to_call</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr_to_call</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>  <span class="c1"># XXX When you call a Symbol it is</span>
                <span class="k">return</span> <span class="n">expr_to_call</span>               <span class="c1"># transformed into an UndefFunction</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">expr_to_call</span><span class="p">(</span><span class="o">*</span><span class="n">on_args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">expr_to_call</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">Basic</span><span class="o">.</span><span class="n">_recursive_call</span><span class="p">(</span>
                <span class="n">sub</span><span class="p">,</span> <span class="n">on_args</span><span class="p">)</span> <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">expr_to_call</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr_to_call</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr_to_call</span>

    <span class="k">def</span> <span class="nf">is_hypergeometric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="k">import</span> <span class="n">hypersimp</span>
        <span class="k">return</span> <span class="n">hypersimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_comparable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if self can be computed to a real number</span>
<span class="sd">        (or already is a real number) with precision, else False.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import exp_polar, pi, I</span>
<span class="sd">        &gt;&gt;&gt; (I*exp_polar(I*pi/2)).is_comparable</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (I*exp_polar(I*pi*2)).is_comparable</span>
<span class="sd">        False</span>

<span class="sd">        A False result does not mean that `self` cannot be rewritten</span>
<span class="sd">        into a form that would be comparable. For example, the</span>
<span class="sd">        difference computed below is zero but without simplification</span>
<span class="sd">        it does not evaluate to a zero with precision:</span>

<span class="sd">        &gt;&gt;&gt; e = 2**pi*(1 + 2**pi)</span>
<span class="sd">        &gt;&gt;&gt; dif = e - e.expand()</span>
<span class="sd">        &gt;&gt;&gt; dif.is_comparable</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; dif.n(2)._prec</span>
<span class="sd">        1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span>
        <span class="k">if</span> <span class="n">is_real</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># don&#39;t re-eval numbers that are already evaluated since</span>
        <span class="c1"># this will create spurious precision</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Number</span> <span class="k">else</span> <span class="n">p</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Number</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
            <span class="c1"># if _prec = 1 we can&#39;t decide and if not,</span>
            <span class="c1"># the answer is False because numbers with</span>
            <span class="c1"># imaginary parts can&#39;t be compared</span>
            <span class="c1"># so return False</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The top-level function in an expression.</span>

<span class="sd">        The following should hold for all objects::</span>

<span class="sd">            &gt;&gt; x == x.func(*x.args)</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; a = 2*x</span>
<span class="sd">        &gt;&gt;&gt; a.func</span>
<span class="sd">        &lt;class &#39;sympy.core.mul.Mul&#39;&gt;</span>
<span class="sd">        &gt;&gt;&gt; a.args</span>
<span class="sd">        (2, x)</span>
<span class="sd">        &gt;&gt;&gt; a.func(*a.args)</span>
<span class="sd">        2*x</span>
<span class="sd">        &gt;&gt;&gt; a == a.func(*a.args)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a tuple of arguments of &#39;self&#39;.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import cot</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">        &gt;&gt;&gt; cot(x).args</span>
<span class="sd">        (x,)</span>

<span class="sd">        &gt;&gt;&gt; cot(x).args[0]</span>
<span class="sd">        x</span>

<span class="sd">        &gt;&gt;&gt; (x*y).args</span>
<span class="sd">        (x, y)</span>

<span class="sd">        &gt;&gt;&gt; (x*y).args[1]</span>
<span class="sd">        y</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        Never use self._args, always use self.args.</span>
<span class="sd">        Only use _args in __new__ when creating a new function.</span>
<span class="sd">        Don&#39;t override .args() from Basic (so that it&#39;s easy to</span>
<span class="sd">        change the interface in the future if needed).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_sorted_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The same as ``args``.  Derived classes which don&#39;t fix an</span>
<span class="sd">        order on their arguments should override this method to</span>
<span class="sd">        produce the sorted representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>


    <span class="k">def</span> <span class="nf">as_poly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts ``self`` to a polynomial or returns ``None``.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import sin</span>
<span class="sd">           &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">           &gt;&gt;&gt; print((x**2 + x*y).as_poly())</span>
<span class="sd">           Poly(x**2 + x*y, x, y, domain=&#39;ZZ&#39;)</span>

<span class="sd">           &gt;&gt;&gt; print((x**2 + x*y).as_poly(x, y))</span>
<span class="sd">           Poly(x**2 + x*y, x, y, domain=&#39;ZZ&#39;)</span>

<span class="sd">           &gt;&gt;&gt; print((x**2 + sin(y)).as_poly(x, y))</span>
<span class="sd">           None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="k">import</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">PolynomialError</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">poly</span><span class="o">.</span><span class="n">is_Poly</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">poly</span>
        <span class="k">except</span> <span class="n">PolynomialError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">as_content_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A stub to allow Basic args (like Tuple) to be skipped when computing</span>
<span class="sd">        the content and primitive components of an expression.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        sympy.core.expr.Expr.as_content_primitive</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">subs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Substitutes old for new in an expression after sympifying args.</span>

<span class="sd">        `args` is either:</span>
<span class="sd">          - two arguments, e.g. foo.subs(old, new)</span>
<span class="sd">          - one iterable argument, e.g. foo.subs(iterable). The iterable may be</span>
<span class="sd">             o an iterable container with (old, new) pairs. In this case the</span>
<span class="sd">               replacements are processed in the order given with successive</span>
<span class="sd">               patterns possibly affecting replacements already made.</span>
<span class="sd">             o a dict or set whose key/value items correspond to old/new pairs.</span>
<span class="sd">               In this case the old/new pairs will be sorted by op count and in</span>
<span class="sd">               case of a tie, by number of args and the default_sort_key. The</span>
<span class="sd">               resulting sorted list is then processed as an iterable container</span>
<span class="sd">               (see previous).</span>

<span class="sd">        If the keyword ``simultaneous`` is True, the subexpressions will not be</span>
<span class="sd">        evaluated until all the substitutions have been made.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import pi, exp, limit, oo</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; (1 + x*y).subs(x, pi)</span>
<span class="sd">        pi*y + 1</span>
<span class="sd">        &gt;&gt;&gt; (1 + x*y).subs({x:pi, y:2})</span>
<span class="sd">        1 + 2*pi</span>
<span class="sd">        &gt;&gt;&gt; (1 + x*y).subs([(x, pi), (y, 2)])</span>
<span class="sd">        1 + 2*pi</span>
<span class="sd">        &gt;&gt;&gt; reps = [(y, x**2), (x, 2)]</span>
<span class="sd">        &gt;&gt;&gt; (x + y).subs(reps)</span>
<span class="sd">        6</span>
<span class="sd">        &gt;&gt;&gt; (x + y).subs(reversed(reps))</span>
<span class="sd">        x**2 + 2</span>

<span class="sd">        &gt;&gt;&gt; (x**2 + x**4).subs(x**2, y)</span>
<span class="sd">        y**2 + y</span>

<span class="sd">        To replace only the x**2 but not the x**4, use xreplace:</span>

<span class="sd">        &gt;&gt;&gt; (x**2 + x**4).xreplace({x**2: y})</span>
<span class="sd">        x**4 + y</span>

<span class="sd">        To delay evaluation until all substitutions have been made,</span>
<span class="sd">        set the keyword ``simultaneous`` to True:</span>

<span class="sd">        &gt;&gt;&gt; (x/y).subs([(x, 0), (y, 0)])</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; (x/y).subs([(x, 0), (y, 0)], simultaneous=True)</span>
<span class="sd">        nan</span>

<span class="sd">        This has the added feature of not allowing subsequent substitutions</span>
<span class="sd">        to affect those already made:</span>

<span class="sd">        &gt;&gt;&gt; ((x + y)/y).subs({x + y: y, y: x + y})</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)</span>
<span class="sd">        y/(x + y)</span>

<span class="sd">        In order to obtain a canonical result, unordered iterables are</span>
<span class="sd">        sorted by count_op length, number of arguments and by the</span>
<span class="sd">        default_sort_key to break any ties. All other iterables are left</span>
<span class="sd">        unsorted.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sqrt, sin, cos</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import a, b, c, d, e</span>

<span class="sd">        &gt;&gt;&gt; A = (sqrt(sin(2*x)), a)</span>
<span class="sd">        &gt;&gt;&gt; B = (sin(2*x), b)</span>
<span class="sd">        &gt;&gt;&gt; C = (cos(2*x), c)</span>
<span class="sd">        &gt;&gt;&gt; D = (x, d)</span>
<span class="sd">        &gt;&gt;&gt; E = (exp(x), e)</span>

<span class="sd">        &gt;&gt;&gt; expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)</span>

<span class="sd">        &gt;&gt;&gt; expr.subs(dict([A, B, C, D, E]))</span>
<span class="sd">        a*c*sin(d*e) + b</span>

<span class="sd">        The resulting expression represents a literal replacement of the</span>
<span class="sd">        old arguments with the new arguments. This may not reflect the</span>
<span class="sd">        limiting behavior of the expression:</span>

<span class="sd">        &gt;&gt;&gt; (x**3 - 3*x).subs({x: oo})</span>
<span class="sd">        nan</span>

<span class="sd">        &gt;&gt;&gt; limit(x**3 - 3*x, x, oo)</span>
<span class="sd">        oo</span>

<span class="sd">        If the substitution will be followed by numerical</span>
<span class="sd">        evaluation, it is better to pass the substitution to</span>
<span class="sd">        evalf as</span>

<span class="sd">        &gt;&gt;&gt; (1/x).evalf(subs={x: 3.0}, n=21)</span>
<span class="sd">        0.333333333333333333333</span>

<span class="sd">        rather than</span>

<span class="sd">        &gt;&gt;&gt; (1/x).subs({x: 3.0}).evalf(21)</span>
<span class="sd">        0.333333333333333314830</span>

<span class="sd">        as the former will ensure that the desired level of precision is</span>
<span class="sd">        obtained.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        replace: replacement capable of doing wildcard-like matching,</span>
<span class="sd">                 parsing of match, and conditional replacements</span>
<span class="sd">        xreplace: exact node replacement in expr tree; also capable of</span>
<span class="sd">                  using matching rules</span>
<span class="sd">        evalf: calculates the given formula to a desired level of precision</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.core.containers</span> <span class="k">import</span> <span class="n">Dict</span>
        <span class="kn">from</span> <span class="nn">sympy.utilities</span> <span class="k">import</span> <span class="n">default_sort_key</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Symbol</span>

        <span class="n">unordered</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
                <span class="n">unordered</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="p">(</span><span class="n">Dict</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)):</span>
                <span class="n">unordered</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">sequence</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="k">import</span> <span class="n">filldedent</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                   When a single argument is passed to subs</span>
<span class="s2">                   it should be a dictionary of old: new pairs or an iterable</span>
<span class="s2">                   of (old, new) tuples.&quot;&quot;&quot;</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;subs accepts either 1 or 2 arguments&quot;</span><span class="p">)</span>

        <span class="n">sequence</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="c1"># when old is a string we prefer Symbol</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">sympify</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">string_types</span><span class="p">))</span>
                     <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>
            <span class="k">except</span> <span class="n">SympifyError</span><span class="p">:</span>
                <span class="c1"># if it can&#39;t be sympified, skip it</span>
                <span class="n">sequence</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>
            <span class="c1"># skip if there is no change</span>
            <span class="n">sequence</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">_aresame</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">sequence</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">unordered</span><span class="p">:</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">is_Atom</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sequence</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ops</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">count_ops</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="n">ops</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">o</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
                <span class="n">newseq</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="n">newseq</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                        <span class="nb">sorted</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]],</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">))</span>
                <span class="n">sequence</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">sequence</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">newseq</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">newseq</span><span class="p">,</span> <span class="n">d</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sequence</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">sequence</span><span class="o">.</span><span class="n">items</span><span class="p">()],</span>
                                  <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;simultaneous&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>  <span class="c1"># XXX should this be the default for dict subs?</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;hack2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="n">commutative</span><span class="o">=</span><span class="n">new</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">)</span>
                <span class="c1"># using d*m so Subs will be used on dummy variables</span>
                <span class="c1"># in things like Derivative(f(x, y), x) in which x</span>
                <span class="c1"># is both free and bound</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">rv</span><span class="o">.</span><span class="n">_subs</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">d</span><span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="n">reps</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span>
            <span class="n">reps</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>  <span class="c1"># get rid of m</span>
            <span class="k">return</span> <span class="n">rv</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">rv</span><span class="o">.</span><span class="n">_subs</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">return</span> <span class="n">rv</span>

    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">_subs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Substitutes an expression old -&gt; new.</span>

<span class="sd">        If self is not equal to old then _eval_subs is called.</span>
<span class="sd">        If _eval_subs doesn&#39;t want to make any special replacement</span>
<span class="sd">        then a None is received which indicates that the fallback</span>
<span class="sd">        should be applied wherein a search for replacements is made</span>
<span class="sd">        amongst the arguments of self.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Add</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        Add&#39;s _eval_subs knows how to target x + y in the following</span>
<span class="sd">        so it makes the change:</span>

<span class="sd">            &gt;&gt;&gt; (x + y + z).subs(x + y, 1)</span>
<span class="sd">            z + 1</span>

<span class="sd">        Add&#39;s _eval_subs doesn&#39;t need to know how to find x + y in</span>
<span class="sd">        the following:</span>

<span class="sd">            &gt;&gt;&gt; Add._eval_subs(z*(x + y) + 3, x + y, 1) is None</span>
<span class="sd">            True</span>

<span class="sd">        The returned None will cause the fallback routine to traverse the args and</span>
<span class="sd">        pass the z*(x + y) arg to Mul where the change will take place and the</span>
<span class="sd">        substitution will succeed:</span>

<span class="sd">            &gt;&gt;&gt; (z*(x + y) + 3).subs(x + y, 1)</span>
<span class="sd">            z + 3</span>

<span class="sd">        ** Developers Notes **</span>

<span class="sd">        An _eval_subs routine for a class should be written if:</span>

<span class="sd">            1) any arguments are not instances of Basic (e.g. bool, tuple);</span>

<span class="sd">            2) some arguments should not be targeted (as in integration</span>
<span class="sd">               variables);</span>

<span class="sd">            3) if there is something other than a literal replacement</span>
<span class="sd">               that should be attempted (as in Piecewise where the condition</span>
<span class="sd">               may be updated without doing a replacement).</span>

<span class="sd">        If it is overridden, here are some special cases that might arise:</span>

<span class="sd">            1) If it turns out that no special change was made and all</span>
<span class="sd">               the original sub-arguments should be checked for</span>
<span class="sd">               replacements then None should be returned.</span>

<span class="sd">            2) If it is necessary to do substitutions on a portion of</span>
<span class="sd">               the expression then _subs should be called. _subs will</span>
<span class="sd">               handle the case of any sub-expression being equal to old</span>
<span class="sd">               (which usually would not be the case) while its fallback</span>
<span class="sd">               will handle the recursion into the sub-arguments. For</span>
<span class="sd">               example, after Add&#39;s _eval_subs removes some matching terms</span>
<span class="sd">               it must process the remaining terms so it calls _subs</span>
<span class="sd">               on each of the un-matched terms and then adds them</span>
<span class="sd">               onto the terms previously obtained.</span>

<span class="sd">           3) If the initial expression should remain unchanged then</span>
<span class="sd">              the original expression should be returned. (Whenever an</span>
<span class="sd">              expression is returned, modified or not, no further</span>
<span class="sd">              substitution of old -&gt; new is attempted.) Sum&#39;s _eval_subs</span>
<span class="sd">              routine uses this strategy when a substitution is attempted</span>
<span class="sd">              on any of its summation variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">fallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Try to replace old with new in any of self&#39;s arguments.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;_eval_subs&#39;</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">_subs</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_aresame</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                    <span class="n">hit</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">if</span> <span class="n">hit</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="n">hack2</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;hack2&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">hack2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rv</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>  <span class="c1"># 2-arg hack</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
                    <span class="n">nonnumber</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                            <span class="n">coeff</span> <span class="o">*=</span> <span class="n">i</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">nonnumber</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">nonnumber</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">nonnumber</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">nonnumber</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">nonnumber</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">rv</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">_aresame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">new</span>

        <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_subs</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">fallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rv</span>

    <span class="k">def</span> <span class="nf">_eval_subs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override this stub if you want to do anything more than</span>
<span class="sd">        attempt a replacement of old with new in the arguments of self.</span>

<span class="sd">        See also: _subs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace occurrences of objects within the expression.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        rule : dict-like</span>
<span class="sd">            Expresses a replacement rule</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        xreplace : the result of the replacement</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols, pi, exp</span>
<span class="sd">        &gt;&gt;&gt; x, y, z = symbols(&#39;x y z&#39;)</span>
<span class="sd">        &gt;&gt;&gt; (1 + x*y).xreplace({x: pi})</span>
<span class="sd">        pi*y + 1</span>
<span class="sd">        &gt;&gt;&gt; (1 + x*y).xreplace({x: pi, y: 2})</span>
<span class="sd">        1 + 2*pi</span>

<span class="sd">        Replacements occur only if an entire node in the expression tree is</span>
<span class="sd">        matched:</span>

<span class="sd">        &gt;&gt;&gt; (x*y + z).xreplace({x*y: pi})</span>
<span class="sd">        z + pi</span>
<span class="sd">        &gt;&gt;&gt; (x*y*z).xreplace({x*y: pi})</span>
<span class="sd">        x*y*z</span>
<span class="sd">        &gt;&gt;&gt; (2*x).xreplace({2*x: y, x: z})</span>
<span class="sd">        y</span>
<span class="sd">        &gt;&gt;&gt; (2*2*x).xreplace({2*x: y, x: z})</span>
<span class="sd">        4*z</span>
<span class="sd">        &gt;&gt;&gt; (x + y + 2).xreplace({x + y: 2})</span>
<span class="sd">        x + y + 2</span>
<span class="sd">        &gt;&gt;&gt; (x + 2 + exp(x + 2)).xreplace({x + 2: y})</span>
<span class="sd">        x + exp(y) + 2</span>

<span class="sd">        xreplace doesn&#39;t differentiate between free and bound symbols. In the</span>
<span class="sd">        following, subs(x, y) would not change x since it is a bound symbol,</span>
<span class="sd">        but xreplace does:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">        &gt;&gt;&gt; Integral(x, (x, 1, 2*x)).xreplace({x: y})</span>
<span class="sd">        Integral(y, (y, 1, 2*y))</span>

<span class="sd">        Trying to replace x with an expression raises an error:</span>

<span class="sd">        &gt;&gt;&gt; Integral(x, (x, 1, 2*x)).xreplace({x: 2*y}) # doctest: +SKIP</span>
<span class="sd">        ValueError: Invalid limits given: ((2*y, 1, 4*y),)</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        replace: replacement capable of doing wildcard-like matching,</span>
<span class="sd">                 parsing of match, and conditional replacements</span>
<span class="sd">        subs: substitution of subexpressions as defined by the objects</span>
<span class="sd">              themselves.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xreplace</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_xreplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper for xreplace. Tracks whether a replacement actually occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">rule</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rule</span><span class="p">[</span><span class="bp">self</span><span class="p">],</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">rule</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">_xreplace</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;_xreplace&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">_xreplace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">a_xr</span> <span class="o">=</span> <span class="n">_xreplace</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_xr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">changed</span> <span class="o">|=</span> <span class="n">a_xr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="kc">False</span>

    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">has</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">patterns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether any subexpression matches any of the patterns.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">        &gt;&gt;&gt; (x**2 + sin(x*y)).has(z)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; (x**2 + sin(x*y)).has(x, y, z)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x.has(x)</span>
<span class="sd">        True</span>

<span class="sd">        Note ``has`` is a structural algorithm with no knowledge of</span>
<span class="sd">        mathematics. Consider the following half-open interval:</span>

<span class="sd">        &gt;&gt;&gt; from sympy.sets import Interval</span>
<span class="sd">        &gt;&gt;&gt; i = Interval.Lopen(0, 5); i</span>
<span class="sd">        Interval.Lopen(0, 5)</span>
<span class="sd">        &gt;&gt;&gt; i.args</span>
<span class="sd">        (0, 5, True, False)</span>
<span class="sd">        &gt;&gt;&gt; i.has(4)  # there is no &quot;4&quot; in the arguments</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; i.has(0)  # there *is* a &quot;0&quot; in the arguments</span>
<span class="sd">        True</span>

<span class="sd">        Instead, use ``contains`` to determine whether a number is in the</span>
<span class="sd">        interval or not:</span>

<span class="sd">        &gt;&gt;&gt; i.contains(4)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; i.contains(0)</span>
<span class="sd">        False</span>


<span class="sd">        Note that ``expr.has(*patterns)`` is exactly equivalent to</span>
<span class="sd">        ``any(expr.has(p) for p in patterns)``. In particular, ``False`` is</span>
<span class="sd">        returned when the list of patterns is empty.</span>

<span class="sd">        &gt;&gt;&gt; x.has()</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_has</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_has</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper for .has()&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="k">import</span> <span class="n">UndefinedFunction</span><span class="p">,</span> <span class="n">Function</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">UndefinedFunction</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">func</span> <span class="o">==</span> <span class="n">pattern</span> <span class="ow">or</span> <span class="n">f</span> <span class="o">==</span> <span class="n">pattern</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="n">UndefinedFunction</span><span class="p">))</span>

        <span class="n">pattern</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">BasicMeta</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">_has_matcher</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="s1">&#39;_has_matcher&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_has_matcher</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">_has_matcher</span><span class="p">()</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">arg</span> <span class="o">==</span> <span class="n">pattern</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_has_matcher</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper for .has()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">other</span><span class="p">:</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace matching subexpressions of ``self`` with ``value``.</span>

<span class="sd">        If ``map = True`` then also return the mapping {old: new} where ``old``</span>
<span class="sd">        was a sub-expression found with query and ``new`` is the replacement</span>
<span class="sd">        value for it. If the expression itself doesn&#39;t match the query, then</span>
<span class="sd">        the returned value will be ``self.xreplace(map)`` otherwise it should</span>
<span class="sd">        be ``self.subs(ordered(map.items()))``.</span>

<span class="sd">        Traverses an expression tree and performs replacement of matching</span>
<span class="sd">        subexpressions from the bottom to the top of the tree. The default</span>
<span class="sd">        approach is to do the replacement in a simultaneous fashion so</span>
<span class="sd">        changes made are targeted only once. If this is not desired or causes</span>
<span class="sd">        problems, ``simultaneous`` can be set to False. In addition, if an</span>
<span class="sd">        expression containing more than one Wild symbol is being used to match</span>
<span class="sd">        subexpressions and  the ``exact`` flag is True, then the match will only</span>
<span class="sd">        succeed if non-zero values are received for each Wild that appears in</span>
<span class="sd">        the match pattern.</span>

<span class="sd">        The list of possible combinations of queries and replacement values</span>
<span class="sd">        is listed below:</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        Initial setup</span>

<span class="sd">            &gt;&gt;&gt; from sympy import log, sin, cos, tan, Wild, Mul, Add</span>
<span class="sd">            &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">            &gt;&gt;&gt; f = log(sin(x)) + tan(sin(x**2))</span>

<span class="sd">        1.1. type -&gt; type</span>
<span class="sd">            obj.replace(type, newtype)</span>

<span class="sd">            When object of type ``type`` is found, replace it with the</span>
<span class="sd">            result of passing its argument(s) to ``newtype``.</span>

<span class="sd">            &gt;&gt;&gt; f.replace(sin, cos)</span>
<span class="sd">            log(cos(x)) + tan(cos(x**2))</span>
<span class="sd">            &gt;&gt;&gt; sin(x).replace(sin, cos, map=True)</span>
<span class="sd">            (cos(x), {sin(x): cos(x)})</span>
<span class="sd">            &gt;&gt;&gt; (x*y).replace(Mul, Add)</span>
<span class="sd">            x + y</span>

<span class="sd">        1.2. type -&gt; func</span>
<span class="sd">            obj.replace(type, func)</span>

<span class="sd">            When object of type ``type`` is found, apply ``func`` to its</span>
<span class="sd">            argument(s). ``func`` must be written to handle the number</span>
<span class="sd">            of arguments of ``type``.</span>

<span class="sd">            &gt;&gt;&gt; f.replace(sin, lambda arg: sin(2*arg))</span>
<span class="sd">            log(sin(2*x)) + tan(sin(2*x**2))</span>
<span class="sd">            &gt;&gt;&gt; (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))</span>
<span class="sd">            sin(2*x*y)</span>

<span class="sd">        2.1. pattern -&gt; expr</span>
<span class="sd">            obj.replace(pattern(wild), expr(wild))</span>

<span class="sd">            Replace subexpressions matching ``pattern`` with the expression</span>
<span class="sd">            written in terms of the Wild symbols in ``pattern``.</span>

<span class="sd">            &gt;&gt;&gt; a, b = map(Wild, &#39;ab&#39;)</span>
<span class="sd">            &gt;&gt;&gt; f.replace(sin(a), tan(a))</span>
<span class="sd">            log(tan(x)) + tan(tan(x**2))</span>
<span class="sd">            &gt;&gt;&gt; f.replace(sin(a), tan(a/2))</span>
<span class="sd">            log(tan(x/2)) + tan(tan(x**2/2))</span>
<span class="sd">            &gt;&gt;&gt; f.replace(sin(a), a)</span>
<span class="sd">            log(x) + tan(x**2)</span>
<span class="sd">            &gt;&gt;&gt; (x*y).replace(a*x, a)</span>
<span class="sd">            y</span>

<span class="sd">            Matching is exact by default when more than one Wild symbol</span>
<span class="sd">            is used: matching fails unless the match gives non-zero</span>
<span class="sd">            values for all Wild symbols:</span>

<span class="sd">            &gt;&gt;&gt; (2*x + y).replace(a*x + b, b - a)</span>
<span class="sd">            y - 2</span>
<span class="sd">            &gt;&gt;&gt; (2*x).replace(a*x + b, b - a)</span>
<span class="sd">            2*x</span>

<span class="sd">            When set to False, the results may be non-intuitive:</span>

<span class="sd">            &gt;&gt;&gt; (2*x).replace(a*x + b, b - a, exact=False)</span>
<span class="sd">            2/x</span>

<span class="sd">        2.2. pattern -&gt; func</span>
<span class="sd">            obj.replace(pattern(wild), lambda wild: expr(wild))</span>

<span class="sd">            All behavior is the same as in 2.1 but now a function in terms of</span>
<span class="sd">            pattern variables is used rather than an expression:</span>

<span class="sd">            &gt;&gt;&gt; f.replace(sin(a), lambda a: sin(2*a))</span>
<span class="sd">            log(sin(2*x)) + tan(sin(2*x**2))</span>

<span class="sd">        3.1. func -&gt; func</span>
<span class="sd">            obj.replace(filter, func)</span>

<span class="sd">            Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``</span>
<span class="sd">            is True.</span>

<span class="sd">            &gt;&gt;&gt; g = 2*sin(x**3)</span>
<span class="sd">            &gt;&gt;&gt; g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)</span>
<span class="sd">            4*sin(x**9)</span>

<span class="sd">        The expression itself is also targeted by the query but is done in</span>
<span class="sd">        such a fashion that changes are not made twice.</span>

<span class="sd">            &gt;&gt;&gt; e = x*(x*y + 1)</span>
<span class="sd">            &gt;&gt;&gt; e.replace(lambda x: x.is_Mul, lambda x: 2*x)</span>
<span class="sd">            2*x*(2*x*y + 1)</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        subs: substitution of subexpressions as defined by the objects</span>
<span class="sd">              themselves.</span>
<span class="sd">        xreplace: exact node replacement in expr tree; also capable of</span>
<span class="sd">                  using matching rules</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="k">import</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Wild</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify.simplify</span> <span class="k">import</span> <span class="n">bottom_up</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SympifyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SympifyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">_query</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="n">_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">value</span><span class="p">(</span><span class="o">*</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">value</span><span class="p">(</span><span class="o">*</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;given a type, replace() expects another &quot;</span>
                    <span class="s2">&quot;type or a callable&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
            <span class="n">_query</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
            <span class="n">exact</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Wild</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">exact</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">exact</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
                    <span class="n">_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">else</span> <span class="n">expr</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="c1"># match dictionary keys get the trailing underscore stripped</span>
                <span class="c1"># from them and are then passed as keywords to the callable;</span>
                <span class="c1"># if ``exact`` is True, only accept match if there are no null</span>
                <span class="c1"># values amongst those matched.</span>
                <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
                    <span class="n">_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="o">**</span>
                        <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
                        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">else</span> <span class="n">expr</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">value</span><span class="p">(</span><span class="o">**</span>
                        <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;given an expression, replace() expects &quot;</span>
                    <span class="s2">&quot;another expression or a callable&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
            <span class="n">_query</span> <span class="o">=</span> <span class="n">query</span>

            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">value</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;given a callable, replace() expects &quot;</span>
                    <span class="s2">&quot;another callable&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;first argument to replace() must be a &quot;</span>
                <span class="s2">&quot;type, an expression or a callable&quot;</span><span class="p">)</span>

        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># changes that took place</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the dummies that were used as change placeholders</span>

        <span class="k">def</span> <span class="nf">rec_replace</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_query</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">or</span> <span class="n">result</span> <span class="o">==</span> <span class="p">{}:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">_value</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new</span> <span class="o">!=</span> <span class="n">expr</span><span class="p">:</span>
                    <span class="n">mapping</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span>
                    <span class="k">if</span> <span class="n">simultaneous</span><span class="p">:</span>
                        <span class="c1"># don&#39;t let this expression be changed during rebuilding</span>
                        <span class="n">com</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="s1">&#39;is_commutative&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">com</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">com</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="n">commutative</span><span class="o">=</span><span class="n">com</span><span class="p">)</span>
                        <span class="n">mask</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">new</span><span class="p">))</span>
                        <span class="n">expr</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">expr</span> <span class="o">=</span> <span class="n">new</span>
            <span class="k">return</span> <span class="n">expr</span>

        <span class="n">rv</span> <span class="o">=</span> <span class="n">bottom_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rec_replace</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># restore original expressions for Dummy symbols</span>
        <span class="k">if</span> <span class="n">simultaneous</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="n">o</span><span class="p">:</span> <span class="n">n</span><span class="p">}</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">rv</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">map</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rv</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">simultaneous</span><span class="p">:</span>
                <span class="c1"># restore subexpressions in mapping</span>
                <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="n">o</span><span class="p">:</span> <span class="n">n</span><span class="p">}</span>
                    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">r</span><span class="p">):</span> <span class="n">v</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">return</span> <span class="n">rv</span><span class="p">,</span> <span class="n">mapping</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find all subexpressions matching a query. &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">_make_find_query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">group</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">groups</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Count the number of matching subexpressions. &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">_make_find_query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">query</span><span class="p">(</span><span class="n">sub</span><span class="p">))</span> <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">repl_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">old</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method for match() that looks for a match between Wild symbols</span>
<span class="sd">        in self and expressions in expr.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols, Wild, Basic</span>
<span class="sd">        &gt;&gt;&gt; a, b, c = symbols(&#39;a b c&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x = Wild(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; Basic(a + x, x).matches(Basic(a + b, c)) is None</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Basic(a + x, x).matches(Basic(a + b + c, b + c))</span>
<span class="sd">        {x_: b + c}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">expr</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">repl_dict</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">repl_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">other_arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="n">other_arg</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">other_arg</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="n">old</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pattern matching.</span>

<span class="sd">        Wild symbols match all.</span>

<span class="sd">        Return ``None`` when expression (self) does not match</span>
<span class="sd">        with pattern. Otherwise return a dictionary such that::</span>

<span class="sd">          pattern.xreplace(self.match(pattern)) == self</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Wild</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; p = Wild(&quot;p&quot;)</span>
<span class="sd">        &gt;&gt;&gt; q = Wild(&quot;q&quot;)</span>
<span class="sd">        &gt;&gt;&gt; r = Wild(&quot;r&quot;)</span>
<span class="sd">        &gt;&gt;&gt; e = (x+y)**(x+y)</span>
<span class="sd">        &gt;&gt;&gt; e.match(p**p)</span>
<span class="sd">        {p_: x + y}</span>
<span class="sd">        &gt;&gt;&gt; e.match(p**q)</span>
<span class="sd">        {p_: x + y, q_: x + y}</span>
<span class="sd">        &gt;&gt;&gt; e = (2*x)**2</span>
<span class="sd">        &gt;&gt;&gt; e.match(p*q**r)</span>
<span class="sd">        {p_: 4, q_: x, r_: 2}</span>
<span class="sd">        &gt;&gt;&gt; (p*q**r).xreplace(e.match(p*q**r))</span>
<span class="sd">        4*x**2</span>

<span class="sd">        The ``old`` flag will give the old-style pattern matching where</span>
<span class="sd">        expressions and patterns are essentially solved to give the</span>
<span class="sd">        match. Both of the following give None unless ``old=True``:</span>

<span class="sd">        &gt;&gt;&gt; (x - 2).match(p - x, old=True)</span>
<span class="sd">        {p_: 2*x - 2}</span>
<span class="sd">        &gt;&gt;&gt; (2/x).match(p*x, old=True)</span>
<span class="sd">        {p_: 2/x**2}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pattern</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="n">old</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">count_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visual</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;wrapper for count_ops that returns the operation count.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">count_ops</span>
        <span class="k">return</span> <span class="n">count_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visual</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate objects that are not evaluated by default like limits,</span>
<span class="sd">           integrals, sums and products. All objects of this kind will be</span>
<span class="sd">           evaluated recursively, unless some species were excluded via &#39;hints&#39;</span>
<span class="sd">           or unless the &#39;deep&#39; hint was set to &#39;False&#39;.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">           &gt;&gt;&gt; from sympy.abc import x</span>

<span class="sd">           &gt;&gt;&gt; 2*Integral(x, x)</span>
<span class="sd">           2*Integral(x, x)</span>

<span class="sd">           &gt;&gt;&gt; (2*Integral(x, x)).doit()</span>
<span class="sd">           x**2</span>

<span class="sd">           &gt;&gt;&gt; (2*Integral(x, x)).doit(deep=False)</span>
<span class="sd">           2*Integral(x, x)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;deep&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">term</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Basic</span><span class="p">)</span> <span class="k">else</span> <span class="n">term</span>
                                         <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">terms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_eval_rewrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">)()</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;deep&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">_eval_rewrite</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Basic</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span>
                        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>

        <span class="k">if</span> <span class="n">pattern</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">):</span>
                <span class="n">rewritten</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rewritten</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">rewritten</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;evaluate&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_accept_eval_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="c1"># This method needs to be overridden by array-like objects</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">_visit_eval_derivative_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_visit_eval_derivative_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="c1"># Base is a scalar</span>
        <span class="c1"># Types are (base: scalar, self: scalar)</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">_eval_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_visit_eval_derivative_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="c1"># Types are (base: array/matrix, self: scalar)</span>
        <span class="c1"># Base is some kind of array/matrix,</span>
        <span class="c1"># it should have `.applyfunc(lambda x: x.diff(self)` implemented:</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">_eval_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_derivative_n_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># This is the default evaluator for derivatives (as called by `diff`</span>
        <span class="c1"># and `Derivative`), it will attempt a loop to derive the expression</span>
        <span class="c1"># `n` times by calling the corresponding `_eval_derivative` method,</span>
        <span class="c1"># while leaving the derivative unevaluated if `n` is symbolic.  This</span>
        <span class="c1"># method should be overridden if the object has a closed form for its</span>
        <span class="c1"># symbolic n-th derivative.</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Integer</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">Integer</span><span class="p">)):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">obj2</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_accept_eval_derivative</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="n">obj2</span> <span class="ow">or</span> <span class="n">obj2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">obj2</span>
            <span class="k">return</span> <span class="n">obj2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">rewrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Rewrite functions in terms of other functions.</span>

<span class="sd">        Rewrites expression containing applications of functions</span>
<span class="sd">        of one kind in terms of functions of different kind. For</span>
<span class="sd">        example you can rewrite trigonometric functions as complex</span>
<span class="sd">        exponentials or combinatorial functions as gamma function.</span>

<span class="sd">        As a pattern this function accepts a list of functions to</span>
<span class="sd">        to rewrite (instances of DefinedFunction class). As rule</span>
<span class="sd">        you can use string or a destination function instance (in</span>
<span class="sd">        this case rewrite() will use the str() function).</span>

<span class="sd">        There is also the possibility to pass hints on how to rewrite</span>
<span class="sd">        the given expressions. For now there is only one such hint</span>
<span class="sd">        defined called &#39;deep&#39;. When &#39;deep&#39; is set to False it will</span>
<span class="sd">        forbid functions to rewrite their contents.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, exp</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>

<span class="sd">        Unspecified pattern:</span>

<span class="sd">        &gt;&gt;&gt; sin(x).rewrite(exp)</span>
<span class="sd">        -I*(exp(I*x) - exp(-I*x))/2</span>

<span class="sd">        Pattern as a single function:</span>

<span class="sd">        &gt;&gt;&gt; sin(x).rewrite(sin, exp)</span>
<span class="sd">        -I*(exp(I*x) - exp(-I*x))/2</span>

<span class="sd">        Pattern as a list of functions:</span>

<span class="sd">        &gt;&gt;&gt; sin(x).rewrite([sin, ], exp)</span>
<span class="sd">        -I*(exp(I*x) - exp(-I*x))/2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">rule</span> <span class="o">=</span> <span class="s1">&#39;_eval_rewrite_as_&#39;</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">rule</span> <span class="o">=</span> <span class="s1">&#39;_eval_rewrite_as_&#39;</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">rule</span> <span class="o">=</span> <span class="s1">&#39;_eval_rewrite_as_&#39;</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_rewrite</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">pattern</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pattern</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>

                <span class="k">if</span> <span class="n">pattern</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_rewrite</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pattern</span><span class="p">),</span> <span class="n">rule</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span>

    <span class="n">_constructor_postprocessor_mapping</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_exec_constructor_postprocessors</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="c1"># WARNING: This API is experimental.</span>

        <span class="c1"># This is an experimental API that introduces constructor</span>
        <span class="c1"># postprosessors for SymPy Core elements. If an argument of a SymPy</span>
        <span class="c1"># expression has a `_constructor_postprocessor_mapping` attribute, it will</span>
        <span class="c1"># be interpreted as a dictionary containing lists of postprocessing</span>
        <span class="c1"># functions for matching expression node names.</span>

        <span class="n">clsname</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">postprocessors</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">postprocessor_mappings</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">Basic</span><span class="o">.</span><span class="n">_constructor_postprocessor_mapping</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">mro</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">Basic</span><span class="o">.</span><span class="n">_constructor_postprocessor_mapping</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">postprocessor_mappings</span><span class="p">):</span>
                    <span class="n">postprocessors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">v</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">postprocessors</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">postprocessors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">clsname</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">obj</span>


<span class="k">class</span> <span class="nc">Atom</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A parent class for atomic things. An atom is an expression with no subexpressions.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    Symbol, Number, Rational, Integer, ...</span>
<span class="sd">    But not: Add, Mul, Pow, ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_Atom</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">repl_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">old</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">expr</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">repl_dict</span>

    <span class="k">def</span> <span class="nf">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">hack2</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">rule</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">class_key</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_key</span><span class="p">(),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),)),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

    <span class="k">def</span> <span class="nf">_eval_simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">measure</span><span class="p">,</span> <span class="n">rational</span><span class="p">,</span> <span class="n">inverse</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_sorted_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># this is here as a safeguard against accidentally using _sorted_args</span>
        <span class="c1"># on Atoms -- they cannot be rebuilt as atom.func(*atom._sorted_args)</span>
        <span class="c1"># since there are no args. So the calling routine should be checking</span>
        <span class="c1"># to see that this property is not called for Atoms.</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Atoms have no args. It might be necessary&#39;</span>
        <span class="s1">&#39; to make a check for Atoms in the calling code.&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_aresame</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if a and b are structurally the same, else False.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    To SymPy, 2.0 == 2:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import S</span>
<span class="sd">    &gt;&gt;&gt; 2.0 == S(2)</span>
<span class="sd">    True</span>

<span class="sd">    Since a simple &#39;same or not&#39; result is sometimes useful, this routine was</span>
<span class="sd">    written to provide that query:</span>

<span class="sd">    &gt;&gt;&gt; from sympy.core.basic import _aresame</span>
<span class="sd">    &gt;&gt;&gt; _aresame(S(2.0), S(2))</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.function</span> <span class="k">import</span> <span class="n">AppliedUndef</span><span class="p">,</span> <span class="n">UndefinedFunction</span> <span class="k">as</span> <span class="n">UndefFunc</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span><span class="n">preorder_traversal</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">UndefFunc</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">UndefFunc</span><span class="p">))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">))):</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">class_key</span><span class="p">()</span> <span class="o">!=</span> <span class="n">j</span><span class="o">.</span><span class="n">class_key</span><span class="p">():</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_atomic</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return atom-like quantities as far as substitution is</span>
<span class="sd">    concerned: Derivatives, Functions and Symbols. Don&#39;t</span>
<span class="sd">    return any &#39;atoms&#39; that are inside such quantities unless</span>
<span class="sd">    they also appear outside, too, unless `recursive` is True.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Derivative, Function, cos</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; from sympy.core.basic import _atomic</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; _atomic(x + y)</span>
<span class="sd">    {x, y}</span>
<span class="sd">    &gt;&gt;&gt; _atomic(x + f(y))</span>
<span class="sd">    {x, f(y)}</span>
<span class="sd">    &gt;&gt;&gt; _atomic(Derivative(f(x), x) + cos(x) + y)</span>
<span class="sd">    {y, cos(x), Derivative(f(x), x)}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Symbol</span>
    <span class="n">pot</span> <span class="o">=</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
        <span class="n">free</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="s2">&quot;free_symbols&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">free</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">e</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">atoms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pot</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="n">pot</span><span class="o">.</span><span class="n">skip</span><span class="p">()</span>
            <span class="k">continue</span>
        <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">free</span><span class="p">:</span>
            <span class="n">atoms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">Derivative</span><span class="p">,</span> <span class="n">Function</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">recursive</span><span class="p">:</span>
                <span class="n">pot</span><span class="o">.</span><span class="n">skip</span><span class="p">()</span>
            <span class="n">atoms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">atoms</span>


<span class="k">class</span> <span class="nc">preorder_traversal</span><span class="p">(</span><span class="n">Iterator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Do a pre-order traversal of a tree.</span>

<span class="sd">    This iterator recursively yields nodes that it has visited in a pre-order</span>
<span class="sd">    fashion. That is, it yields the current node then descends through the</span>
<span class="sd">    tree breadth-first to yield all of a node&#39;s children&#39;s pre-order</span>
<span class="sd">    traversal.</span>


<span class="sd">    For an expression, the order of the traversal depends on the order of</span>
<span class="sd">    .args, which in many cases can be arbitrary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    node : sympy expression</span>
<span class="sd">        The expression to traverse.</span>
<span class="sd">    keys : (default None) sort key(s)</span>
<span class="sd">        The key(s) used to sort args of Basic objects. When None, args of Basic</span>
<span class="sd">        objects are processed in arbitrary order. If key is defined, it will</span>
<span class="sd">        be passed along to ordered() as the only key(s) to use to sort the</span>
<span class="sd">        arguments; if ``key`` is simply True then the default keys of ordered</span>
<span class="sd">        will be used.</span>

<span class="sd">    Yields</span>
<span class="sd">    ======</span>
<span class="sd">    subtree : sympy expression</span>
<span class="sd">        All of the subtrees in the tree.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">    &gt;&gt;&gt; from sympy.core.basic import preorder_traversal</span>
<span class="sd">    &gt;&gt;&gt; x, y, z = symbols(&#39;x y z&#39;)</span>

<span class="sd">    The nodes are returned in the order that they are encountered unless key</span>
<span class="sd">    is given; simply passing key=True will guarantee that the traversal is</span>
<span class="sd">    unique.</span>

<span class="sd">    &gt;&gt;&gt; list(preorder_traversal((x + y)*z, keys=None)) # doctest: +SKIP</span>
<span class="sd">    [z*(x + y), z, x + y, y, x]</span>
<span class="sd">    &gt;&gt;&gt; list(preorder_traversal((x + y)*z, keys=True))</span>
<span class="sd">    [z*(x + y), z, x + y, x, y]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skip_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preorder_traversal</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_preorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">node</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip_flag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skip_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">keys</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;_argset&#39;</span><span class="p">):</span>
                <span class="c1"># LatticeOp keeps args as a set. We should use this if we</span>
                <span class="c1"># don&#39;t care about the order, to prevent unnecessary sorting.</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_argset</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span>
            <span class="k">if</span> <span class="n">keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">keys</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="n">ordered</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="n">ordered</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preorder_traversal</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">subtree</span>
        <span class="k">elif</span> <span class="n">iterable</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preorder_traversal</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">subtree</span>

    <span class="k">def</span> <span class="nf">skip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Skip yielding current node&#39;s (last yielded node&#39;s) subtrees.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.core import symbols</span>
<span class="sd">        &gt;&gt;&gt; from sympy.core.basic import preorder_traversal</span>
<span class="sd">        &gt;&gt;&gt; x, y, z = symbols(&#39;x y z&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pt = preorder_traversal((x+y*z)*z)</span>
<span class="sd">        &gt;&gt;&gt; for i in pt:</span>
<span class="sd">        ...     print(i)</span>
<span class="sd">        ...     if i == x+y*z:</span>
<span class="sd">        ...             pt.skip()</span>
<span class="sd">        z*(x + y*z)</span>
<span class="sd">        z</span>
<span class="sd">        x + y*z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skip_flag</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pt</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">def</span> <span class="nf">_make_find_query</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert the argument of Basic.find() into a callable&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">SympifyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">query</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright J. Taylor and others
      <span class="lastupdated">
        Last updated on Sep 25, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>