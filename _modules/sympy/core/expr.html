

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Selection &mdash; Selection Documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />


</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../algorithms/index.html">Non-randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../randomized/index.html">Randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../learning/index.html">Learning selection</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">selection</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>Selection</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sympy.core.expr</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">.sympify</span> <span class="k">import</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">_sympify</span><span class="p">,</span> <span class="n">SympifyError</span>
<span class="kn">from</span> <span class="nn">.basic</span> <span class="k">import</span> <span class="n">Basic</span><span class="p">,</span> <span class="n">Atom</span>
<span class="kn">from</span> <span class="nn">.singleton</span> <span class="k">import</span> <span class="n">S</span>
<span class="kn">from</span> <span class="nn">.evalf</span> <span class="k">import</span> <span class="n">EvalfMixin</span><span class="p">,</span> <span class="n">pure_complex</span>
<span class="kn">from</span> <span class="nn">.decorators</span> <span class="k">import</span> <span class="n">_sympifyit</span><span class="p">,</span> <span class="n">call_highest_priority</span>
<span class="kn">from</span> <span class="nn">.cache</span> <span class="k">import</span> <span class="n">cacheit</span>
<span class="kn">from</span> <span class="nn">.compatibility</span> <span class="k">import</span> <span class="n">reduce</span><span class="p">,</span> <span class="n">as_int</span><span class="p">,</span> <span class="n">default_sort_key</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">mpmath.libmp</span> <span class="k">import</span> <span class="n">mpf_log</span><span class="p">,</span> <span class="n">prec_to_dps</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>

<span class="k">class</span> <span class="nc">Expr</span><span class="p">(</span><span class="n">Basic</span><span class="p">,</span> <span class="n">EvalfMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for algebraic expressions.</span>

<span class="sd">    Everything that requires arithmetic operations to be defined</span>
<span class="sd">    should subclass this class, instead of Basic (which should be</span>
<span class="sd">    used only for argument storage and expression manipulation, i.e.</span>
<span class="sd">    pattern matching, substitutions, etc).</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    sympy.core.basic.Basic</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">is_scalar</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># self derivative is 1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_diff_wrt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if one can differentiate with respect to this</span>
<span class="sd">        object, else False.</span>

<span class="sd">        Subclasses such as Symbol, Function and Derivative return True</span>
<span class="sd">        to enable derivatives wrt them. The implementation in Derivative</span>
<span class="sd">        separates the Symbol and non-Symbol (_diff_wrt=True) variables and</span>
<span class="sd">        temporarily converts the non-Symbols into Symbols when performing</span>
<span class="sd">        the differentiation. By default, any object deriving from Expr</span>
<span class="sd">        will behave like a scalar with self.diff(self) == 1. If this is</span>
<span class="sd">        not desired then the object must also set `is_scalar = False` or</span>
<span class="sd">        else define an _eval_derivative routine.</span>

<span class="sd">        Note, see the docstring of Derivative for how this should work</span>
<span class="sd">        mathematically. In particular, note that expr.subs(yourclass, Symbol)</span>
<span class="sd">        should be well-defined on a structural level, or this will lead to</span>
<span class="sd">        inconsistent results.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Expr</span>
<span class="sd">        &gt;&gt;&gt; e = Expr()</span>
<span class="sd">        &gt;&gt;&gt; e._diff_wrt</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; class MyScalar(Expr):</span>
<span class="sd">        ...     _diff_wrt = True</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; MyScalar().diff(MyScalar())</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; class MySymbol(Expr):</span>
<span class="sd">        ...     _diff_wrt = True</span>
<span class="sd">        ...     is_scalar = False</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; MySymbol().diff(MySymbol())</span>
<span class="sd">        Derivative(MySymbol(), MySymbol())</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">coeff</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">expr</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Dummy</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(),)</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">),)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_ordered_terms</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_ordered_factors</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span>

            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span> <span class="p">])</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">class_key</span><span class="p">(),</span> <span class="n">args</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">coeff</span>

    <span class="c1"># ***************</span>
    <span class="c1"># * Arithmetics *</span>
    <span class="c1"># ***************</span>
    <span class="c1"># Expr and its sublcasses use _op_priority to determine which object</span>
    <span class="c1"># passed to a binary special method (__mul__, etc.) will handle the</span>
    <span class="c1"># operation. In general, the &#39;call_highest_priority&#39; decorator will choose</span>
    <span class="c1"># the object with the highest _op_priority to handle the call.</span>
    <span class="c1"># Custom subclasses that want to define their own binary special methods</span>
    <span class="c1"># should set an _op_priority value that is higher than the default.</span>
    <span class="c1">#</span>
    <span class="c1"># **NOTE**:</span>
    <span class="c1"># This is a temporary fix, and will eventually be replaced with</span>
    <span class="c1"># something better and more powerful.  See issue 5510.</span>
    <span class="n">_op_priority</span> <span class="o">=</span> <span class="mf">10.0</span>

    <span class="k">def</span> <span class="nf">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Abs</span>
        <span class="k">return</span> <span class="n">Abs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__radd__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__add__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__rsub__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__sub__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__rmul__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__mul__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__rpow__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">mod</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mod</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pow</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">as_int</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">as_int</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">as_int</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">other</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">pow</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="k">import</span> <span class="n">mod_inverse</span>
                <span class="k">return</span> <span class="n">mod_inverse</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="o">-</span><span class="n">other</span><span class="p">,</span> <span class="n">mod</span><span class="p">),</span> <span class="n">mod</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pow</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">power</span><span class="o">%</span><span class="n">mod</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__pow__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__rdiv__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Pow</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">))</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__div__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">))</span>

    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">__div__</span>
    <span class="fm">__rtruediv__</span> <span class="o">=</span> <span class="n">__rdiv__</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__rmod__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__mod__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mod</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__rfloordiv__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.integers</span> <span class="k">import</span> <span class="n">floor</span>
        <span class="k">return</span> <span class="n">floor</span><span class="p">(</span><span class="bp">self</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__floordiv__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.integers</span> <span class="k">import</span> <span class="n">floor</span>
        <span class="k">return</span> <span class="n">floor</span><span class="p">(</span><span class="n">other</span> <span class="o">/</span> <span class="bp">self</span><span class="p">)</span>


    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__rdivmod__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__divmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.integers</span> <span class="k">import</span> <span class="n">floor</span>
        <span class="k">return</span> <span class="n">floor</span><span class="p">(</span><span class="bp">self</span> <span class="o">/</span> <span class="n">other</span><span class="p">),</span> <span class="n">Mod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s1">&#39;__divmod__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rdivmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.integers</span> <span class="k">import</span> <span class="n">floor</span>
        <span class="k">return</span> <span class="n">floor</span><span class="p">(</span><span class="n">other</span> <span class="o">/</span> <span class="bp">self</span><span class="p">),</span> <span class="n">Mod</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Although we only need to round to the units position, we&#39;ll</span>
        <span class="c1"># get one more digit so the extra testing below can be avoided</span>
        <span class="c1"># unless the rounded value rounded to an integer, e.g. if an</span>
        <span class="c1"># expression were equal to 1.9 and we rounded to the unit position</span>
        <span class="c1"># we would get a 2 and would not know if this rounded up or not</span>
        <span class="c1"># without doing a test (as done below). But if we keep an extra</span>
        <span class="c1"># digit we know that 1.9 is not the same as 1 and there is no</span>
        <span class="c1"># need for further testing: our int value is correct. If the value</span>
        <span class="c1"># were 1.99, however, this would round to 2.0 and our int value is</span>
        <span class="c1"># off by one. So...if our round value is the same as the int value</span>
        <span class="c1"># (regardless of how much extra work we do to calculate extra decimal</span>
        <span class="c1"># places) we need to test whether we are off by one.</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Dummy</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can&#39;t convert symbols to int&quot;</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can&#39;t convert complex to int&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">in</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can&#39;t convert </span><span class="si">%s</span><span class="s2"> to int&quot;</span> <span class="o">%</span> <span class="n">r</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="c1"># off-by-one check</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">r</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">isign</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
            <span class="c1"># in the following (self - i).evalf(2) will not always work while</span>
            <span class="c1"># (self - r).evalf(2) and the use of subs does; if the test that</span>
            <span class="c1"># was added when this comment was added passes, it might be safe</span>
            <span class="c1"># to simply use sign to compute this rather than doing this by hand:</span>
            <span class="n">diff_sign</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">i</span><span class="p">})</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">diff_sign</span> <span class="o">!=</span> <span class="n">isign</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">-=</span> <span class="n">isign</span>
        <span class="k">return</span> <span class="n">i</span>
    <span class="n">__long__</span> <span class="o">=</span> <span class="fm">__int__</span>

    <span class="k">def</span> <span class="nf">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Don&#39;t bother testing if it&#39;s a number; if it&#39;s not this is going</span>
        <span class="c1"># to fail, and if it is we still need to check that it evalf&#39;ed to</span>
        <span class="c1"># a number.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can&#39;t convert complex to float&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can&#39;t convert expression to float&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">re</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">GreaterThan</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SympifyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid comparison </span><span class="si">%s</span><span class="s2"> &gt;= </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">me</span><span class="o">.</span><span class="n">is_complex</span> <span class="ow">and</span> <span class="n">me</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid comparison of complex </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">me</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">me</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid NaN comparison&quot;</span><span class="p">)</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">_n2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">n2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
            <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                    <span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sympify</span><span class="p">(</span><span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GreaterThan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">LessThan</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SympifyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid comparison </span><span class="si">%s</span><span class="s2"> &lt;= </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">me</span><span class="o">.</span><span class="n">is_complex</span> <span class="ow">and</span> <span class="n">me</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid comparison of complex </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">me</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">me</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid NaN comparison&quot;</span><span class="p">)</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">_n2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">n2</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
            <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                    <span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sympify</span><span class="p">(</span><span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LessThan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">StrictGreaterThan</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SympifyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid comparison </span><span class="si">%s</span><span class="s2"> &gt; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">me</span><span class="o">.</span><span class="n">is_complex</span> <span class="ow">and</span> <span class="n">me</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid comparison of complex </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">me</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">me</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid NaN comparison&quot;</span><span class="p">)</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">_n2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">n2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
            <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                    <span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sympify</span><span class="p">(</span><span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">StrictGreaterThan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">StrictLessThan</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SympifyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid comparison </span><span class="si">%s</span><span class="s2"> &lt; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">me</span><span class="o">.</span><span class="n">is_complex</span> <span class="ow">and</span> <span class="n">me</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid comparison of complex </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">me</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">me</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid NaN comparison&quot;</span><span class="p">)</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">_n2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">n2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
            <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                    <span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sympify</span><span class="p">(</span><span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">StrictLessThan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__trunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can&#39;t truncate symbols and expressions&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_from_mpmath</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Float</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;_mpf_&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;_mpc_&quot;</span><span class="p">):</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_mpc_</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span>
            <span class="k">return</span> <span class="n">re</span> <span class="o">+</span> <span class="n">im</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected mpmath number (mpf or mpc)&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if ``self`` has no free symbols and no</span>
<span class="sd">        undefined functions (AppliedUndef, to be precise). It will be</span>
<span class="sd">        faster than ``if not self.free_symbols``, however, since</span>
<span class="sd">        ``is_number`` will fail as soon as it hits a free symbol</span>
<span class="sd">        or undefined function.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import log, Integral, cos, sin, pi</span>
<span class="sd">        &gt;&gt;&gt; from sympy.core.function import Function</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>

<span class="sd">        &gt;&gt;&gt; x.is_number</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; f(1).is_number</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; (2*x).is_number</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; (2 + Integral(2, x)).is_number</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; (2 + Integral(2, (x, 1, 2))).is_number</span>
<span class="sd">        True</span>

<span class="sd">        Not all numbers are Numbers in the SymPy sense:</span>

<span class="sd">        &gt;&gt;&gt; pi.is_number, pi.is_Number</span>
<span class="sd">        (True, False)</span>

<span class="sd">        If something is a number it should evaluate to a number with</span>
<span class="sd">        real and imaginary parts that are Numbers; the result may not</span>
<span class="sd">        be comparable, however, since the real and/or imaginary part</span>
<span class="sd">        of the result may not have precision.</span>

<span class="sd">        &gt;&gt;&gt; cos(1).is_number and cos(1).is_comparable</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; z = cos(1)**2 + sin(1)**2 - 1</span>
<span class="sd">        &gt;&gt;&gt; z.is_number</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; z.is_comparable</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        sympy.core.basic.is_comparable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">is_number</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">re_min</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">im_min</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">re_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">im_max</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self evaluated, if possible, replacing free symbols with</span>
<span class="sd">        random complex values, if necessary.</span>

<span class="sd">        The random complex value for each free symbol is generated</span>
<span class="sd">        by the random_complex_number routine giving real and imaginary</span>
<span class="sd">        parts in the range given by the re_min, re_max, im_min, and im_max</span>
<span class="sd">        values. The returned value is evaluated to a precision of n</span>
<span class="sd">        (if given) else the maximum of 15 and the precision needed</span>
<span class="sd">        to get more than 1 digit of precision. If the expression</span>
<span class="sd">        could not be evaluated to a number, or could not be evaluated</span>
<span class="sd">        to more than 1 digit of precision, then None is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; x._random()                         # doctest: +SKIP</span>
<span class="sd">        0.0392918155679172 + 0.916050214307199*I</span>
<span class="sd">        &gt;&gt;&gt; x._random(2)                        # doctest: +SKIP</span>
<span class="sd">        -0.77 - 0.87*I</span>
<span class="sd">        &gt;&gt;&gt; (x + y/2)._random(2)                # doctest: +SKIP</span>
<span class="sd">        -0.57 + 0.16*I</span>
<span class="sd">        &gt;&gt;&gt; sqrt(2)._random(2)</span>
<span class="sd">        1.4</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        sympy.utilities.randtest.random_complex_number</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">free</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="n">prec</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">free</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sympy.utilities.randtest</span> <span class="k">import</span> <span class="n">random_complex_number</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">re_min</span><span class="p">,</span> <span class="n">re_max</span><span class="p">,</span> <span class="n">im_min</span><span class="p">,</span> <span class="n">im_max</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="p">[</span><span class="n">random_complex_number</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">zi</span> <span class="ow">in</span> <span class="n">free</span><span class="p">])))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nmag</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="n">reps</span><span class="p">))</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="c1"># if an out of range value resulted in evalf problems</span>
                <span class="c1"># then return None -- XXX is there a way to know how to</span>
                <span class="c1"># select a good random number for a given expression?</span>
                <span class="c1"># e.g. when calculating n! negative values for n should not</span>
                <span class="c1"># be used</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">nmag</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">nmag</span><span class="p">,</span> <span class="s1">&#39;_prec&#39;</span><span class="p">):</span>
            <span class="c1"># e.g. exp_polar(2*I*pi) doesn&#39;t evaluate but is_number is True</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">nmag</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># increase the precision up to the default maximum</span>
            <span class="c1"># precision to see if we can get any significance</span>

            <span class="kn">from</span> <span class="nn">mpmath.libmp.libintmath</span> <span class="k">import</span> <span class="n">giant_steps</span>
            <span class="kn">from</span> <span class="nn">sympy.core.evalf</span> <span class="k">import</span> <span class="n">DEFAULT_MAXPREC</span> <span class="k">as</span> <span class="n">target</span>

            <span class="c1"># evaluate</span>
            <span class="k">for</span> <span class="n">prec</span> <span class="ow">in</span> <span class="n">giant_steps</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
                <span class="n">nmag</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="n">reps</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">nmag</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">nmag</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="n">reps</span><span class="p">)</span>

        <span class="c1"># never got any significance</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">wrt</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if self is constant, False if not, or None if</span>
<span class="sd">        the constancy could not be determined conclusively.</span>

<span class="sd">        If an expression has no free symbols then it is a constant. If</span>
<span class="sd">        there are free symbols it is possible that the expression is a</span>
<span class="sd">        constant, perhaps (but not necessarily) zero. To test such</span>
<span class="sd">        expressions, two strategies are tried:</span>

<span class="sd">        1) numerical evaluation at two random points. If two such evaluations</span>
<span class="sd">        give two different values and the values have a precision greater than</span>
<span class="sd">        1 then self is not constant. If the evaluations agree or could not be</span>
<span class="sd">        obtained with any precision, no decision is made. The numerical testing</span>
<span class="sd">        is done only if ``wrt`` is different than the free symbols.</span>

<span class="sd">        2) differentiation with respect to variables in &#39;wrt&#39; (or all free</span>
<span class="sd">        symbols if omitted) to see if the expression is constant or not. This</span>
<span class="sd">        will not always lead to an expression that is zero even though an</span>
<span class="sd">        expression is constant (see added test in test_expr.py). If</span>
<span class="sd">        all derivatives are zero then self is constant with respect to the</span>
<span class="sd">        given symbols.</span>

<span class="sd">        If neither evaluation nor differentiation can prove the expression is</span>
<span class="sd">        constant, None is returned unless two numerical values happened to be</span>
<span class="sd">        the same and the flag ``failing_number`` is True -- in that case the</span>
<span class="sd">        numerical value will be returned.</span>

<span class="sd">        If flag simplify=False is passed, self will not be simplified;</span>
<span class="sd">        the default is True since self should be simplified before testing.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import cos, sin, Sum, S, pi</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import a, n, x, y</span>
<span class="sd">        &gt;&gt;&gt; x.is_constant()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; S(2).is_constant()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, 10)).is_constant()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, n)).is_constant()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, n)).is_constant(y)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, n)).is_constant(n)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Sum(x, (x, 1, n)).is_constant(x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; eq = a*cos(x)**2 + a*sin(x)**2 - a</span>
<span class="sd">        &gt;&gt;&gt; eq.is_constant()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; (0**x).is_constant()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x.is_constant()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; (x**x).is_constant()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; one = cos(x)**2 + sin(x)**2</span>
<span class="sd">        &gt;&gt;&gt; one.is_constant()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">simplify</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">free</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">free</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># assume f(1) is some constant</span>

        <span class="c1"># if we are only interested in some symbols and they are not in the</span>
        <span class="c1"># free symbols then this expression is constant wrt those symbols</span>
        <span class="n">wrt</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">wrt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wrt</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wrt</span> <span class="o">&amp;</span> <span class="n">free</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">wrt</span> <span class="o">=</span> <span class="n">wrt</span> <span class="ow">or</span> <span class="n">free</span>

        <span class="c1"># simplify unless this has already been done</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

        <span class="c1"># is_zero should be a quick assumptions check; it can be wrong for</span>
        <span class="c1"># numbers (see test_is_not_constant test), giving False when it</span>
        <span class="c1"># shouldn&#39;t, but hopefully it will never give True unless it is sure.</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># try numerical evaluation to see if we get two different values</span>
        <span class="n">failing_number</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">wrt</span> <span class="o">==</span> <span class="n">free</span><span class="p">:</span>
            <span class="c1"># try 0 (for a) and 1 (for b)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">))),</span>
                    <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                    <span class="c1"># evaluation may succeed when substitution fails</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">))),</span>
                        <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                        <span class="c1"># evaluation may succeed when substitution fails</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="c1"># try random real</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="c1"># try random complex</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">_random</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="n">failing_number</span> <span class="o">=</span> <span class="n">a</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_number</span> <span class="k">else</span> <span class="n">b</span>

        <span class="c1"># now we will test each wrt symbol (or all free symbols) to see if the</span>
        <span class="c1"># expression depends on them or not using differentiation. This is</span>
        <span class="c1"># not sufficient for all expressions, however, so we don&#39;t return</span>
        <span class="c1"># False if we get a derivative other than 0 with free symbols.</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wrt</span><span class="p">:</span>
            <span class="n">deriv</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
                <span class="n">deriv</span> <span class="o">=</span> <span class="n">deriv</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">deriv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">pure_complex</span><span class="p">(</span><span class="n">deriv</span><span class="p">,</span> <span class="n">or_real</span><span class="o">=</span><span class="kc">True</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;failing_number&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">failing_number</span>
                    <span class="k">elif</span> <span class="n">deriv</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                        <span class="c1"># dead line provided _random returns None in such cases</span>
                        <span class="k">return</span> <span class="kc">None</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">failing_expression</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if self == other, False if it doesn&#39;t, or None. If</span>
<span class="sd">        failing_expression is True then the expression which did not simplify</span>
<span class="sd">        to a 0 will be returned instead of None.</span>

<span class="sd">        If ``self`` is a Number (or complex number) that is not zero, then</span>
<span class="sd">        the result is False.</span>

<span class="sd">        If ``self`` is a number and has not evaluated to zero, evalf will be</span>
<span class="sd">        used to test whether the expression evaluates to zero. If it does so</span>
<span class="sd">        and the result has significance (i.e. the precision is either -1, for</span>
<span class="sd">        a Rational result, or is greater than 1) then the evalf value will be</span>
<span class="sd">        used to return True or False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify.simplify</span> <span class="k">import</span> <span class="n">nsimplify</span><span class="p">,</span> <span class="n">simplify</span>
        <span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="k">import</span> <span class="n">solveset</span>
        <span class="kn">from</span> <span class="nn">sympy.polys.polyerrors</span> <span class="k">import</span> <span class="n">NotAlgebraic</span>
        <span class="kn">from</span> <span class="nn">sympy.polys.numberfields</span> <span class="k">import</span> <span class="n">minimal_polynomial</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># they aren&#39;t the same so see if we can make the difference 0;</span>
        <span class="c1"># don&#39;t worry about doing simplification steps one at a time</span>
        <span class="c1"># because if the expression ever goes to 0 then the subsequent</span>
        <span class="c1"># simplification steps that are done will be very fast.</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">factor_terms</span><span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">other</span><span class="p">),</span> <span class="n">radical</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">diff</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">diff</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Add</span><span class="p">,</span> <span class="n">Mod</span><span class="p">):</span>
            <span class="c1"># if there is no expanding to be done after simplifying</span>
            <span class="c1"># then this can&#39;t be a zero</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">constant</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">failing_number</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">constant</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">constant</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">diff</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="c1"># e.g. unless the right simplification is done, a symbolic</span>
            <span class="c1"># zero is possible (see expression of issue 6829: without</span>
            <span class="c1"># simplification constant will be None).</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">constant</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ndiff</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">_random</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ndiff</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># sometimes we can use a simplified result to give a clue as to</span>
        <span class="c1"># what the expression should be; if the expression is *not* zero</span>
        <span class="c1"># then we should have been able to compute that and so now</span>
        <span class="c1"># we can just consider the cases where the approximation appears</span>
        <span class="c1"># to be zero -- we try to prove it via minimal_polynomial.</span>
        <span class="k">if</span> <span class="n">diff</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="n">approx</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">nsimplify</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">approx</span><span class="p">:</span>
                <span class="c1"># try to prove via self-consistency</span>
                <span class="n">surds</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">diff</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Pow</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">]</span>
                <span class="c1"># it seems to work better to try big ones first</span>
                <span class="n">surds</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">surds</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># simplify is False here -- this expression has already</span>
                        <span class="c1"># been identified as being hard to identify as zero;</span>
                        <span class="c1"># we will handle the checking ourselves using nsimplify</span>
                        <span class="c1"># to see if we are in the right ballpark or not and if so</span>
                        <span class="c1"># *then* the simplification will be attempted.</span>
                        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                            <span class="n">sol</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">sol</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">sol</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">:</span>
                                <span class="k">return</span> <span class="kc">True</span>
                            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
                                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">nsimplify</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">==</span> <span class="n">s</span> <span class="ow">and</span> <span class="n">simplify</span><span class="p">(</span><span class="n">si</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span>
                                        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">):</span>
                                    <span class="k">return</span> <span class="kc">True</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="k">pass</span>

                <span class="c1"># try to prove with minimal_polynomial but know when</span>
                <span class="c1"># *not* to use this or else it can take a long time. e.g. issue 8354</span>
                <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>  <span class="c1"># change True to condition that assures non-hang</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">mp</span> <span class="o">=</span> <span class="n">minimal_polynomial</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mp</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                            <span class="k">return</span> <span class="kc">True</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">except</span> <span class="p">(</span><span class="n">NotAlgebraic</span><span class="p">,</span> <span class="ne">NotImplementedError</span><span class="p">):</span>
                        <span class="k">pass</span>

        <span class="c1"># diff has not simplified to zero; constant is either None, True</span>
        <span class="c1"># or the number with significance (prec != 1) that was randomly</span>
        <span class="c1"># calculated twice as the same value.</span>
        <span class="k">if</span> <span class="n">constant</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">constant</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">failing_expression</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">diff</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_eval_is_positive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.polys.numberfields</span> <span class="k">import</span> <span class="n">minimal_polynomial</span>
        <span class="kn">from</span> <span class="nn">sympy.polys.polyerrors</span> <span class="k">import</span> <span class="n">NotAlgebraic</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># check to see that we can get a value</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># XXX: This shouldn&#39;t be caught here</span>
            <span class="c1"># Catches ValueError: hypsum() failed to converge to the requested</span>
            <span class="c1"># 34 bits of accuracy</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">n2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="s1">&#39;_prec&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># no significance</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="ow">not</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">i</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">is_algebraic</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">minimal_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="k">except</span> <span class="p">(</span><span class="n">NotAlgebraic</span><span class="p">,</span> <span class="ne">NotImplementedError</span><span class="p">):</span>
                    <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_eval_is_negative</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.polys.numberfields</span> <span class="k">import</span> <span class="n">minimal_polynomial</span>
        <span class="kn">from</span> <span class="nn">sympy.polys.polyerrors</span> <span class="k">import</span> <span class="n">NotAlgebraic</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># check to see that we can get a value</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># XXX: This shouldn&#39;t be caught here</span>
            <span class="c1"># Catches ValueError: hypsum() failed to converge to the requested</span>
            <span class="c1"># 34 bits of accuracy</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">n2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="s1">&#39;_prec&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># no significance</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">_prec</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="ow">not</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">i</span><span class="o">.</span><span class="n">_prec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">is_algebraic</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">minimal_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="k">except</span> <span class="p">(</span><span class="n">NotAlgebraic</span><span class="p">,</span> <span class="ne">NotImplementedError</span><span class="p">):</span>
                    <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_eval_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns evaluation over an interval.  For most functions this is:</span>

<span class="sd">        self.subs(x, b) - self.subs(x, a),</span>

<span class="sd">        possibly using limit() if NaN is returned from subs, or if</span>
<span class="sd">        singularities are found between a and b.</span>

<span class="sd">        If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),</span>
<span class="sd">        respectively.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.series</span> <span class="k">import</span> <span class="n">limit</span><span class="p">,</span> <span class="n">Limit</span>
        <span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="k">import</span> <span class="n">solveset</span>
        <span class="kn">from</span> <span class="nn">sympy.sets.sets</span> <span class="k">import</span> <span class="n">Interval</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.exponential</span> <span class="k">import</span> <span class="n">log</span>
        <span class="kn">from</span> <span class="nn">sympy.calculus.util</span> <span class="k">import</span> <span class="n">AccumBounds</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Both interval ends cannot be None.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">ComplexInfinity</span><span class="p">,</span> <span class="n">AccumBounds</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">A</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Limit</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Could not compute limit&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">B</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">ComplexInfinity</span><span class="p">,</span> <span class="n">AccumBounds</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">B</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">B</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">Limit</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Could not compute limit&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="ow">and</span> <span class="n">b</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">B</span> <span class="o">-</span> <span class="n">A</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="n">A</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_comparable</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">is_comparable</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">domain</span> <span class="o">=</span> <span class="n">Interval</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">domain</span> <span class="o">=</span> <span class="n">Interval</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="c1"># check the singularities of self within the interval</span>
            <span class="c1"># if singularities is a ConditionSet (not iterable), catch the exception and pass</span>
            <span class="n">singularities</span> <span class="o">=</span> <span class="n">solveset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">logterm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">log</span><span class="p">):</span>
                <span class="n">singularities</span> <span class="o">=</span> <span class="n">singularities</span> <span class="o">|</span> <span class="n">solveset</span><span class="p">(</span><span class="n">logterm</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span>
                    <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">singularities</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                        <span class="c1"># no need to keep adding, it will stay NaN</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">is_comparable</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">+=</span> <span class="o">-</span><span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">+=</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_eval_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># subclass to compute self**other for cases when</span>
        <span class="c1"># other is not NaN, 0, or 1</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_eval_conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_imaginary</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span>

    <span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="k">import</span> <span class="n">conjugate</span> <span class="k">as</span> <span class="n">c</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="k">import</span> <span class="n">conjugate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_antihermitian</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="k">import</span> <span class="n">transpose</span>
        <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="k">import</span> <span class="n">conjugate</span><span class="p">,</span> <span class="n">transpose</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_antihermitian</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_conjugate</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_transpose</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conjugate</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="k">import</span> <span class="n">adjoint</span>
        <span class="k">return</span> <span class="n">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_parse_order</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse and configure the ordering of terms. &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys.orderings</span> <span class="k">import</span> <span class="n">monomial_key</span>

        <span class="n">startswith</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="s2">&quot;startswith&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">startswith</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reverse</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reverse</span> <span class="o">=</span> <span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;rev-&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>

        <span class="n">monom_key</span> <span class="o">=</span> <span class="n">monomial_key</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">neg</span><span class="p">(</span><span class="n">monom</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">monom</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neg</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">),</span> <span class="n">monom</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">)</span> <span class="o">=</span> <span class="n">term</span>

            <span class="n">monom</span> <span class="o">=</span> <span class="n">neg</span><span class="p">(</span><span class="n">monom_key</span><span class="p">(</span><span class="n">monom</span><span class="p">))</span>
            <span class="n">ncpart</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ncpart</span><span class="p">])</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="nb">bool</span><span class="p">(</span><span class="n">im</span><span class="p">),</span> <span class="n">im</span><span class="p">),</span> <span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">monom</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">,</span> <span class="n">coeff</span>

        <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">reverse</span>

    <span class="k">def</span> <span class="nf">as_ordered_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of ordered factors (if Mul) else [self].&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">as_ordered_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform an expression to an ordered list of terms.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, cos</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>

<span class="sd">        &gt;&gt;&gt; (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()</span>
<span class="sd">        [sin(x)**2*cos(x), sin(x)**2, 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">.numbers</span> <span class="k">import</span> <span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span>

        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="c1"># Spot the special case of Add(Number, Mul(Number, expr)) with the</span>
            <span class="c1"># first number positive and thhe second number nagative</span>
            <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">))</span>
            <span class="n">add_args</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">add_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">add_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">))</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">add_args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Mul</span><span class="p">)):</span>
                <span class="n">mul_args</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">add_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mul_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mul_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Number</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">add_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_positive</span>
                    <span class="ow">and</span> <span class="n">mul_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_negative</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">add_args</span>

        <span class="n">key</span><span class="p">,</span> <span class="n">reverse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_order</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="n">terms</span><span class="p">,</span> <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_terms</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">is_Order</span> <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">):</span>
            <span class="n">ordered</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_terms</span><span class="p">,</span> <span class="n">_order</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="nb">repr</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
                    <span class="n">_terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="nb">repr</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_order</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="nb">repr</span><span class="p">))</span>

            <span class="n">ordered</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">_terms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> \
                <span class="o">+</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">_order</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ordered</span><span class="p">,</span> <span class="n">gens</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">term</span> <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">as_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform an expression to a list of terms. &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.add</span> <span class="k">import</span> <span class="n">Add</span>
        <span class="kn">from</span> <span class="nn">.mul</span> <span class="k">import</span> <span class="n">Mul</span>
        <span class="kn">from</span> <span class="nn">.exprtools</span> <span class="k">import</span> <span class="n">decompose_power</span>

        <span class="n">gens</span><span class="p">,</span> <span class="n">terms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([]),</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">_term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>

            <span class="n">coeff</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
            <span class="n">cpart</span><span class="p">,</span> <span class="n">ncpart</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">_term</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">factor</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">coeff</span> <span class="o">*=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
                        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                            <span class="k">pass</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>

                    <span class="k">if</span> <span class="n">factor</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                        <span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">decompose_power</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

                        <span class="n">cpart</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp</span>
                        <span class="n">gens</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ncpart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

            <span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">coeff</span><span class="o">.</span><span class="n">imag</span>
            <span class="n">ncpart</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ncpart</span><span class="p">)</span>

            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">cpart</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">)))</span>

        <span class="n">gens</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">gens</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

        <span class="n">k</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">),</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gens</span><span class="p">):</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">cpart</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">)</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">monom</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">k</span>

            <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">cpart</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">monom</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">base</span><span class="p">]]</span> <span class="o">=</span> <span class="n">exp</span>

            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">monom</span><span class="p">),</span> <span class="n">ncpart</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">gens</span>

    <span class="k">def</span> <span class="nf">removeO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the additive O(..) symbol if there is one&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">getO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the additive O(..) symbol if there is one, else None.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">getn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the order of the expression.</span>

<span class="sd">        The order is determined either from the O(...) term. If there</span>
<span class="sd">        is no O(...) term, it returns None.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import O</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; (1 + x + O(x**2)).getn()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; (1 + x).getn()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Symbol</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">expr</span>
            <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">o</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>  <span class="c1"># x**n*log(x)**n or x**n/log(x)**n</span>
                <span class="k">for</span> <span class="n">oi</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">oi</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
                    <span class="k">if</span> <span class="n">oi</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                        <span class="n">syms</span> <span class="o">=</span> <span class="n">oi</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">oi</span> <span class="o">=</span> <span class="n">oi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                            <span class="k">if</span> <span class="n">oi</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">and</span> <span class="n">oi</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                                <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">oi</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;not sure of order of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">o</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">count_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visual</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;wrapper for count_ops that returns the operation count.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.function</span> <span class="k">import</span> <span class="n">count_ops</span>
        <span class="k">return</span> <span class="n">count_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visual</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">args_cnc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">split_1</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return [commutative factors, non-commutative factors] of self.</span>

<span class="sd">        self is treated as a Mul and the ordering of the factors is maintained.</span>
<span class="sd">        If ``cset`` is True the commutative factors will be returned in a set.</span>
<span class="sd">        If there were repeated factors (as may happen with an unevaluated Mul)</span>
<span class="sd">        then an error will be raised unless it is explicitly suppressed by</span>
<span class="sd">        setting ``warn`` to False.</span>

<span class="sd">        Note: -1 is always separated from a Number unless split_1 is False.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols, oo</span>
<span class="sd">        &gt;&gt;&gt; A, B = symbols(&#39;A B&#39;, commutative=0)</span>
<span class="sd">        &gt;&gt;&gt; x, y = symbols(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; (-2*x*y).args_cnc()</span>
<span class="sd">        [[-1, 2, x, y], []]</span>
<span class="sd">        &gt;&gt;&gt; (-2.5*x).args_cnc()</span>
<span class="sd">        [[-1, 2.5, x], []]</span>
<span class="sd">        &gt;&gt;&gt; (-2*x*A*B*y).args_cnc()</span>
<span class="sd">        [[-1, 2, x, y], [A, B]]</span>
<span class="sd">        &gt;&gt;&gt; (-2*x*A*B*y).args_cnc(split_1=False)</span>
<span class="sd">        [[-2, x, y], [A, B]]</span>
<span class="sd">        &gt;&gt;&gt; (-2*x*y).args_cnc(cset=True)</span>
<span class="sd">        [{-1, 2, x, y}, []]</span>

<span class="sd">        The arg is always treated as a Mul:</span>

<span class="sd">        &gt;&gt;&gt; (-2 + x + A).args_cnc()</span>
<span class="sd">        [[], [x - 2 + A]]</span>
<span class="sd">        &gt;&gt;&gt; (-oo).args_cnc() # -oo is a singleton</span>
<span class="sd">        [[-1, oo], []]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mi</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
                <span class="n">nc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">args</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">c</span> <span class="ow">and</span> <span class="n">split_1</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span>
            <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">and</span>
                <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">):</span>
            <span class="n">c</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">cset</span><span class="p">:</span>
            <span class="n">clen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">clen</span> <span class="ow">and</span> <span class="n">warn</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">clen</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;repeated commutative arguments: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                                 <span class="p">[</span><span class="n">ci</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">c</span> <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">nc</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coefficient from the term(s) containing ``x**n``. If ``n``</span>
<span class="sd">        is zero then all terms independent of ``x`` will be returned.</span>

<span class="sd">        When ``x`` is noncommutative, the coefficient to the left (default) or</span>
<span class="sd">        right of ``x`` can be returned. The keyword &#39;right&#39; is ignored when</span>
<span class="sd">        ``x`` is commutative.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        as_coefficient: separate the expression into a coefficient and factor</span>
<span class="sd">        as_coeff_Add: separate the additive constant from an expression</span>
<span class="sd">        as_coeff_Mul: separate the multiplicative constant from an expression</span>
<span class="sd">        as_independent: separate x-dependent terms/factors from others</span>
<span class="sd">        sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly</span>
<span class="sd">        sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>

<span class="sd">        You can select terms that have an explicit negative in front of them:</span>

<span class="sd">        &gt;&gt;&gt; (-x + 2*y).coeff(-1)</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; (x - 2*y).coeff(-1)</span>
<span class="sd">        2*y</span>

<span class="sd">        You can select terms with no Rational coefficient:</span>

<span class="sd">        &gt;&gt;&gt; (x + 2*y).coeff(1)</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(1)</span>
<span class="sd">        0</span>

<span class="sd">        You can select terms independent of x by making n=0; in this case</span>
<span class="sd">        expr.as_independent(x)[0] is returned (and 0 will be returned instead</span>
<span class="sd">        of None):</span>

<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(x, 0)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; eq = ((x + 1)**3).expand() + 1</span>
<span class="sd">        &gt;&gt;&gt; eq</span>
<span class="sd">        x**3 + 3*x**2 + 3*x + 2</span>
<span class="sd">        &gt;&gt;&gt; [eq.coeff(x, i) for i in reversed(range(4))]</span>
<span class="sd">        [1, 3, 3, 2]</span>
<span class="sd">        &gt;&gt;&gt; eq -= 2</span>
<span class="sd">        &gt;&gt;&gt; [eq.coeff(x, i) for i in reversed(range(4))]</span>
<span class="sd">        [1, 3, 3, 0]</span>

<span class="sd">        You can select terms that have a numerical term in front of them:</span>

<span class="sd">        &gt;&gt;&gt; (-x - 2*y).coeff(2)</span>
<span class="sd">        -y</span>
<span class="sd">        &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">        &gt;&gt;&gt; (x + sqrt(2)*x).coeff(sqrt(2))</span>
<span class="sd">        x</span>

<span class="sd">        The matching is exact:</span>

<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(x)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(x**2)</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; (3 + 2*x + 4*x**2).coeff(x**3)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; (z*(x + y)**2).coeff((x + y)**2)</span>
<span class="sd">        z</span>
<span class="sd">        &gt;&gt;&gt; (z*(x + y)**2).coeff(x + y)</span>
<span class="sd">        0</span>

<span class="sd">        In addition, no factoring is done, so 1 + z*(1 + y) is not obtained</span>
<span class="sd">        from the following:</span>

<span class="sd">        &gt;&gt;&gt; (x + z*(x + x*y)).coeff(x)</span>
<span class="sd">        1</span>

<span class="sd">        If such factoring is desired, factor_terms can be used first:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import factor_terms</span>
<span class="sd">        &gt;&gt;&gt; factor_terms(x + z*(x + x*y)).coeff(x)</span>
<span class="sd">        z*(y + 1) + 1</span>

<span class="sd">        &gt;&gt;&gt; n, m, o = symbols(&#39;n m o&#39;, commutative=False)</span>
<span class="sd">        &gt;&gt;&gt; n.coeff(n)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; (3*n).coeff(n)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; (n*m + m*n*m).coeff(n) # = (1 + m)*n*m</span>
<span class="sd">        1 + m</span>
<span class="sd">        &gt;&gt;&gt; (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m</span>
<span class="sd">        m</span>

<span class="sd">        If there is more than one possible coefficient 0 is returned:</span>

<span class="sd">        &gt;&gt;&gt; (n*m + m*n).coeff(n)</span>
<span class="sd">        0</span>

<span class="sd">        If there is only one possible coefficient, it is returned:</span>

<span class="sd">        &gt;&gt;&gt; (n*m + x*m*n).coeff(m*n)</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; (n*m + x*m*n).coeff(m*n, right=1)</span>
<span class="sd">        1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">as_int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="n">co</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">c</span><span class="p">)])</span>
                <span class="k">return</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">c</span><span class="p">)])</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># continue with the full method, looking for this power of x:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">n</span>

        <span class="k">def</span> <span class="nf">incommon</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">l1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">l2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">l2</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">l2</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="n">l1</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">l1</span><span class="p">[:]</span>

        <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Find where list sub appears in list l. When ``first`` is True</span>
<span class="sd">            the first occurrence from the left is returned, else the last</span>
<span class="sd">            occurrence is returned. Return None if sub is not in l.</span>

<span class="sd">            &gt;&gt; l = range(5)*2</span>
<span class="sd">            &gt;&gt; find(l, [2, 3])</span>
<span class="sd">            2</span>
<span class="sd">            &gt;&gt; find(l, [2, 3], first=0)</span>
<span class="sd">            7</span>
<span class="sd">            &gt;&gt; find(l, [2, 4])</span>
<span class="sd">            None</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sub</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">l</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">sub</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">sub</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">sub</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">i</span>

        <span class="n">co</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">self_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_commutative</span>
        <span class="n">x_c</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">is_commutative</span>
        <span class="k">if</span> <span class="n">self_c</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x_c</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="k">if</span> <span class="n">self_c</span><span class="p">:</span>
            <span class="n">xargs</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">margs</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">margs</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">resid</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">co</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">elif</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x_c</span><span class="p">:</span>
            <span class="n">xargs</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">margs</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">margs</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="n">nc</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">co</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">elif</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># both nc</span>
            <span class="n">xargs</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># find the parts that pass the commutative terms</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">margs</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">margs</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">resid</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>
            <span class="c1"># now check the non-comm parts</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">):</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">co</span><span class="p">]),</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][:</span><span class="n">ii</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">ii</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">):])</span>
            <span class="n">beg</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">incommon</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">beg</span><span class="p">:</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="n">gcdc</span> <span class="o">=</span> <span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">co</span><span class="p">)):</span>
                            <span class="n">gcdc</span> <span class="o">=</span> <span class="n">gcdc</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">co</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">gcdc</span><span class="p">:</span>
                                <span class="k">break</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">gcdc</span><span class="p">)</span> <span class="o">+</span> <span class="n">beg</span><span class="p">[:</span><span class="n">ii</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">ii</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="n">m</span><span class="p">:]))</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">])</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span>
                <span class="n">reduce</span><span class="p">(</span><span class="n">incommon</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">))))</span>
            <span class="k">if</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="o">+</span> <span class="n">ii</span><span class="p">]))</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">):])</span>
            <span class="c1"># look for single match</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">co</span><span class="p">):</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">hit</span><span class="p">:</span>
                        <span class="n">hit</span> <span class="o">=</span> <span class="n">ii</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hit</span><span class="p">:</span>
                    <span class="n">ii</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">hit</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">[:</span><span class="n">ii</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">):])</span>

            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="k">def</span> <span class="nf">as_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a polynomial to a SymPy expression.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">        &gt;&gt;&gt; f = (x**2 + x*y).as_poly(x, y)</span>
<span class="sd">        &gt;&gt;&gt; f.as_expr()</span>
<span class="sd">        x**2 + x*y</span>

<span class="sd">        &gt;&gt;&gt; sin(x).as_expr()</span>
<span class="sd">        sin(x)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">as_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts symbolic coefficient at the given expression. In</span>
<span class="sd">        other words, this functions separates &#39;self&#39; into the product</span>
<span class="sd">        of &#39;expr&#39; and &#39;expr&#39;-free coefficient. If such separation</span>
<span class="sd">        is not possible it will return None.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import E, pi, sin, I, Poly</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>

<span class="sd">        &gt;&gt;&gt; E.as_coefficient(E)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; (2*E).as_coefficient(E)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; (2*sin(E)*E).as_coefficient(E)</span>

<span class="sd">        Two terms have E in them so a sum is returned. (If one were</span>
<span class="sd">        desiring the coefficient of the term exactly matching E then</span>
<span class="sd">        the constant from the returned expression could be selected.</span>
<span class="sd">        Or, for greater precision, a method of Poly can be used to</span>
<span class="sd">        indicate the desired term from which the coefficient is</span>
<span class="sd">        desired.)</span>

<span class="sd">        &gt;&gt;&gt; (2*E + x*E).as_coefficient(E)</span>
<span class="sd">        x + 2</span>
<span class="sd">        &gt;&gt;&gt; _.args[0]  # just want the exact match</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; p = Poly(2*E + x*E); p</span>
<span class="sd">        Poly(x*E + 2*E, x, E, domain=&#39;ZZ&#39;)</span>
<span class="sd">        &gt;&gt;&gt; p.coeff_monomial(E)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; p.nth(0, 1)</span>
<span class="sd">        2</span>

<span class="sd">        Since the following cannot be written as a product containing</span>
<span class="sd">        E as a factor, None is returned. (If the coefficient ``2*x`` is</span>
<span class="sd">        desired then the ``coeff`` method should be used.)</span>

<span class="sd">        &gt;&gt;&gt; (2*E*x + x).as_coefficient(E)</span>
<span class="sd">        &gt;&gt;&gt; (2*E*x + x).coeff(E)</span>
<span class="sd">        2*x</span>

<span class="sd">        &gt;&gt;&gt; (E*(x + 1) + x).as_coefficient(E)</span>

<span class="sd">        &gt;&gt;&gt; (2*pi*I).as_coefficient(pi*I)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; (2*I).as_coefficient(pi*I)</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        coeff: return sum of terms have a given factor</span>
<span class="sd">        as_coeff_Add: separate the additive constant from an expression</span>
<span class="sd">        as_coeff_Mul: separate the multiplicative constant from an expression</span>
<span class="sd">        as_independent: separate x-dependent terms/factors from others</span>
<span class="sd">        sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly</span>
<span class="sd">        sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">as_independent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">deps</span><span class="p">,</span> <span class="o">**</span><span class="n">hint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A mostly naive separation of a Mul or Add into arguments that are not</span>
<span class="sd">        are dependent on deps. To obtain as complete a separation of variables</span>
<span class="sd">        as possible, use a separation method first, e.g.:</span>

<span class="sd">        * separatevars() to change Mul, Add and Pow (including exp) into Mul</span>
<span class="sd">        * .expand(mul=True) to change Add or Mul into Add</span>
<span class="sd">        * .expand(log=True) to change log expr into an Add</span>

<span class="sd">        The only non-naive thing that is done here is to respect noncommutative</span>
<span class="sd">        ordering of variables and to always return (0, 0) for `self` of zero</span>
<span class="sd">        regardless of hints.</span>

<span class="sd">        For nonzero `self`, the returned tuple (i, d) has the</span>
<span class="sd">        following interpretation:</span>

<span class="sd">        * i will has no variable that appears in deps</span>
<span class="sd">        * d will either have terms that contain variables that are in deps, or</span>
<span class="sd">          be equal to 0 (when self is an Add) or 1 (when self is a Mul)</span>
<span class="sd">        * if self is an Add then self = i + d</span>
<span class="sd">        * if self is a Mul then self = i*d</span>
<span class="sd">        * otherwise (self, S.One) or (S.One, self) is returned.</span>

<span class="sd">        To force the expression to be treated as an Add, use the hint as_Add=True</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        -- self is an Add</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, cos, exp</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>

<span class="sd">        &gt;&gt;&gt; (x + x*y).as_independent(x)</span>
<span class="sd">        (0, x*y + x)</span>
<span class="sd">        &gt;&gt;&gt; (x + x*y).as_independent(y)</span>
<span class="sd">        (x, x*y)</span>
<span class="sd">        &gt;&gt;&gt; (2*x*sin(x) + y + x + z).as_independent(x)</span>
<span class="sd">        (y + z, 2*x*sin(x) + x)</span>
<span class="sd">        &gt;&gt;&gt; (2*x*sin(x) + y + x + z).as_independent(x, y)</span>
<span class="sd">        (z, 2*x*sin(x) + x + y)</span>

<span class="sd">        -- self is a Mul</span>

<span class="sd">        &gt;&gt;&gt; (x*sin(x)*cos(y)).as_independent(x)</span>
<span class="sd">        (cos(y), x*sin(x))</span>

<span class="sd">        non-commutative terms cannot always be separated out when self is a Mul</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; n1, n2, n3 = symbols(&#39;n1 n2 n3&#39;, commutative=False)</span>
<span class="sd">        &gt;&gt;&gt; (n1 + n1*n2).as_independent(n2)</span>
<span class="sd">        (n1, n1*n2)</span>
<span class="sd">        &gt;&gt;&gt; (n2*n1 + n1*n2).as_independent(n2)</span>
<span class="sd">        (0, n1*n2 + n2*n1)</span>
<span class="sd">        &gt;&gt;&gt; (n1*n2*n3).as_independent(n1)</span>
<span class="sd">        (1, n1*n2*n3)</span>
<span class="sd">        &gt;&gt;&gt; (n1*n2*n3).as_independent(n2)</span>
<span class="sd">        (n1, n2*n3)</span>
<span class="sd">        &gt;&gt;&gt; ((x-n1)*(x-y)).as_independent(x)</span>
<span class="sd">        (1, (x - y)*(x - n1))</span>

<span class="sd">        -- self is anything else:</span>

<span class="sd">        &gt;&gt;&gt; (sin(x)).as_independent(x)</span>
<span class="sd">        (1, sin(x))</span>
<span class="sd">        &gt;&gt;&gt; (sin(x)).as_independent(y)</span>
<span class="sd">        (sin(x), 1)</span>
<span class="sd">        &gt;&gt;&gt; exp(x+y).as_independent(x)</span>
<span class="sd">        (1, exp(x + y))</span>

<span class="sd">        -- force self to be treated as an Add:</span>

<span class="sd">        &gt;&gt;&gt; (3*x).as_independent(x, as_Add=True)</span>
<span class="sd">        (0, 3*x)</span>

<span class="sd">        -- force self to be treated as a Mul:</span>

<span class="sd">        &gt;&gt;&gt; (3+x).as_independent(x, as_Add=False)</span>
<span class="sd">        (1, x + 3)</span>
<span class="sd">        &gt;&gt;&gt; (-3+x).as_independent(x, as_Add=False)</span>
<span class="sd">        (1, x - 3)</span>

<span class="sd">        Note how the below differs from the above in making the</span>
<span class="sd">        constant on the dep term positive.</span>

<span class="sd">        &gt;&gt;&gt; (y*(-3+x)).as_independent(x)</span>
<span class="sd">        (y, x - 3)</span>

<span class="sd">        -- use .as_independent() for true independence testing instead</span>
<span class="sd">           of .has(). The former considers only symbols in the free</span>
<span class="sd">           symbols while the latter considers all symbols</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">        &gt;&gt;&gt; I = Integral(x, (x, 1, 2))</span>
<span class="sd">        &gt;&gt;&gt; I.has(x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x in I.free_symbols</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; I.as_independent(x) == (I, 1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (I + x).as_independent(x) == (I, x)</span>
<span class="sd">        True</span>

<span class="sd">        Note: when trying to get independent terms, a separation method</span>
<span class="sd">        might need to be used first. In this case, it is important to keep</span>
<span class="sd">        track of what you send to this routine so you know how to interpret</span>
<span class="sd">        the returned values</span>

<span class="sd">        &gt;&gt;&gt; from sympy import separatevars, log</span>
<span class="sd">        &gt;&gt;&gt; separatevars(exp(x+y)).as_independent(x)</span>
<span class="sd">        (exp(y), exp(x))</span>
<span class="sd">        &gt;&gt;&gt; (x + x*y).as_independent(y)</span>
<span class="sd">        (x, x*y)</span>
<span class="sd">        &gt;&gt;&gt; separatevars(x + x*y).as_independent(y)</span>
<span class="sd">        (x, y + 1)</span>
<span class="sd">        &gt;&gt;&gt; (x*(1 + y)).as_independent(y)</span>
<span class="sd">        (x, y + 1)</span>
<span class="sd">        &gt;&gt;&gt; (x*(1 + y)).expand(mul=True).as_independent(y)</span>
<span class="sd">        (x, x*y)</span>
<span class="sd">        &gt;&gt;&gt; a, b=symbols(&#39;a b&#39;, positive=True)</span>
<span class="sd">        &gt;&gt;&gt; (log(a*b).expand(log=True)).as_independent(b)</span>
<span class="sd">        (log(a), log(b))</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        .separatevars(), .expand(log=True), Add.as_two_terms(),</span>
<span class="sd">        Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.symbol</span> <span class="k">import</span> <span class="n">Symbol</span>
        <span class="kn">from</span> <span class="nn">.add</span> <span class="k">import</span> <span class="n">_unevaluated_Add</span>
        <span class="kn">from</span> <span class="nn">.mul</span> <span class="k">import</span> <span class="n">_unevaluated_Mul</span>
        <span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="k">import</span> <span class="n">sift</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span>
        <span class="k">if</span> <span class="n">hint</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;as_Add&#39;</span><span class="p">,</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">want</span> <span class="o">=</span> <span class="n">Add</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">want</span> <span class="o">=</span> <span class="n">Mul</span>

        <span class="c1"># sift out deps into symbolic and other and ignore</span>
        <span class="c1"># all symbols but those that are in the free symbols</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>  <span class="c1"># Symbol.is_Symbol is True</span>
                <span class="n">sym</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">has</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;return the standard has() if there are no literal symbols, else</span>
<span class="sd">            check to see that symbol-deps are in the free symbols.&quot;&quot;&quot;</span>
            <span class="n">has_other</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sym</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">has_other</span>
            <span class="k">return</span> <span class="n">has_other</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">sym</span><span class="p">))</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">func</span> <span class="ow">or</span>
                <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Add</span> <span class="ow">and</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Mul</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">has</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">want</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">want</span><span class="o">.</span><span class="n">identity</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">Add</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">sift</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">depend</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span>
        <span class="n">indep</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">Add</span><span class="p">:</span>  <span class="c1"># all terms were treated as commutative</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">indep</span><span class="p">),</span> <span class="n">_unevaluated_Add</span><span class="p">(</span><span class="o">*</span><span class="n">depend</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># handle noncommutative by stopping at first dependent term</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">has</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">depend</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nc</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
                    <span class="k">break</span>
                <span class="n">indep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">indep</span><span class="p">),</span> <span class="p">(</span>
                <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">depend</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">if</span> <span class="n">nc</span> <span class="k">else</span>
                <span class="n">_unevaluated_Mul</span><span class="p">(</span><span class="o">*</span><span class="n">depend</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">as_real_imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs complex expansion on &#39;self&#39; and returns a tuple</span>
<span class="sd">           containing collected both real and imaginary parts. This</span>
<span class="sd">           method can&#39;t be confused with re() and im() functions,</span>
<span class="sd">           which does not perform complex expansion at evaluation.</span>

<span class="sd">           However it is possible to expand both re() and im()</span>
<span class="sd">           functions and get exactly the same results as with</span>
<span class="sd">           a single call to this function.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import symbols, I</span>

<span class="sd">           &gt;&gt;&gt; x, y = symbols(&#39;x,y&#39;, real=True)</span>

<span class="sd">           &gt;&gt;&gt; (x + y*I).as_real_imag()</span>
<span class="sd">           (x, y)</span>

<span class="sd">           &gt;&gt;&gt; from sympy.abc import z, w</span>

<span class="sd">           &gt;&gt;&gt; (z + w*I).as_real_imag()</span>
<span class="sd">           (re(z) - im(w), re(w) + im(z))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">im</span><span class="p">,</span> <span class="n">re</span>
        <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">re</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">im</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">as_powers_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self as a dictionary of factors with each factor being</span>
<span class="sd">        treated as a power. The keys are the bases of the factors and the</span>
<span class="sd">        values, the corresponding exponents. The resulting dictionary should</span>
<span class="sd">        be used with caution if the expression is a Mul and contains non-</span>
<span class="sd">        commutative factors since the order that they appeared will be lost in</span>
<span class="sd">        the dictionary.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        as_ordered_factors: An alternative for noncommutative applications,</span>
<span class="sd">                            returning an ordered list of factors.</span>
<span class="sd">        args_cnc: Similar to as_ordered_factors, but guarantees separation</span>
<span class="sd">                  of commutative and noncommutative factors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()]))</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">as_coefficients_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary mapping terms to their Rational coefficient.</span>
<span class="sd">        Since the dictionary is a defaultdict, inquiries about terms which</span>
<span class="sd">        were not present will return a coefficient of 0. If an expression is</span>
<span class="sd">        not an Add it is considered to have a single term.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import a, x</span>
<span class="sd">        &gt;&gt;&gt; (3*x + a*x + 4).as_coefficients_dict()</span>
<span class="sd">        {1: 4, x: 3, a*x: 1}</span>
<span class="sd">        &gt;&gt;&gt; _[a]</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; (3*a*x).as_coefficients_dict()</span>
<span class="sd">        {a*x: 3}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">m</span><span class="p">:</span> <span class="n">c</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">as_base_exp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># a -&gt; b ** e</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

    <span class="k">def</span> <span class="nf">as_coeff_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">deps</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the tuple (c, args) where self is written as a Mul, ``m``.</span>

<span class="sd">        c should be a Rational multiplied by any factors of the Mul that are</span>
<span class="sd">        independent of deps.</span>

<span class="sd">        args should be a tuple of all other factors of m; args is empty</span>
<span class="sd">        if self is a Number or if self is independent of deps (when given).</span>

<span class="sd">        This should be used when you don&#39;t know if self is a Mul or not but</span>
<span class="sd">        you want to treat self as a Mul or if you want to process the</span>
<span class="sd">        individual arguments of the tail of self as a Mul.</span>

<span class="sd">        - if you know self is a Mul and want only the head, use self.args[0];</span>
<span class="sd">        - if you don&#39;t want to process the arguments of the tail but need the</span>
<span class="sd">          tail then use self.as_two_terms() which gives the head and tail;</span>
<span class="sd">        - if you want to split self into an independent and dependent parts</span>
<span class="sd">          use ``self.as_independent(*deps)``</span>

<span class="sd">        &gt;&gt;&gt; from sympy import S</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; (S(3)).as_coeff_mul()</span>
<span class="sd">        (3, ())</span>
<span class="sd">        &gt;&gt;&gt; (3*x*y).as_coeff_mul()</span>
<span class="sd">        (3, (x, y))</span>
<span class="sd">        &gt;&gt;&gt; (3*x*y).as_coeff_mul(x)</span>
<span class="sd">        (3*y, (x,))</span>
<span class="sd">        &gt;&gt;&gt; (3*y).as_coeff_mul(x)</span>
<span class="sd">        (3*y, ())</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">deps</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">as_coeff_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">deps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the tuple (c, args) where self is written as an Add, ``a``.</span>

<span class="sd">        c should be a Rational added to any terms of the Add that are</span>
<span class="sd">        independent of deps.</span>

<span class="sd">        args should be a tuple of all other terms of ``a``; args is empty</span>
<span class="sd">        if self is a Number or if self is independent of deps (when given).</span>

<span class="sd">        This should be used when you don&#39;t know if self is an Add or not but</span>
<span class="sd">        you want to treat self as an Add or if you want to process the</span>
<span class="sd">        individual arguments of the tail of self as an Add.</span>

<span class="sd">        - if you know self is an Add and want only the head, use self.args[0];</span>
<span class="sd">        - if you don&#39;t want to process the arguments of the tail but need the</span>
<span class="sd">          tail then use self.as_two_terms() which gives the head and tail.</span>
<span class="sd">        - if you want to split self into an independent and dependent parts</span>
<span class="sd">          use ``self.as_independent(*deps)``</span>

<span class="sd">        &gt;&gt;&gt; from sympy import S</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; (S(3)).as_coeff_add()</span>
<span class="sd">        (3, ())</span>
<span class="sd">        &gt;&gt;&gt; (3 + x).as_coeff_add()</span>
<span class="sd">        (3, (x,))</span>
<span class="sd">        &gt;&gt;&gt; (3 + x + y).as_coeff_add(x)</span>
<span class="sd">        (y + 3, (x,))</span>
<span class="sd">        &gt;&gt;&gt; (3 + y).as_coeff_add(x)</span>
<span class="sd">        (y + 3, ())</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">deps</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the positive Rational that can be extracted non-recursively</span>
<span class="sd">        from every term of self (i.e., self is treated like an Add). This is</span>
<span class="sd">        like the as_coeff_Mul() method but primitive always extracts a positive</span>
<span class="sd">        Rational (never a negative or a Float).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; (3*(x + 1)**2).primitive()</span>
<span class="sd">        (3, (x + 1)**2)</span>
<span class="sd">        &gt;&gt;&gt; a = (6*x + 2); a.primitive()</span>
<span class="sd">        (2, 3*x + 1)</span>
<span class="sd">        &gt;&gt;&gt; b = (x/2 + 3); b.primitive()</span>
<span class="sd">        (1/2, x + 6)</span>
<span class="sd">        &gt;&gt;&gt; (a*b).primitive() == (1, a*b)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">r</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">as_content_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method should recursively remove a Rational from all arguments</span>
<span class="sd">        and return that (content) and the new self (primitive). The content</span>
<span class="sd">        should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.</span>
<span class="sd">        The primitive need not be in canonical form and should try to preserve</span>
<span class="sd">        the underlying structure if possible (i.e. expand_mul should not be</span>
<span class="sd">        applied to self).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>

<span class="sd">        &gt;&gt;&gt; eq = 2 + 2*x + 2*y*(3 + 3*y)</span>

<span class="sd">        The as_content_primitive function is recursive and retains structure:</span>

<span class="sd">        &gt;&gt;&gt; eq.as_content_primitive()</span>
<span class="sd">        (2, x + 3*y*(y + 1) + 1)</span>

<span class="sd">        Integer powers will have Rationals extracted from the base:</span>

<span class="sd">        &gt;&gt;&gt; ((2 + 6*x)**2).as_content_primitive()</span>
<span class="sd">        (4, (3*x + 1)**2)</span>
<span class="sd">        &gt;&gt;&gt; ((2 + 6*x)**(2*y)).as_content_primitive()</span>
<span class="sd">        (1, (2*(3*x + 1))**(2*y))</span>

<span class="sd">        Terms may end up joining once their as_content_primitives are added:</span>

<span class="sd">        &gt;&gt;&gt; ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()</span>
<span class="sd">        (11, x*(y + 1))</span>
<span class="sd">        &gt;&gt;&gt; ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()</span>
<span class="sd">        (9, x*(y + 1))</span>
<span class="sd">        &gt;&gt;&gt; ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()</span>
<span class="sd">        (1, 6.0*x*(y + 1) + 3*z*(y + 1))</span>
<span class="sd">        &gt;&gt;&gt; ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()</span>
<span class="sd">        (121, x**2*(y + 1)**2)</span>
<span class="sd">        &gt;&gt;&gt; ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()</span>
<span class="sd">        (1, 121.0*x**2*(y + 1)**2)</span>

<span class="sd">        Radical content can also be factored out of the primitive:</span>

<span class="sd">        &gt;&gt;&gt; (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)</span>
<span class="sd">        (2, sqrt(2)*(1 + 2*sqrt(5)))</span>

<span class="sd">        If clear=False (default is True) then content will not be removed</span>
<span class="sd">        from an Add if it can be distributed to leave one or more</span>
<span class="sd">        terms with integer coefficients.</span>

<span class="sd">        &gt;&gt;&gt; (x/2 + y).as_content_primitive()</span>
<span class="sd">        (1/2, x + 2*y)</span>
<span class="sd">        &gt;&gt;&gt; (x/2 + y).as_content_primitive(clear=False)</span>
<span class="sd">        (1, x/2 + y)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">as_numer_denom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; expression -&gt; a/b -&gt; a, b</span>

<span class="sd">        This is just a stub that should be defined by</span>
<span class="sd">        an object&#39;s class methods to get anything else.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        normal: return a/b instead of a, b</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

    <span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.mul</span> <span class="k">import</span> <span class="n">_unevaluated_Mul</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_unevaluated_Mul</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">/</span><span class="n">d</span>

    <span class="k">def</span> <span class="nf">extract_multiplicatively</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return None if it&#39;s not possible to make self in the form</span>
<span class="sd">           c * something in a nice way, i.e. preserving the properties</span>
<span class="sd">           of arguments of self.</span>

<span class="sd">           Examples</span>
<span class="sd">           ========</span>

<span class="sd">           &gt;&gt;&gt; from sympy import symbols, Rational</span>

<span class="sd">           &gt;&gt;&gt; x, y = symbols(&#39;x,y&#39;, real=True)</span>

<span class="sd">           &gt;&gt;&gt; ((x*y)**3).extract_multiplicatively(x**2 * y)</span>
<span class="sd">           x*y**2</span>

<span class="sd">           &gt;&gt;&gt; ((x*y)**3).extract_multiplicatively(x**4 * y)</span>

<span class="sd">           &gt;&gt;&gt; (2*x).extract_multiplicatively(2)</span>
<span class="sd">           x</span>

<span class="sd">           &gt;&gt;&gt; (2*x).extract_multiplicatively(3)</span>

<span class="sd">           &gt;&gt;&gt; (Rational(1, 2)*x).extract_multiplicatively(3)</span>
<span class="sd">           x/6</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">cc</span><span class="p">,</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">as_two_terms</span><span class="p">()</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="n">quotient</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">/</span> <span class="n">c</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span>
            <span class="k">elif</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span>
                <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span>
            <span class="k">elif</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ComplexInfinity</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">ComplexInfinity</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_NumberSymbol</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">or</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">quotient</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">quotient</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
            <span class="k">elif</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">quotient</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">cs</span><span class="p">,</span> <span class="n">ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
            <span class="c1"># assert cs &gt;= 1</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">:</span>
                <span class="c1"># assert c != 1 (handled at top)</span>
                <span class="k">if</span> <span class="n">cs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                        <span class="n">xc</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">cs</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">xc</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">xc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">xc</span><span class="o">*</span><span class="n">ps</span>  <span class="c1"># rely on 2-arg Mul to restore Add</span>
                <span class="k">return</span>  <span class="c1"># |c| != 1 can only be extracted from cs</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">ps</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cs</span>
            <span class="c1"># check args of ps</span>
            <span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">ps</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">newarg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newarg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span>  <span class="c1"># all or nothing</span>
                <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newarg</span><span class="p">)</span>
            <span class="c1"># args should be in same order so use unevaluated return</span>
            <span class="k">if</span> <span class="n">cs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Add</span><span class="o">.</span><span class="n">_from_args</span><span class="p">([</span><span class="n">cs</span><span class="o">*</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">newargs</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Add</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">newargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                <span class="n">newarg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newarg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">newarg</span>
                    <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">base</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
                <span class="n">new_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">**</span> <span class="p">(</span><span class="n">new_exp</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
                <span class="n">new_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">**</span> <span class="p">(</span><span class="n">new_exp</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extract_additively</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self - c if it&#39;s possible to subtract c from self and</span>
<span class="sd">        make all matching coefficients move towards zero, else return None.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; e = 2*x + 3</span>
<span class="sd">        &gt;&gt;&gt; e.extract_additively(x + 1)</span>
<span class="sd">        x + 2</span>
<span class="sd">        &gt;&gt;&gt; e.extract_additively(3*x)</span>
<span class="sd">        &gt;&gt;&gt; e.extract_additively(4)</span>
<span class="sd">        &gt;&gt;&gt; (y*(x + 1)).extract_additively(x + 1)</span>
<span class="sd">        &gt;&gt;&gt; ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)</span>
<span class="sd">        (x + 1)*(x + 2*y) + 3</span>

<span class="sd">        Sometimes auto-expansion will return a less simplified result</span>
<span class="sd">        than desired; gcd_terms might be used in such cases:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import gcd_terms</span>
<span class="sd">        &gt;&gt;&gt; (4*x*(y + 1) + y).extract_additively(x)</span>
<span class="sd">        4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y</span>
<span class="sd">        &gt;&gt;&gt; gcd_terms(_)</span>
<span class="sd">        x*(4*y + 3) + y</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        extract_multiplicatively</span>
<span class="sd">        coeff</span>
<span class="sd">        as_coefficient</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">elif</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">co</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">co</span> <span class="o">-</span> <span class="n">c</span>
            <span class="c1"># XXX should we match types? i.e should 3 - .1 succeed?</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">co</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">co</span> <span class="ow">or</span>
                    <span class="n">co</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">co</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">diff</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="n">co</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">co</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">xa</span> <span class="o">+</span> <span class="n">t</span>

        <span class="c1"># handle the args[0].is_Number case separately</span>
        <span class="c1"># since we will have trouble looking for the coeff of</span>
        <span class="c1"># a number.</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="c1"># whole term as a term factor</span>
            <span class="n">co</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">xa0</span> <span class="o">=</span> <span class="p">(</span><span class="n">co</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">c</span>
            <span class="k">if</span> <span class="n">xa0</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">co</span><span class="o">*</span><span class="n">c</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">xa0</span> <span class="o">+</span> <span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">diff</span><span class="p">))</span> <span class="ow">or</span> <span class="kc">None</span>
            <span class="c1"># term-wise</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="n">sh</span><span class="p">,</span> <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">xa2</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xa2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">xa</span> <span class="o">+</span> <span class="n">xa2</span>

        <span class="c1"># whole term as a term factor</span>
        <span class="n">co</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">xa0</span> <span class="o">=</span> <span class="p">(</span><span class="n">co</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">c</span>
        <span class="k">if</span> <span class="n">xa0</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">co</span><span class="o">*</span><span class="n">c</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">xa0</span> <span class="o">+</span> <span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">diff</span><span class="p">))</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="c1"># term-wise</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
            <span class="n">ac</span><span class="p">,</span> <span class="n">at</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
            <span class="n">co</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">coc</span><span class="p">,</span> <span class="n">cot</span> <span class="o">=</span> <span class="n">co</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">coc</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">ac</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="bp">self</span> <span class="o">-=</span> <span class="n">co</span><span class="o">*</span><span class="n">at</span>
            <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cot</span> <span class="o">+</span> <span class="n">xa</span><span class="p">)</span><span class="o">*</span><span class="n">at</span><span class="p">)</span>
        <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">coeffs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">expr_free_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Like ``free_symbols``, but returns the free symbols only if they are contained in an expression node.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; (x + y).expr_free_symbols</span>
<span class="sd">        {x, y}</span>

<span class="sd">        If the expression is contained in a non-expression object, don&#39;t return</span>
<span class="sd">        the free symbols. Compare:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Tuple</span>
<span class="sd">        &gt;&gt;&gt; t = Tuple(x + y)</span>
<span class="sd">        &gt;&gt;&gt; t.expr_free_symbols</span>
<span class="sd">        set()</span>
<span class="sd">        &gt;&gt;&gt; t.free_symbols</span>
<span class="sd">        {x, y}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">expr_free_symbols</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">could_extract_minus_sign</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if self is not in a canonical form with respect</span>
<span class="sd">        to its sign.</span>

<span class="sd">        For most expressions, e, there will be a difference in e and -e.</span>
<span class="sd">        When there is, True will be returned for one and False for the</span>
<span class="sd">        other; False will be returned if there is no difference.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; e = x - y</span>
<span class="sd">        &gt;&gt;&gt; {i.could_extract_minus_sign() for i in (e, -e)}</span>
<span class="sd">        {False, True}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">negative_self</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">negative_self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># e.g. zoo*x == -zoo*x</span>
        <span class="n">self_has_minus</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">negative_self_has_minus</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">negative_self</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self_has_minus</span> <span class="o">!=</span> <span class="n">negative_self_has_minus</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self_has_minus</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="c1"># We choose the one with less arguments with minus signs</span>
                <span class="n">all_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                <span class="n">negative_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="kc">False</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">()])</span>
                <span class="n">positive_args</span> <span class="o">=</span> <span class="n">all_args</span> <span class="o">-</span> <span class="n">negative_args</span>
                <span class="k">if</span> <span class="n">positive_args</span> <span class="o">&gt;</span> <span class="n">negative_args</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="n">positive_args</span> <span class="o">&lt;</span> <span class="n">negative_args</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="c1"># We choose the one with an odd number of minus signs</span>
                <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
                <span class="n">arg_signs</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">()</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
                <span class="n">negative_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">arg_signs</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">negative_args</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="c1"># As a last resort, we choose the one with greater value of .sort_key()</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sort_key</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">negative_self</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">extract_branch_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_half</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.</span>
<span class="sd">        Return (z, n).</span>

<span class="sd">        &gt;&gt;&gt; from sympy import exp_polar, I, pi</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(I*pi).extract_branch_factor()</span>
<span class="sd">        (exp_polar(I*pi), 0)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(2*I*pi).extract_branch_factor()</span>
<span class="sd">        (1, 1)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(-pi*I).extract_branch_factor()</span>
<span class="sd">        (exp_polar(I*pi), -1)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(3*pi*I + x).extract_branch_factor()</span>
<span class="sd">        (exp_polar(x + I*pi), 1)</span>
<span class="sd">        &gt;&gt;&gt; (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()</span>
<span class="sd">        (y*exp_polar(2*pi*x), -1)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(-I*pi/2).extract_branch_factor()</span>
<span class="sd">        (exp_polar(-I*pi/2), 0)</span>

<span class="sd">        If allow_half is True, also extract exp_polar(I*pi):</span>

<span class="sd">        &gt;&gt;&gt; exp_polar(I*pi).extract_branch_factor(allow_half=True)</span>
<span class="sd">        (1, 1/2)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(2*I*pi).extract_branch_factor(allow_half=True)</span>
<span class="sd">        (1, 1)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(3*I*pi).extract_branch_factor(allow_half=True)</span>
<span class="sd">        (1, 3/2)</span>
<span class="sd">        &gt;&gt;&gt; exp_polar(-I*pi).extract_branch_factor(allow_half=True)</span>
<span class="sd">        (1, -1/2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">ceiling</span><span class="p">,</span> <span class="n">Add</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">exps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">exp_polar</span><span class="p">):</span>
                <span class="n">exps</span> <span class="o">+=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">exp</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">*=</span> <span class="n">arg</span>
        <span class="n">piimult</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">extras</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">exps</span><span class="p">:</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">exps</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">exp</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">exps</span> <span class="o">+=</span> <span class="n">exp</span><span class="o">.</span><span class="n">args</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">exp</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">as_coefficient</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">piimult</span> <span class="o">+=</span> <span class="n">coeff</span>
                    <span class="k">continue</span>
            <span class="n">extras</span> <span class="o">+=</span> <span class="p">[</span><span class="n">exp</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">piimult</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">piimult</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">piimult</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">(</span><span class="o">*</span><span class="n">piimult</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
        <span class="c1"># round down to nearest multiple of 2</span>
        <span class="n">branchfact</span> <span class="o">=</span> <span class="n">ceiling</span><span class="p">(</span><span class="n">coeff</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="n">branchfact</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">-</span> <span class="n">branchfact</span>
        <span class="k">if</span> <span class="n">allow_half</span><span class="p">:</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span>
        <span class="n">newexp</span> <span class="o">=</span> <span class="n">pi</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">tail</span><span class="p">))</span> <span class="o">+</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">extras</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">newexp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">*=</span> <span class="n">exp_polar</span><span class="p">(</span><span class="n">newexp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">_eval_is_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">is_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if self is a polynomial in syms and False otherwise.</span>

<span class="sd">        This checks if self is an exact polynomial in syms.  This function</span>
<span class="sd">        returns False for expressions that are &quot;polynomials&quot; with symbolic</span>
<span class="sd">        exponents.  Thus, you should be able to apply polynomial algorithms to</span>
<span class="sd">        expressions for which this returns True, and Poly(expr, \*syms) should</span>
<span class="sd">        work if and only if expr.is_polynomial(\*syms) returns True. The</span>
<span class="sd">        polynomial does not have to be in expanded form.  If no symbols are</span>
<span class="sd">        given, all free symbols in the expression will be used.</span>

<span class="sd">        This is not part of the assumptions system.  You cannot do</span>
<span class="sd">        Symbol(&#39;z&#39;, polynomial=True).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ((x**2 + 1)**4).is_polynomial(x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ((x**2 + 1)**4).is_polynomial()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (2**x + 1).is_polynomial(x)</span>
<span class="sd">        False</span>


<span class="sd">        &gt;&gt;&gt; n = Symbol(&#39;n&#39;, nonnegative=True, integer=True)</span>
<span class="sd">        &gt;&gt;&gt; (x**n + 1).is_polynomial(x)</span>
<span class="sd">        False</span>

<span class="sd">        This function does not attempt any nontrivial simplifications that may</span>
<span class="sd">        result in an expression that does not appear to be a polynomial to</span>
<span class="sd">        become one.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sqrt, factor, cancel</span>
<span class="sd">        &gt;&gt;&gt; y = Symbol(&#39;y&#39;, positive=True)</span>
<span class="sd">        &gt;&gt;&gt; a = sqrt(y**2 + 2*y + 1)</span>
<span class="sd">        &gt;&gt;&gt; a.is_polynomial(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; factor(a)</span>
<span class="sd">        y + 1</span>
<span class="sd">        &gt;&gt;&gt; factor(a).is_polynomial(y)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; b = (y**2 + 2*y + 1)/(y + 1)</span>
<span class="sd">        &gt;&gt;&gt; b.is_polynomial(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; cancel(b)</span>
<span class="sd">        y + 1</span>
<span class="sd">        &gt;&gt;&gt; cancel(b).is_polynomial(y)</span>
<span class="sd">        True</span>

<span class="sd">        See also .is_rational_function()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">syms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>

        <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="c1"># constant polynomial</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_is_polynomial</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_is_rational_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">is_rational_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether function is a ratio of two polynomials in the given</span>
<span class="sd">        symbols, syms. When syms is not given, all free symbols will be used.</span>
<span class="sd">        The rational function does not have to be in expanded or in any kind of</span>
<span class="sd">        canonical form.</span>

<span class="sd">        This function returns False for expressions that are &quot;rational</span>
<span class="sd">        functions&quot; with symbolic exponents.  Thus, you should be able to call</span>
<span class="sd">        .as_numer_denom() and apply polynomial algorithms to the result for</span>
<span class="sd">        expressions for which this returns True.</span>

<span class="sd">        This is not part of the assumptions system.  You cannot do</span>
<span class="sd">        Symbol(&#39;z&#39;, rational_function=True).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol, sin</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">        &gt;&gt;&gt; (x/y).is_rational_function()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; (x**2).is_rational_function()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; (x/sin(y)).is_rational_function(y)</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; n = Symbol(&#39;n&#39;, integer=True)</span>
<span class="sd">        &gt;&gt;&gt; (x**n + 1).is_rational_function(x)</span>
<span class="sd">        False</span>

<span class="sd">        This function does not attempt any nontrivial simplifications that may</span>
<span class="sd">        result in an expression that does not appear to be a rational function</span>
<span class="sd">        to become one.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sqrt, factor</span>
<span class="sd">        &gt;&gt;&gt; y = Symbol(&#39;y&#39;, positive=True)</span>
<span class="sd">        &gt;&gt;&gt; a = sqrt(y**2 + 2*y + 1)/y</span>
<span class="sd">        &gt;&gt;&gt; a.is_rational_function(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; factor(a)</span>
<span class="sd">        (y + 1)/y</span>
<span class="sd">        &gt;&gt;&gt; factor(a).is_rational_function(y)</span>
<span class="sd">        True</span>

<span class="sd">        See also is_algebraic_expr().</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">,</span> <span class="o">-</span><span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">ComplexInfinity</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">syms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>

        <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="c1"># constant rational function</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_is_rational_function</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_is_algebraic_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">is_algebraic_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This tests whether a given expression is algebraic or not, in the</span>
<span class="sd">        given symbols, syms. When syms is not given, all free symbols</span>
<span class="sd">        will be used. The rational function does not have to be in expanded</span>
<span class="sd">        or in any kind of canonical form.</span>

<span class="sd">        This function returns False for expressions that are &quot;algebraic</span>
<span class="sd">        expressions&quot; with symbolic exponents. This is a simple extension to the</span>
<span class="sd">        is_rational_function, including rational exponentiation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol, sqrt</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&#39;x&#39;, real=True)</span>
<span class="sd">        &gt;&gt;&gt; sqrt(1 + x).is_rational_function()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; sqrt(1 + x).is_algebraic_expr()</span>
<span class="sd">        True</span>

<span class="sd">        This function does not attempt any nontrivial simplifications that may</span>
<span class="sd">        result in an expression that does not appear to be an algebraic</span>
<span class="sd">        expression to become one.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import exp, factor</span>
<span class="sd">        &gt;&gt;&gt; a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)</span>
<span class="sd">        &gt;&gt;&gt; a.is_algebraic_expr(x)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; factor(a).is_algebraic_expr()</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        is_rational_function()</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        - https://en.wikipedia.org/wiki/Algebraic_expression</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">syms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>

        <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="c1"># constant algebraic expression</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_is_algebraic_expr</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span>

    <span class="c1">###################################################################################</span>
    <span class="c1">##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################</span>
    <span class="c1">###################################################################################</span>

    <span class="k">def</span> <span class="nf">series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Series expansion of &quot;self&quot; around ``x = x0`` yielding either terms of</span>
<span class="sd">        the series one by one (the lazy series given when n=None), else</span>
<span class="sd">        all the terms at once when n != None.</span>

<span class="sd">        Returns the series expansion of &quot;self&quot; around the point ``x = x0``</span>
<span class="sd">        with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).</span>

<span class="sd">        If ``x=None`` and ``self`` is univariate, the univariate symbol will</span>
<span class="sd">        be supplied, otherwise an error will be raised.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import cos, exp</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; cos(x).series()</span>
<span class="sd">        1 - x**2/2 + x**4/24 + O(x**6)</span>
<span class="sd">        &gt;&gt;&gt; cos(x).series(n=4)</span>
<span class="sd">        1 - x**2/2 + O(x**4)</span>
<span class="sd">        &gt;&gt;&gt; cos(x).series(x, x0=1, n=2)</span>
<span class="sd">        cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))</span>
<span class="sd">        &gt;&gt;&gt; e = cos(x + exp(y))</span>
<span class="sd">        &gt;&gt;&gt; e.series(y, n=2)</span>
<span class="sd">        cos(x + 1) - y*sin(x + 1) + O(y**2)</span>
<span class="sd">        &gt;&gt;&gt; e.series(x, n=2)</span>
<span class="sd">        cos(exp(y)) - x*sin(exp(y)) + O(x**2)</span>

<span class="sd">        If ``n=None`` then a generator of the series terms will be returned.</span>

<span class="sd">        &gt;&gt;&gt; term=cos(x).series(n=None)</span>
<span class="sd">        &gt;&gt;&gt; [next(term) for i in range(2)]</span>
<span class="sd">        [1, -x**2/2]</span>

<span class="sd">        For ``dir=+`` (default) the series is calculated from the right and</span>
<span class="sd">        for ``dir=-`` the series from the left. For smooth functions this</span>
<span class="sd">        flag will not alter the results.</span>

<span class="sd">        &gt;&gt;&gt; abs(x).series(dir=&quot;+&quot;)</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; abs(x).series(dir=&quot;-&quot;)</span>
<span class="sd">        -x</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">collect</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Order</span><span class="p">,</span> <span class="n">Rational</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">ceiling</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">syms</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x must be given for multivariate functions.&#39;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="n">dep</span> <span class="o">=</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
            <span class="n">dep</span> <span class="o">=</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">d</span><span class="p">})</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dep</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">dir</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;+-&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dir must be &#39;+&#39; or &#39;-&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x0</span> <span class="ow">in</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">]:</span>
            <span class="n">sgn</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sgn</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">si</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sgn</span><span class="o">/</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sgn</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>


        <span class="c1"># use rep to shift origin to x0 and change sign (if dir is negative)</span>
        <span class="c1"># and undo the process with rep2</span>
        <span class="k">if</span> <span class="n">x0</span> <span class="ow">or</span> <span class="nb">dir</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="n">x0</span>
                <span class="n">rep2</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
                <span class="n">rep2b</span> <span class="o">=</span> <span class="n">x0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x0</span>
                <span class="n">rep2</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">rep2b</span> <span class="o">=</span> <span class="o">-</span><span class="n">x0</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rep</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># lseries...</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">si</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rep2</span> <span class="o">+</span> <span class="n">rep2b</span><span class="p">)</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rep2</span> <span class="o">+</span> <span class="n">rep2b</span><span class="p">)</span>

        <span class="c1"># from here on it&#39;s x0=0 and dir=&#39;+&#39; handling</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">is</span> <span class="n">x</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># replace x with an x that has a positive assumption</span>
            <span class="n">xpos</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xpos</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">xpos</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">xpos</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">rv</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rv</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">xpos</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># nseries handling</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span> <span class="ow">or</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="n">o</span><span class="p">:</span>
                <span class="c1"># make sure the requested order is returned</span>
                <span class="n">ngot</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">ngot</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
                    <span class="c1"># leave o in its current form (e.g. with x*log(x)) so</span>
                    <span class="c1"># it eats terms properly, then replace it below</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">s1</span> <span class="o">+=</span> <span class="n">o</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="n">Rational</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ngot</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">s1</span> <span class="o">+=</span> <span class="n">Order</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">ngot</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                    <span class="c1"># increase the requested number of terms to get the desired</span>
                    <span class="c1"># number keep increasing (up to 9) until the received order</span>
                    <span class="c1"># is different than the original order and then predict how</span>
                    <span class="c1"># many additional terms are needed</span>
                    <span class="k">for</span> <span class="n">more</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span>
                        <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="n">more</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
                        <span class="n">newn</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">newn</span> <span class="o">!=</span> <span class="n">ngot</span><span class="p">:</span>
                            <span class="n">ndo</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">ceiling</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">ngot</span><span class="p">)</span><span class="o">*</span><span class="n">more</span><span class="o">/</span><span class="p">(</span><span class="n">newn</span> <span class="o">-</span> <span class="n">ngot</span><span class="p">))</span>
                            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">ndo</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
                            <span class="k">while</span> <span class="n">s1</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                                <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">ndo</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
                                <span class="n">ndo</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not calculate </span><span class="si">%s</span><span class="s1"> terms for </span><span class="si">%s</span><span class="s1">&#39;</span>
                                         <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="bp">self</span><span class="p">))</span>
                    <span class="n">s1</span> <span class="o">+=</span> <span class="n">Order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">s1done</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s1done</span> <span class="o">+</span> <span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span> <span class="o">==</span> <span class="n">s1done</span><span class="p">:</span>
                    <span class="n">o</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">collect</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">o</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">o</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># lseries handling</span>
            <span class="k">def</span> <span class="nf">yield_lseries</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Return terms of lseries one at a time.&quot;&quot;&quot;</span>
                <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">si</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">si</span>
                        <span class="k">continue</span>
                    <span class="c1"># yield terms 1 at a time if possible</span>
                    <span class="c1"># by increasing order until all the</span>
                    <span class="c1"># terms have been returned</span>
                    <span class="n">yielded</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">o</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span>
                    <span class="n">ndid</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">ndo</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">si</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">do</span> <span class="o">=</span> <span class="p">(</span><span class="n">si</span> <span class="o">-</span> <span class="n">yielded</span> <span class="o">+</span> <span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
                        <span class="n">o</span> <span class="o">*=</span> <span class="n">x</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">do</span> <span class="ow">or</span> <span class="n">do</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">do</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                            <span class="n">ndid</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">do</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ndid</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">yield</span> <span class="n">do</span>
                        <span class="k">if</span> <span class="n">ndid</span> <span class="o">==</span> <span class="n">ndo</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="n">yielded</span> <span class="o">+=</span> <span class="n">do</span>

            <span class="k">return</span> <span class="n">yield_lseries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span><span class="o">.</span><span class="n">_eval_lseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">taylor_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">previous_terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;General method for the taylor term.</span>

<span class="sd">        This method is slow, because it differentiates n-times. Subclasses can</span>
<span class="sd">        redefine it to make it faster by using the &quot;previous_terms&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">factorial</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for series yielding an iterator of the terms of the series.</span>

<span class="sd">        Note: an infinite series will yield an infinite iterator. The following,</span>
<span class="sd">        for exaxmple, will never terminate. It will just keep printing terms</span>
<span class="sd">        of the sin(x) series::</span>

<span class="sd">          for term in sin(x).lseries(x):</span>
<span class="sd">              print term</span>

<span class="sd">        The advantage of lseries() over nseries() is that many times you are</span>
<span class="sd">        just interested in the next term in the series (i.e. the first term for</span>
<span class="sd">        example), but you don&#39;t know how many you should ask for in nseries()</span>
<span class="sd">        using the &quot;n&quot; parameter.</span>

<span class="sd">        See also nseries().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="nb">dir</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_lseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># default implementation of lseries is using nseries(), and adaptively</span>
        <span class="c1"># increasing the &quot;n&quot;. As you can see, it is not very efficient, because</span>
        <span class="c1"># we are calculating the series over and over again. Subclasses should</span>
        <span class="c1"># override this method and implement much more efficient yielding of</span>
        <span class="c1"># terms.</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">series</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">series</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">series</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">series</span>
            <span class="k">return</span>

        <span class="k">while</span> <span class="n">series</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
        <span class="k">yield</span> <span class="n">e</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">series</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">yield</span> <span class="n">series</span> <span class="o">-</span> <span class="n">e</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">series</span>

    <span class="k">def</span> <span class="nf">nseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper to _eval_nseries if assumptions allow, else to series.</span>

<span class="sd">        If x is given, x0 is 0, dir=&#39;+&#39;, and self has x, then _eval_nseries is</span>
<span class="sd">        called. This calculates &quot;n&quot; terms in the innermost expressions and</span>
<span class="sd">        then builds up the final series just by &quot;cross-multiplying&quot; everything</span>
<span class="sd">        out.</span>

<span class="sd">        The optional ``logx`` parameter can be used to replace any log(x) in the</span>
<span class="sd">        returned series with a symbolic value to avoid evaluating log(x) at 0. A</span>
<span class="sd">        symbol to use in place of log(x) should be provided.</span>

<span class="sd">        Advantage -- it&#39;s fast, because we don&#39;t have to determine how many</span>
<span class="sd">        terms we need to calculate in advance.</span>

<span class="sd">        Disadvantage -- you may end up with less terms than you may have</span>
<span class="sd">        expected, but the O(x**n) term appended will always be correct and</span>
<span class="sd">        so the result, though perhaps shorter, will also be correct.</span>

<span class="sd">        If any of those assumptions is not met, this is treated like a</span>
<span class="sd">        wrapper to series which will try harder to return the correct</span>
<span class="sd">        number of terms.</span>

<span class="sd">        See also lseries().</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, log, Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; sin(x).nseries(x, 0, 6)</span>
<span class="sd">        x - x**3/6 + x**5/120 + O(x**6)</span>
<span class="sd">        &gt;&gt;&gt; log(x+1).nseries(x, 0, 5)</span>
<span class="sd">        x - x**2/2 + x**3/3 - x**4/4 + O(x**5)</span>

<span class="sd">        Handling of the ``logx`` parameter --- in the following example the</span>
<span class="sd">        expansion fails since ``sin`` does not have an asymptotic expansion</span>
<span class="sd">        at -oo (the limit of log(x) as x approaches 0):</span>

<span class="sd">        &gt;&gt;&gt; e = sin(log(x))</span>
<span class="sd">        &gt;&gt;&gt; e.nseries(x, 0, 6)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        PoleError: ...</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; logx = Symbol(&#39;logx&#39;)</span>
<span class="sd">        &gt;&gt;&gt; e.nseries(x, 0, 6, logx=logx)</span>
<span class="sd">        sin(logx)</span>

<span class="sd">        In the following example, the expansion works but gives only an Order term</span>
<span class="sd">        unless the ``logx`` parameter is used:</span>

<span class="sd">        &gt;&gt;&gt; e = x**y</span>
<span class="sd">        &gt;&gt;&gt; e.nseries(x, 0, 2)</span>
<span class="sd">        O(log(x)**2)</span>
<span class="sd">        &gt;&gt;&gt; e.nseries(x, 0, 2, logx=logx)</span>
<span class="sd">        exp(logx*y)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">x0</span> <span class="ow">or</span> <span class="nb">dir</span> <span class="o">!=</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>  <span class="c1"># {see XPOS above} or (x.is_positive == x.is_negative == None):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_nseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return terms of series for self up to O(x**n) at x=0</span>
<span class="sd">        from the positive direction.</span>

<span class="sd">        This is a method that should be overridden in subclasses. Users should</span>
<span class="sd">        never call this method directly (use .nseries() instead), so you don&#39;t</span>
<span class="sd">        have to write docstrings for _eval_nseries().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="k">import</span> <span class="n">filldedent</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                     The _eval_nseries method should be added to</span>
<span class="s2">                     </span><span class="si">%s</span><span class="s2"> to give terms up to O(x**n) at x=0</span>
<span class="s2">                     from the positive direction so it is available when</span>
<span class="s2">                     nseries calls it.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
                     <span class="p">)</span>

    <span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute limit x-&gt;xlim.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.series.limits</span> <span class="k">import</span> <span class="n">limit</span>
        <span class="k">return</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_leading_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        as_leading_term is only allowed for results of .series()</span>
<span class="sd">        This is a wrapper to compute a series first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">log</span>
        <span class="kn">from</span> <span class="nn">sympy.series.gruntz</span> <span class="k">import</span> <span class="n">calculate_series</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">logx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;logx&#39;</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">logx</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">as_leading_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the leading (nonzero) term of the series expansion of self.</span>

<span class="sd">        The _eval_as_leading_term routines are used to do this, and they must</span>
<span class="sd">        always return a non-zero value.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; (1 + x + x**2).as_leading_term(x)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; (1/x**2 + x + x**2).as_leading_term(x)</span>
<span class="sd">        x**(-2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">powsimp</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">c</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_symbol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expecting a Symbol but got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s1">&#39;exp&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;as_leading_term(</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_eval_as_leading_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">as_coeff_exponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; ``c*x**e -&gt; c,e`` where x can be any symbolic expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">collect</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="k">def</span> <span class="nf">leadterm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the leading term a*x**b as a tuple (a, b).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; (1+x+x**2).leadterm(x)</span>
<span class="sd">        (1, 0)</span>
<span class="sd">        &gt;&gt;&gt; (1/x**2+x+x**2).leadterm(x)</span>
<span class="sd">        (1, -2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">log</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;logx&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">as_coeff_exponent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="k">import</span> <span class="n">filldedent</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                cannot compute leadterm(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">). The coefficient</span>
<span class="s2">                should have been free of x but got </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)))</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span>

    <span class="k">def</span> <span class="nf">as_coeff_Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Efficiently extract the coefficient of a product. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">as_coeff_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Efficiently extract the coefficient of a summation. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">fps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hyper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">full</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute formal power power series of self.</span>

<span class="sd">        See the docstring of the :func:`fps` function in sympy.series.formal for</span>
<span class="sd">        more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.series.formal</span> <span class="k">import</span> <span class="n">fps</span>

        <span class="k">return</span> <span class="n">fps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">hyper</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">rational</span><span class="p">,</span> <span class="n">full</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fourier_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute fourier sine/cosine series of self.</span>

<span class="sd">        See the docstring of the :func:`fourier_series` in sympy.series.fourier</span>
<span class="sd">        for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.series.fourier</span> <span class="k">import</span> <span class="n">fourier_series</span>

        <span class="k">return</span> <span class="n">fourier_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limits</span><span class="p">)</span>

    <span class="c1">###################################################################################</span>
    <span class="c1">##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################</span>
    <span class="c1">###################################################################################</span>

    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
        <span class="n">assumptions</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;evaluate&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>

    <span class="c1">###########################################################################</span>
    <span class="c1">###################### EXPRESSION EXPANSION METHODS #######################</span>
    <span class="c1">###########################################################################</span>

    <span class="c1"># Relevant subclasses should override _eval_expand_hint() methods.  See</span>
    <span class="c1"># the docstring of expand() for more info.</span>

    <span class="k">def</span> <span class="nf">_eval_expand_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="n">real</span><span class="p">,</span> <span class="n">imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">real</span> <span class="o">+</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="o">*</span><span class="n">imag</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_expand_hint</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.</span>

<span class="sd">        Returns ``(expr, hit)``, where expr is the (possibly) expanded</span>
<span class="sd">        ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and</span>
<span class="sd">        ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># XXX: Hack to support non-Basic args</span>
        <span class="c1">#              |</span>
        <span class="c1">#              V</span>
        <span class="k">if</span> <span class="n">deep</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;args&#39;</span><span class="p">,</span> <span class="p">())</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="n">sargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">arg</span><span class="p">,</span> <span class="n">arghit</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                <span class="n">hit</span> <span class="o">|=</span> <span class="n">arghit</span>
                <span class="n">sargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">hit</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">sargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hint</span><span class="p">):</span>
            <span class="n">newexpr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hint</span><span class="p">)(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">newexpr</span> <span class="o">!=</span> <span class="n">expr</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">newexpr</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hit</span><span class="p">)</span>

    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">power_base</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">power_exp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">mul</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multinomial</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">basic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand an expression using hints.</span>

<span class="sd">        See the docstring of the expand() function in sympy.core.function for</span>
<span class="sd">        more information.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify.radsimp</span> <span class="k">import</span> <span class="n">fraction</span>

        <span class="n">hints</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">power_base</span><span class="o">=</span><span class="n">power_base</span><span class="p">,</span> <span class="n">power_exp</span><span class="o">=</span><span class="n">power_exp</span><span class="p">,</span> <span class="n">mul</span><span class="o">=</span><span class="n">mul</span><span class="p">,</span>
           <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">multinomial</span><span class="o">=</span><span class="n">multinomial</span><span class="p">,</span> <span class="n">basic</span><span class="o">=</span><span class="n">basic</span><span class="p">)</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;frac&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="n">modulus</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">/</span><span class="n">d</span>
        <span class="k">elif</span> <span class="n">hints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;denom&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">/</span><span class="n">d</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="n">modulus</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">hints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;numer&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="n">modulus</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span><span class="o">/</span><span class="n">d</span>

        <span class="c1"># Although the hints are sorted here, an earlier hint may get applied</span>
        <span class="c1"># at a given node in the expression tree before another because of how</span>
        <span class="c1"># the hints are applied.  e.g. expand(log(x*(y + z))) -&gt; log(x*y +</span>
        <span class="c1"># x*z) because while applying log at the top level, log and mul are</span>
        <span class="c1"># applied at the deeper level in the tree so that when the log at the</span>
        <span class="c1"># upper level gets applied, the mul has already been applied at the</span>
        <span class="c1"># lower level.</span>

        <span class="c1"># Additionally, because hints are only applied once, the expression</span>
        <span class="c1"># may not be expanded all the way.   For example, if mul is applied</span>
        <span class="c1"># before multinomial, x*(x + 1)**2 won&#39;t be expanded all the way.  For</span>
        <span class="c1"># now, we just use a special case to make multinomial run before mul,</span>
        <span class="c1"># so that at least polynomials will be expanded all the way.  In the</span>
        <span class="c1"># future, smarter heuristics should be applied.</span>
        <span class="c1"># TODO: Smarter heuristics</span>

        <span class="k">def</span> <span class="nf">_expand_hint_key</span><span class="p">(</span><span class="n">hint</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Make multinomial come before mul&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">hint</span> <span class="o">==</span> <span class="s1">&#39;mul&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;mulz&#39;</span>
            <span class="k">return</span> <span class="n">hint</span>

        <span class="k">for</span> <span class="n">hint</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">hints</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">_expand_hint_key</span><span class="p">):</span>
            <span class="n">use_hint</span> <span class="o">=</span> <span class="n">hints</span><span class="p">[</span><span class="n">hint</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">use_hint</span><span class="p">:</span>
                <span class="n">hint</span> <span class="o">=</span> <span class="s1">&#39;_eval_expand_&#39;</span> <span class="o">+</span> <span class="n">hint</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">hit</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">was</span> <span class="o">=</span> <span class="n">expr</span>
            <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;multinomial&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span>
                    <span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;_eval_expand_multinomial&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mul&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span>
                    <span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;_eval_expand_mul&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">_expand_hint</span><span class="p">(</span>
                    <span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;_eval_expand_log&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">expr</span> <span class="o">==</span> <span class="n">was</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">modulus</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">modulus</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">modulus</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">modulus</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">or</span> <span class="n">modulus</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;modulus must be a positive integer, got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">modulus</span><span class="p">)</span>

            <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">coeff</span> <span class="o">%=</span> <span class="n">modulus</span>

                <span class="k">if</span> <span class="n">coeff</span><span class="p">:</span>
                    <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">tail</span><span class="p">)</span>

            <span class="n">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">terms</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expr</span>

    <span class="c1">###########################################################################</span>
    <span class="c1">################### GLOBAL ACTION VERB WRAPPER METHODS ####################</span>
    <span class="c1">###########################################################################</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the integrate function in sympy.integrals&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.integrals</span> <span class="k">import</span> <span class="n">integrate</span>
        <span class="k">return</span> <span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mf">1.7</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the simplify function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="k">import</span> <span class="n">simplify</span>
        <span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="k">import</span> <span class="n">count_ops</span>
        <span class="n">measure</span> <span class="o">=</span> <span class="n">measure</span> <span class="ow">or</span> <span class="n">count_ops</span>
        <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">measure</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nsimplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="p">[],</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the nsimplify function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="k">import</span> <span class="n">nsimplify</span>
        <span class="k">return</span> <span class="n">nsimplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">full</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">separate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the separate function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="k">import</span> <span class="n">expand_power_base</span>
        <span class="k">return</span> <span class="n">expand_power_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the collect function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="k">import</span> <span class="n">collect</span>
        <span class="k">return</span> <span class="n">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">evaluate</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">together</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the together function in sympy.polys&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="k">import</span> <span class="n">together</span>
        <span class="k">return</span> <span class="n">together</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the apart function in sympy.polys&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="k">import</span> <span class="n">apart</span>
        <span class="k">return</span> <span class="n">apart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ratsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the ratsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="k">import</span> <span class="n">ratsimp</span>
        <span class="k">return</span> <span class="n">ratsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">trigsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the trigsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="k">import</span> <span class="n">trigsimp</span>
        <span class="k">return</span> <span class="n">trigsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">radsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the radsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="k">import</span> <span class="n">radsimp</span>
        <span class="k">return</span> <span class="n">radsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">powsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the powsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="k">import</span> <span class="n">powsimp</span>
        <span class="k">return</span> <span class="n">powsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">combsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the combsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="k">import</span> <span class="n">combsimp</span>
        <span class="k">return</span> <span class="n">combsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">gammasimp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the gammasimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="k">import</span> <span class="n">gammasimp</span>
        <span class="k">return</span> <span class="n">gammasimp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the factor() function in sympy.polys.polytools&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="k">import</span> <span class="n">factor</span>
        <span class="k">return</span> <span class="n">factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">refine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumption</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the refine function in sympy.assumptions&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.assumptions</span> <span class="k">import</span> <span class="n">refine</span>
        <span class="k">return</span> <span class="n">refine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumption</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the cancel function in sympy.polys&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="k">import</span> <span class="n">cancel</span>
        <span class="k">return</span> <span class="n">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the multiplicative inverse of ``self`` mod ``g``</span>
<span class="sd">        where ``self`` (and ``g``) may be symbolic expressions).</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys.polytools</span> <span class="k">import</span> <span class="n">invert</span>
        <span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="k">import</span> <span class="n">mod_inverse</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s1">&#39;is_number&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mod_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return x rounded to the given decimal place.</span>

<span class="sd">        If a complex number would results, apply round to the real</span>
<span class="sd">        and imaginary components of the number.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import pi, E, I, S, Add, Mul, Number</span>
<span class="sd">        &gt;&gt;&gt; S(10.5).round()</span>
<span class="sd">        11.</span>
<span class="sd">        &gt;&gt;&gt; pi.round()</span>
<span class="sd">        3.</span>
<span class="sd">        &gt;&gt;&gt; pi.round(2)</span>
<span class="sd">        3.14</span>
<span class="sd">        &gt;&gt;&gt; (2*pi + E*I).round()</span>
<span class="sd">        6. + 3.*I</span>

<span class="sd">        The round method has a chopping effect:</span>

<span class="sd">        &gt;&gt;&gt; (2*pi + I/10).round()</span>
<span class="sd">        6.</span>
<span class="sd">        &gt;&gt;&gt; (pi/10 + 2*I).round()</span>
<span class="sd">        2.*I</span>
<span class="sd">        &gt;&gt;&gt; (pi/10 + E*I).round(2)</span>
<span class="sd">        0.31 + 2.72*I</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        Do not confuse the Python builtin function, round, with the</span>
<span class="sd">        SymPy method of the same name. The former always returns a float</span>
<span class="sd">        (or raises an error if applied to a complex value) while the</span>
<span class="sd">        latter returns either a Number or a complex number:</span>

<span class="sd">        &gt;&gt;&gt; isinstance(round(S(123), -2), Number)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; isinstance(S(123).round(-2), Number)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; isinstance((3*I).round(), Mul)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; isinstance((1 + 3*I).round(), Add)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Float</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can&#39;t round symbolic expression&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="n">xn</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pure_complex</span><span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="n">or_real</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a number but got </span><span class="si">%s</span><span class="s1">:&#39;</span> <span class="o">%</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s1">&#39;func&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">ComplexInfinity</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">i</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="o">*</span><span class="n">r</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">precs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">_prec</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Float</span><span class="p">)]</span>
        <span class="n">dps</span> <span class="o">=</span> <span class="n">prec_to_dps</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">precs</span><span class="p">))</span> <span class="k">if</span> <span class="n">precs</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">mag_first_dig</span> <span class="o">=</span> <span class="n">_mag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">allow</span> <span class="o">=</span> <span class="n">digits_needed</span> <span class="o">=</span> <span class="n">mag_first_dig</span> <span class="o">+</span> <span class="n">p</span>
        <span class="k">if</span> <span class="n">dps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">allow</span> <span class="o">&gt;</span> <span class="n">dps</span><span class="p">:</span>
            <span class="n">allow</span> <span class="o">=</span> <span class="n">dps</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>  <span class="c1"># magnitude needed to bring digit p to units place</span>
        <span class="n">xwas</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">mag</span><span class="p">)</span>  <span class="c1"># add the half for rounding</span>
        <span class="n">i10</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">mag</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">n</span><span class="p">((</span><span class="n">dps</span> <span class="k">if</span> <span class="n">dps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">digits_needed</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i10</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">xwas</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">mag</span><span class="p">)</span>  <span class="c1"># should have gone the other way</span>
            <span class="n">i10</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">mag</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">n</span><span class="p">((</span><span class="n">dps</span> <span class="k">if</span> <span class="n">dps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">digits_needed</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="o">-</span><span class="n">i10</span><span class="p">)</span><span class="o">//</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">i10</span><span class="p">)</span><span class="o">//</span><span class="mi">10</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">mag</span>
        <span class="k">elif</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">/=</span> <span class="n">mag</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rv</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
            <span class="c1"># use str or else it won&#39;t be a float</span>
            <span class="k">return</span> <span class="n">Float</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">rv</span><span class="p">),</span> <span class="n">digits_needed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allow</span> <span class="ow">and</span> <span class="n">rv</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">allow</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">Float</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="n">allow</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_derivative_matrix_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices.expressions.matexpr</span> <span class="k">import</span> <span class="n">_LeftRightArgs</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">_LeftRightArgs</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">higher</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_eval_derivative</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>


<span class="k">class</span> <span class="nc">AtomicExpr</span><span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A parent class for object which are both atoms and Exprs.</span>

<span class="sd">    For example: Symbol, Number, Rational, Integer, ...</span>
<span class="sd">    But not: Add, Mul, Pow, ...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_number</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_Atom</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_eval_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="k">def</span> <span class="nf">_eval_derivative_n_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Piecewise</span><span class="p">,</span> <span class="n">Eq</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">MatrixExpr</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices.common</span> <span class="k">import</span> <span class="n">MatrixCommon</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">MatrixCommon</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">MatrixExpr</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AtomicExpr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_eval_derivative_n_times</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Piecewise</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">Eq</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Eq</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Piecewise</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">Eq</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_eval_is_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_eval_is_rational_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_eval_is_algebraic_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_eval_nseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">expr_free_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">_mag</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return integer ``i`` such that .1 &lt;= x/10**i &lt; 1</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.core.expr import _mag</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Float</span>
<span class="sd">    &gt;&gt;&gt; _mag(Float(.1))</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; _mag(Float(.01))</span>
<span class="sd">    -1</span>
<span class="sd">    &gt;&gt;&gt; _mag(Float(1234))</span>
<span class="sd">    4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">log10</span><span class="p">,</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">log</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Float</span>
    <span class="n">xpos</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">n</span><span class="p">())</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">xpos</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">mag_first_dig</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">xpos</span><span class="p">)))</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
        <span class="n">mag_first_dig</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">Float</span><span class="p">(</span><span class="n">mpf_log</span><span class="p">(</span><span class="n">xpos</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">,</span> <span class="mi">53</span><span class="p">))</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
    <span class="c1"># check that we aren&#39;t off by 1</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">xpos</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="n">mag_first_dig</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">xpos</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="n">mag_first_dig</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span>
        <span class="n">mag_first_dig</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">mag_first_dig</span>


<span class="k">class</span> <span class="nc">UnevaluatedExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expression that is not evaluated unless released.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import UnevaluatedExpr</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, b, x, y</span>
<span class="sd">    &gt;&gt;&gt; x*(1/x)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; x*UnevaluatedExpr(1/x)</span>
<span class="sd">    x*1/x</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">_sympify</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;deep&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_n2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return (a - b).evalf(2) if a and b are comparable, else None.</span>
<span class="sd">    This should only be used when a and b are already sympified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># /!\ it is very important (see issue 8245) not to</span>
    <span class="c1"># use a re-evaluated number in the calculation of dif</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_comparable</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">is_comparable</span><span class="p">:</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_comparable</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dif</span>


<span class="k">def</span> <span class="nf">unchanged</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if `func` applied to the `args` is unchanged.</span>
<span class="sd">    Can be used instead of `assert foo == foo`.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.core.expr import unchanged</span>
<span class="sd">    &gt;&gt;&gt; from sympy.functions.elementary.trigonometric import cos</span>
<span class="sd">    &gt;&gt;&gt; from sympy.core.numbers import pi</span>

<span class="sd">    &gt;&gt;&gt; unchanged(cos, 1)  # instead of assert cos(1) == cos(1)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; unchanged(cos, pi)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">func</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">args</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">sympify</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>


<span class="kn">from</span> <span class="nn">.mul</span> <span class="k">import</span> <span class="n">Mul</span>
<span class="kn">from</span> <span class="nn">.add</span> <span class="k">import</span> <span class="n">Add</span>
<span class="kn">from</span> <span class="nn">.power</span> <span class="k">import</span> <span class="n">Pow</span>
<span class="kn">from</span> <span class="nn">.function</span> <span class="k">import</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">Function</span>
<span class="kn">from</span> <span class="nn">.mod</span> <span class="k">import</span> <span class="n">Mod</span>
<span class="kn">from</span> <span class="nn">.exprtools</span> <span class="k">import</span> <span class="n">factor_terms</span>
<span class="kn">from</span> <span class="nn">.numbers</span> <span class="k">import</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Rational</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright J. Taylor and others
      <span class="lastupdated">
        Last updated on Sep 24, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>