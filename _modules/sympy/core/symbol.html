

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Selection &mdash; Selection Documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />


</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../algorithms/index.html">Non-randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../randomized/index.html">Randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../learning/index.html">Learning selection</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">selection</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>Selection</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sympy.core.symbol</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">sympy.core.assumptions</span> <span class="k">import</span> <span class="n">StdFactKB</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="k">import</span> <span class="p">(</span><span class="n">string_types</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">is_sequence</span><span class="p">,</span>
    <span class="n">ordered</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.basic</span> <span class="k">import</span> <span class="n">Basic</span>
<span class="kn">from</span> <span class="nn">.sympify</span> <span class="k">import</span> <span class="n">sympify</span>
<span class="kn">from</span> <span class="nn">.singleton</span> <span class="k">import</span> <span class="n">S</span>
<span class="kn">from</span> <span class="nn">.expr</span> <span class="k">import</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">AtomicExpr</span>
<span class="kn">from</span> <span class="nn">.cache</span> <span class="k">import</span> <span class="n">cacheit</span>
<span class="kn">from</span> <span class="nn">.function</span> <span class="k">import</span> <span class="n">FunctionClass</span>
<span class="kn">from</span> <span class="nn">sympy.core.logic</span> <span class="k">import</span> <span class="n">fuzzy_bool</span>
<span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="k">import</span> <span class="n">Boolean</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="k">import</span> <span class="n">cartes</span>
<span class="kn">from</span> <span class="nn">sympy.core.containers</span> <span class="k">import</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">import</span> <span class="nn">re</span> <span class="k">as</span> <span class="nn">_re</span>
<span class="kn">import</span> <span class="nn">random</span>


<span class="k">def</span> <span class="nf">_symbol</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">matching_symbol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return s if s is a Symbol, else if s is a string, return either</span>
<span class="sd">    the matching_symbol if the names are the same or else a new symbol</span>
<span class="sd">    with the same assumptions as the matching symbol (or the</span>
<span class="sd">    assumptions as provided).</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Symbol, Dummy</span>
<span class="sd">    &gt;&gt;&gt; from sympy.core.symbol import _symbol</span>
<span class="sd">    &gt;&gt;&gt; _symbol(&#39;y&#39;)</span>
<span class="sd">    y</span>
<span class="sd">    &gt;&gt;&gt; _.is_real is None</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; _symbol(&#39;y&#39;, real=True).is_real</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = Symbol(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; _symbol(x, real=True)</span>
<span class="sd">    x</span>
<span class="sd">    &gt;&gt;&gt; _.is_real is None  # ignore attribute if s is a Symbol</span>
<span class="sd">    True</span>

<span class="sd">    Below, the variable sym has the name &#39;foo&#39;:</span>

<span class="sd">    &gt;&gt;&gt; sym = Symbol(&#39;foo&#39;, real=True)</span>

<span class="sd">    Since &#39;x&#39; is not the same as sym&#39;s name, a new symbol is created:</span>

<span class="sd">    &gt;&gt;&gt; _symbol(&#39;x&#39;, sym).name</span>
<span class="sd">    &#39;x&#39;</span>

<span class="sd">    It will acquire any assumptions give:</span>

<span class="sd">    &gt;&gt;&gt; _symbol(&#39;x&#39;, sym, real=False).is_real</span>
<span class="sd">    False</span>

<span class="sd">    Since &#39;foo&#39; is the same as sym&#39;s name, sym is returned</span>

<span class="sd">    &gt;&gt;&gt; _symbol(&#39;foo&#39;, sym)</span>
<span class="sd">    foo</span>

<span class="sd">    Any assumptions given are ignored:</span>

<span class="sd">    &gt;&gt;&gt; _symbol(&#39;foo&#39;, sym, real=False).is_real</span>
<span class="sd">    True</span>

<span class="sd">    NB: the symbol here may not be the same as a symbol with the same</span>
<span class="sd">    name defined elsewhere as a result of different assumptions.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    sympy.core.symbol.Symbol</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">matching_symbol</span> <span class="ow">and</span> <span class="n">matching_symbol</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">matching_symbol</span>
        <span class="k">return</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">s</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;symbol must be string for symbol name or Symbol&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_uniquely_named_symbol</span><span class="p">(</span><span class="n">xname</span><span class="p">,</span> <span class="n">exprs</span><span class="o">=</span><span class="p">(),</span> <span class="n">compare</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">modify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a symbol which, when printed, will have a name unique</span>
<span class="sd">    from any other already in the expressions given. The name is made</span>
<span class="sd">    unique by prepending underscores (default) but this can be</span>
<span class="sd">    customized with the keyword &#39;modify&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">        xname : a string or a Symbol (when symbol xname &lt;- str(xname))</span>
<span class="sd">        compare : a single arg function that takes a symbol and returns</span>
<span class="sd">            a string to be compared with xname (the default is the str</span>
<span class="sd">            function which indicates how the name will look when it</span>
<span class="sd">            is printed, e.g. this includes underscores that appear on</span>
<span class="sd">            Dummy symbols)</span>
<span class="sd">        modify : a single arg function that changes its string argument</span>
<span class="sd">            in some way (the default is to preppend underscores)</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.core.symbol import _uniquely_named_symbol as usym, Dummy</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; usym(&#39;x&#39;, x)</span>
<span class="sd">    _x</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">default</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">xname</span><span class="p">):</span>
        <span class="n">xname</span><span class="p">,</span> <span class="n">default</span> <span class="o">=</span> <span class="n">xname</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">xname</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exprs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_symbol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">default</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">exprs</span><span class="p">):</span>
        <span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">exprs</span><span class="p">]</span>
    <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">modify</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">modify</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">s</span>
    <span class="k">while</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">compare</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">modify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_symbol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">default</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Symbol</span><span class="p">(</span><span class="n">AtomicExpr</span><span class="p">,</span> <span class="n">Boolean</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assumptions:</span>
<span class="sd">       commutative = True</span>

<span class="sd">    You can override the default assumptions in the constructor:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">    &gt;&gt;&gt; A,B = symbols(&#39;A,B&#39;, commutative = False)</span>
<span class="sd">    &gt;&gt;&gt; bool(A*B != B*A)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; bool(A*B*2 == 2*A*B) == True # multiplication by scalars is commutative</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_comparable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>

    <span class="n">is_Symbol</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_symbol</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_diff_wrt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allow derivatives wrt Symbols.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">            &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">            &gt;&gt;&gt; x = Symbol(&#39;x&#39;)</span>
<span class="sd">            &gt;&gt;&gt; x._diff_wrt</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sanitize</span><span class="p">(</span><span class="n">assumptions</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove None, covert values to bool, check commutativity *in place*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># be strict about commutativity: cannot be None</span>
        <span class="n">is_commutative</span> <span class="o">=</span> <span class="n">fuzzy_bool</span><span class="p">(</span><span class="n">assumptions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;commutative&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">is_commutative</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">whose</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">if</span> <span class="n">obj</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">commutativity must be True or False.&#39;</span> <span class="o">%</span> <span class="n">whose</span><span class="p">)</span>

        <span class="c1"># sanitize other assumptions so 1 -&gt; True and 0 -&gt; False</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">assumptions</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
            <span class="kn">from</span> <span class="nn">sympy.utilities.exceptions</span> <span class="k">import</span> <span class="n">SymPyDeprecationWarning</span>
            <span class="n">keymap</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">keymap</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;bounded&#39;</span><span class="p">:</span> <span class="s1">&#39;finite&#39;</span><span class="p">,</span> <span class="s1">&#39;unbounded&#39;</span><span class="p">:</span> <span class="s1">&#39;infinite&#39;</span><span class="p">,</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span> <span class="s1">&#39;zero&#39;</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">keymap</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="n">SymPyDeprecationWarning</span><span class="p">(</span>
                    <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> assumption&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">,</span>
                    <span class="n">useinstead</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">keymap</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                    <span class="n">issue</span><span class="o">=</span><span class="mi">8071</span><span class="p">,</span>
                    <span class="n">deprecated_since_version</span><span class="o">=</span><span class="s2">&quot;0.7.6&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">warn</span><span class="p">()</span>
                <span class="n">assumptions</span><span class="p">[</span><span class="n">keymap</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="n">assumptions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">assumptions</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">keymap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="n">v</span> <span class="o">=</span> <span class="n">assumptions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">assumptions</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">assumptions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Symbols are identified by name and assumptions::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; Symbol(&quot;x&quot;) == Symbol(&quot;x&quot;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Symbol(&quot;x&quot;, real=True) == Symbol(&quot;x&quot;, real=False)</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_sanitize</span><span class="p">(</span><span class="n">assumptions</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Symbol</span><span class="o">.</span><span class="n">__xnew_cached_</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__new_stage2__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;name should be a string, not </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)))</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="c1"># TODO: Issue #8873: Forcing the commutative assumption here means</span>
        <span class="c1"># later code such as ``srepr()`` cannot tell whether the user</span>
        <span class="c1"># specified ``commutative=True`` or omitted it.  To workaround this,</span>
        <span class="c1"># we keep a copy of the assumptions dict, then create the StdFactKB,</span>
        <span class="c1"># and finally overwrite its ``._generator`` with the dict copy.  This</span>
        <span class="c1"># is a bit of a hack because we assume StdFactKB merely copies the</span>
        <span class="c1"># given dict as ``._generator``, but future modification might, e.g.,</span>
        <span class="c1"># compute a minimal equivalent assumption set.</span>
        <span class="n">tmp_asm_copy</span> <span class="o">=</span> <span class="n">assumptions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># be strict about commutativity</span>
        <span class="n">is_commutative</span> <span class="o">=</span> <span class="n">fuzzy_bool</span><span class="p">(</span><span class="n">assumptions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;commutative&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="n">assumptions</span><span class="p">[</span><span class="s1">&#39;commutative&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_commutative</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_assumptions</span> <span class="o">=</span> <span class="n">StdFactKB</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_assumptions</span><span class="o">.</span><span class="n">_generator</span> <span class="o">=</span> <span class="n">tmp_asm_copy</span>  <span class="c1"># Issue #8873</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="n">__xnew__</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span>
        <span class="n">__new_stage2__</span><span class="p">)</span>            <span class="c1"># never cached (e.g. dummy)</span>
    <span class="n">__xnew_cached_</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span>
        <span class="n">cacheit</span><span class="p">(</span><span class="n">__new_stage2__</span><span class="p">))</span>   <span class="c1"># symbols are always cached</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;_assumptions&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assumptions</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_hashable_content</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Note: user-specified assumptions not hashed, just derived ones</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">_eval_subs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.core.power</span> <span class="k">import</span> <span class="n">Pow</span>
        <span class="k">if</span> <span class="n">old</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_eval_subs</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">assumptions0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span>
                <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assumptions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_key</span><span class="p">(),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),)),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

    <span class="k">def</span> <span class="nf">as_dummy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Dummy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_real_imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">im</span><span class="p">,</span> <span class="n">re</span>
        <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">re</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">im</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_sage_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">sage.all</span> <span class="k">as</span> <span class="nn">sage</span>
        <span class="k">return</span> <span class="n">sage</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">wrt</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">wrt</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">wrt</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">free_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="p">}</span>

    <span class="n">binary_symbols</span> <span class="o">=</span> <span class="n">free_symbols</span>  <span class="c1"># in this case, not always</span>

    <span class="k">def</span> <span class="nf">as_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">UniversalSet</span>


<span class="k">class</span> <span class="nc">Dummy</span><span class="p">(</span><span class="n">Symbol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dummy symbols are each unique, even if they have the same name:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Dummy</span>
<span class="sd">    &gt;&gt;&gt; Dummy(&quot;x&quot;) == Dummy(&quot;x&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    If a name is not supplied then a string value of an internal count will be</span>
<span class="sd">    used. This is useful when a temporary variable is needed and the name</span>
<span class="sd">    of the variable used in the expression is not important.</span>

<span class="sd">    &gt;&gt;&gt; Dummy() #doctest: +SKIP</span>
<span class="sd">    _Dummy_10</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># In the rare event that a Dummy object needs to be recreated, both the</span>
    <span class="c1"># `name` and `dummy_index` should be passed.  This is used by `srepr` for</span>
    <span class="c1"># example:</span>
    <span class="c1"># &gt;&gt;&gt; d1 = Dummy()</span>
    <span class="c1"># &gt;&gt;&gt; d2 = eval(srepr(d1))</span>
    <span class="c1"># &gt;&gt;&gt; d2 == d1</span>
    <span class="c1"># True</span>
    <span class="c1">#</span>
    <span class="c1"># If a new session is started between `srepr` and `eval`, there is a very</span>
    <span class="c1"># small chance that `d2` will be equal to a previously-created Dummy.</span>

    <span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">_prng</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">()</span>
    <span class="n">_base_dummy_index</span> <span class="o">=</span> <span class="n">_prng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dummy_index&#39;</span><span class="p">]</span>

    <span class="n">is_Dummy</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dummy_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dummy_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;If you specify a dummy_index, you must also provide a name&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Dummy_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">Dummy</span><span class="o">.</span><span class="n">_count</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dummy_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dummy_index</span> <span class="o">=</span> <span class="n">Dummy</span><span class="o">.</span><span class="n">_base_dummy_index</span> <span class="o">+</span> <span class="n">Dummy</span><span class="o">.</span><span class="n">_count</span>
            <span class="n">Dummy</span><span class="o">.</span><span class="n">_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">_sanitize</span><span class="p">(</span><span class="n">assumptions</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Symbol</span><span class="o">.</span><span class="n">__xnew__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">dummy_index</span> <span class="o">=</span> <span class="n">dummy_index</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;_assumptions&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assumptions</span><span class="p">,</span> <span class="s1">&#39;dummy_index&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dummy_index</span><span class="p">}</span>

    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_key</span><span class="p">(),</span> <span class="p">(</span>
            <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dummy_index</span><span class="p">)),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

    <span class="k">def</span> <span class="nf">_hashable_content</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Symbol</span><span class="o">.</span><span class="n">_hashable_content</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dummy_index</span><span class="p">,)</span>


<span class="k">class</span> <span class="nc">Wild</span><span class="p">(</span><span class="n">Symbol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Wild symbol matches anything, or anything</span>
<span class="sd">    without whatever is explicitly excluded.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    name : str</span>
<span class="sd">        Name of the Wild instance.</span>
<span class="sd">    exclude : iterable, optional</span>
<span class="sd">        Instances in ``exclude`` will not be matched.</span>
<span class="sd">    properties : iterable of functions, optional</span>
<span class="sd">        Functions, each taking an expressions as input</span>
<span class="sd">        and returns a ``bool``. All functions in ``properties``</span>
<span class="sd">        need to return ``True`` in order for the Wild instance</span>
<span class="sd">        to match the expression.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Wild, WildFunction, cos, pi</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">    &gt;&gt;&gt; a = Wild(&#39;a&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x.match(a)</span>
<span class="sd">    {a_: x}</span>
<span class="sd">    &gt;&gt;&gt; pi.match(a)</span>
<span class="sd">    {a_: pi}</span>
<span class="sd">    &gt;&gt;&gt; (3*x**2).match(a*x)</span>
<span class="sd">    {a_: 3*x}</span>
<span class="sd">    &gt;&gt;&gt; cos(x).match(a)</span>
<span class="sd">    {a_: cos(x)}</span>
<span class="sd">    &gt;&gt;&gt; b = Wild(&#39;b&#39;, exclude=[x])</span>
<span class="sd">    &gt;&gt;&gt; (3*x**2).match(b*x)</span>
<span class="sd">    &gt;&gt;&gt; b.match(a)</span>
<span class="sd">    {a_: b_}</span>
<span class="sd">    &gt;&gt;&gt; A = WildFunction(&#39;A&#39;)</span>
<span class="sd">    &gt;&gt;&gt; A.match(a)</span>
<span class="sd">    {a_: A_}</span>

<span class="sd">    Tips</span>
<span class="sd">    ====</span>

<span class="sd">    When using Wild, be sure to use the exclude</span>
<span class="sd">    keyword to make the pattern more precise.</span>
<span class="sd">    Without the exclude pattern, you may get matches</span>
<span class="sd">    that are technically correct, but not what you</span>
<span class="sd">    wanted. For example, using the above without</span>
<span class="sd">    exclude:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">    &gt;&gt;&gt; a, b = symbols(&#39;a b&#39;, cls=Wild)</span>
<span class="sd">    &gt;&gt;&gt; (2 + 3*y).match(a*x + b*y)</span>
<span class="sd">    {a_: 2/x, b_: 3}</span>

<span class="sd">    This is technically correct, because</span>
<span class="sd">    (2/x)*x + 3*y == 2 + 3*y, but you probably</span>
<span class="sd">    wanted it to not match at all. The issue is that</span>
<span class="sd">    you really didn&#39;t want a and b to include x and y,</span>
<span class="sd">    and the exclude parameter lets you specify exactly</span>
<span class="sd">    this.  With the exclude parameter, the pattern will</span>
<span class="sd">    not match.</span>

<span class="sd">    &gt;&gt;&gt; a = Wild(&#39;a&#39;, exclude=[x, y])</span>
<span class="sd">    &gt;&gt;&gt; b = Wild(&#39;b&#39;, exclude=[x, y])</span>
<span class="sd">    &gt;&gt;&gt; (2 + 3*y).match(a*x + b*y)</span>

<span class="sd">    Exclude also helps remove ambiguity from matches.</span>

<span class="sd">    &gt;&gt;&gt; E = 2*x**3*y*z</span>
<span class="sd">    &gt;&gt;&gt; a, b = symbols(&#39;a b&#39;, cls=Wild)</span>
<span class="sd">    &gt;&gt;&gt; E.match(a*b)</span>
<span class="sd">    {a_: 2*y*z, b_: x**3}</span>
<span class="sd">    &gt;&gt;&gt; a = Wild(&#39;a&#39;, exclude=[x, y])</span>
<span class="sd">    &gt;&gt;&gt; E.match(a*b)</span>
<span class="sd">    {a_: z, b_: 2*x**3*y}</span>
<span class="sd">    &gt;&gt;&gt; a = Wild(&#39;a&#39;, exclude=[x, y, z])</span>
<span class="sd">    &gt;&gt;&gt; E.match(a*b)</span>
<span class="sd">    {a_: 2, b_: x**3*y*z}</span>

<span class="sd">    Wild also accepts a ``properties`` parameter:</span>

<span class="sd">    &gt;&gt;&gt; a = Wild(&#39;a&#39;, properties=[lambda k: k.is_Integer])</span>
<span class="sd">    &gt;&gt;&gt; E.match(a*b)</span>
<span class="sd">    {a_: 2, b_: x**3*y*z}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_Wild</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;exclude&#39;</span><span class="p">,</span> <span class="s1">&#39;properties&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">(),</span> <span class="n">properties</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
        <span class="n">exclude</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">])</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">properties</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_sanitize</span><span class="p">(</span><span class="n">assumptions</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Wild</span><span class="o">.</span><span class="n">__xnew__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">exclude</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@cacheit</span>
    <span class="k">def</span> <span class="nf">__xnew__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">exclude</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Symbol</span><span class="o">.</span><span class="n">__xnew__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">exclude</span> <span class="o">=</span> <span class="n">exclude</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="n">properties</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_hashable_content</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Wild</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_hashable_content</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exclude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>

    <span class="c1"># TODO add check against another Wild</span>
    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">repl_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">old</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclude</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">f</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">repl_dict</span> <span class="o">=</span> <span class="n">repl_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">repl_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="k">return</span> <span class="n">repl_dict</span>


<span class="n">_range</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;([0-9]*:[0-9]+|[a-zA-Z]?:[a-zA-Z])&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">symbols</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform strings into instances of :class:`Symbol` class.</span>

<span class="sd">    :func:`symbols` function returns a sequence of symbols with names taken</span>
<span class="sd">    from ``names`` argument, which can be a comma or whitespace delimited</span>
<span class="sd">    string, or a sequence of strings::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols, Function</span>

<span class="sd">        &gt;&gt;&gt; x, y, z = symbols(&#39;x,y,z&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a, b, c = symbols(&#39;a b c&#39;)</span>

<span class="sd">    The type of output is dependent on the properties of input arguments::</span>

<span class="sd">        &gt;&gt;&gt; symbols(&#39;x&#39;)</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; symbols(&#39;x,&#39;)</span>
<span class="sd">        (x,)</span>
<span class="sd">        &gt;&gt;&gt; symbols(&#39;x,y&#39;)</span>
<span class="sd">        (x, y)</span>
<span class="sd">        &gt;&gt;&gt; symbols((&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">        (a, b, c)</span>
<span class="sd">        &gt;&gt;&gt; symbols([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        [a, b, c]</span>
<span class="sd">        &gt;&gt;&gt; symbols({&#39;a&#39;, &#39;b&#39;, &#39;c&#39;})</span>
<span class="sd">        {a, b, c}</span>

<span class="sd">    If an iterable container is needed for a single symbol, set the ``seq``</span>
<span class="sd">    argument to ``True`` or terminate the symbol name with a comma::</span>

<span class="sd">        &gt;&gt;&gt; symbols(&#39;x&#39;, seq=True)</span>
<span class="sd">        (x,)</span>

<span class="sd">    To reduce typing, range syntax is supported to create indexed symbols.</span>
<span class="sd">    Ranges are indicated by a colon and the type of range is determined by</span>
<span class="sd">    the character to the right of the colon. If the character is a digit</span>
<span class="sd">    then all contiguous digits to the left are taken as the nonnegative</span>
<span class="sd">    starting value (or 0 if there is no digit left of the colon) and all</span>
<span class="sd">    contiguous digits to the right are taken as 1 greater than the ending</span>
<span class="sd">    value::</span>

<span class="sd">        &gt;&gt;&gt; symbols(&#39;x:10&#39;)</span>
<span class="sd">        (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)</span>

<span class="sd">        &gt;&gt;&gt; symbols(&#39;x5:10&#39;)</span>
<span class="sd">        (x5, x6, x7, x8, x9)</span>
<span class="sd">        &gt;&gt;&gt; symbols(&#39;x5(:2)&#39;)</span>
<span class="sd">        (x50, x51)</span>

<span class="sd">        &gt;&gt;&gt; symbols(&#39;x5:10,y:5&#39;)</span>
<span class="sd">        (x5, x6, x7, x8, x9, y0, y1, y2, y3, y4)</span>

<span class="sd">        &gt;&gt;&gt; symbols((&#39;x5:10&#39;, &#39;y:5&#39;))</span>
<span class="sd">        ((x5, x6, x7, x8, x9), (y0, y1, y2, y3, y4))</span>

<span class="sd">    If the character to the right of the colon is a letter, then the single</span>
<span class="sd">    letter to the left (or &#39;a&#39; if there is none) is taken as the start</span>
<span class="sd">    and all characters in the lexicographic range *through* the letter to</span>
<span class="sd">    the right are used as the range::</span>

<span class="sd">        &gt;&gt;&gt; symbols(&#39;x:z&#39;)</span>
<span class="sd">        (x, y, z)</span>
<span class="sd">        &gt;&gt;&gt; symbols(&#39;x:c&#39;)  # null range</span>
<span class="sd">        ()</span>
<span class="sd">        &gt;&gt;&gt; symbols(&#39;x(:c)&#39;)</span>
<span class="sd">        (xa, xb, xc)</span>

<span class="sd">        &gt;&gt;&gt; symbols(&#39;:c&#39;)</span>
<span class="sd">        (a, b, c)</span>

<span class="sd">        &gt;&gt;&gt; symbols(&#39;a:d, x:z&#39;)</span>
<span class="sd">        (a, b, c, d, x, y, z)</span>

<span class="sd">        &gt;&gt;&gt; symbols((&#39;a:d&#39;, &#39;x:z&#39;))</span>
<span class="sd">        ((a, b, c, d), (x, y, z))</span>

<span class="sd">    Multiple ranges are supported; contiguous numerical ranges should be</span>
<span class="sd">    separated by parentheses to disambiguate the ending number of one</span>
<span class="sd">    range from the starting number of the next::</span>

<span class="sd">        &gt;&gt;&gt; symbols(&#39;x:2(1:3)&#39;)</span>
<span class="sd">        (x01, x02, x11, x12)</span>
<span class="sd">        &gt;&gt;&gt; symbols(&#39;:3:2&#39;)  # parsing is from left to right</span>
<span class="sd">        (00, 01, 10, 11, 20, 21)</span>

<span class="sd">    Only one pair of parentheses surrounding ranges are removed, so to</span>
<span class="sd">    include parentheses around ranges, double them. And to include spaces,</span>
<span class="sd">    commas, or colons, escape them with a backslash::</span>

<span class="sd">        &gt;&gt;&gt; symbols(&#39;x((a:b))&#39;)</span>
<span class="sd">        (x(a), x(b))</span>
<span class="sd">        &gt;&gt;&gt; symbols(r&#39;x(:1\,:2)&#39;)  # or r&#39;x((:1)\,(:2))&#39;</span>
<span class="sd">        (x(0,0), x(0,1))</span>

<span class="sd">    All newly created symbols have assumptions set according to ``args``::</span>

<span class="sd">        &gt;&gt;&gt; a = symbols(&#39;a&#39;, integer=True)</span>
<span class="sd">        &gt;&gt;&gt; a.is_integer</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; x, y, z = symbols(&#39;x,y,z&#39;, real=True)</span>
<span class="sd">        &gt;&gt;&gt; x.is_real and y.is_real and z.is_real</span>
<span class="sd">        True</span>

<span class="sd">    Despite its name, :func:`symbols` can create symbol-like objects like</span>
<span class="sd">    instances of Function or Wild classes. To achieve this, set ``cls``</span>
<span class="sd">    keyword argument to the desired type::</span>

<span class="sd">        &gt;&gt;&gt; symbols(&#39;f,g,h&#39;, cls=Function)</span>
<span class="sd">        (f, g, h)</span>

<span class="sd">        &gt;&gt;&gt; type(_[0])</span>
<span class="sd">        &lt;class &#39;sympy.core.function.UndefinedFunction&#39;&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="n">marker</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">literals</span> <span class="o">=</span> <span class="p">[</span><span class="sa">r</span><span class="s1">&#39;\,&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\:&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\ &#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">literals</span><span class="p">)):</span>
            <span class="n">lit</span> <span class="o">=</span> <span class="n">literals</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lit</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">while</span> <span class="nb">chr</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">lit_char</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>
                <span class="n">marker</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">lit</span><span class="p">,</span> <span class="n">lit_char</span><span class="p">)</span>
                <span class="n">literals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lit_char</span><span class="p">,</span> <span class="n">lit</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">def</span> <span class="nf">literal</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">literals</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">literals</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s</span>

        <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">as_seq</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">as_seq</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no symbols given&#39;</span><span class="p">)</span>

        <span class="c1"># split on commas</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;missing symbol between commas&#39;</span><span class="p">)</span>
        <span class="c1"># split on spaces</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="bp">cls</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;cls&#39;</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;seq&#39;</span><span class="p">,</span> <span class="n">as_seq</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;missing symbol&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="s1">&#39;:&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">literal</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">split</span> <span class="o">=</span> <span class="n">_range</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="c1"># remove 1 layer of bounding parentheses around ranges</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">split</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">and</span> <span class="s1">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;:&#39;</span> <span class="ow">and</span> \
                        <span class="n">split</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                        <span class="n">split</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">):</span>
                    <span class="n">split</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">split</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">split</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">split</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">split</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;missing end range&#39;</span><span class="p">)</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span><span class="p">:</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                        <span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="ow">or</span> <span class="s1">&#39;a&#39;</span>
                        <span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                            <span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
                            <span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>  <span class="c1"># inclusive</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">seq</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">names</span> <span class="o">=</span> <span class="n">split</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">cartes</span><span class="p">(</span><span class="o">*</span><span class="n">split</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">literals</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="bp">cls</span><span class="p">(</span><span class="n">literal</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">names</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="bp">cls</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">names</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">seq</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">()</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbols</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">names</span><span class="p">)(</span><span class="n">result</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create symbols and inject them into the global namespace.</span>

<span class="sd">    This calls :func:`symbols` with the same arguments and puts the results</span>
<span class="sd">    into the *global* namespace. It&#39;s recommended not to use :func:`var` in</span>
<span class="sd">    library code, where :func:`symbols` has to be used::</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import var</span>

<span class="sd">    &gt;&gt;&gt; var(&#39;x&#39;)</span>
<span class="sd">    x</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    x</span>

<span class="sd">    &gt;&gt;&gt; var(&#39;a,ab,abc&#39;)</span>
<span class="sd">    (a, ab, abc)</span>
<span class="sd">    &gt;&gt;&gt; abc</span>
<span class="sd">    abc</span>

<span class="sd">    &gt;&gt;&gt; var(&#39;x,y&#39;, real=True)</span>
<span class="sd">    (x, y)</span>
<span class="sd">    &gt;&gt;&gt; x.is_real and y.is_real</span>
<span class="sd">    True</span>

<span class="sd">    See :func:`symbol` documentation for more details on what kinds of</span>
<span class="sd">    arguments can be passed to :func:`var`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recursively inject symbols to the global namespace. &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                <span class="n">frame</span><span class="o">.</span><span class="n">f_globals</span><span class="p">[</span><span class="n">symbol</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbol</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">FunctionClass</span><span class="p">):</span>
                <span class="n">frame</span><span class="o">.</span><span class="n">f_globals</span><span class="p">[</span><span class="n">symbol</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbol</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">traverse</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">currentframe</span>
    <span class="n">frame</span> <span class="o">=</span> <span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_back</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">syms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                <span class="n">frame</span><span class="o">.</span><span class="n">f_globals</span><span class="p">[</span><span class="n">syms</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">syms</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">FunctionClass</span><span class="p">):</span>
                <span class="n">frame</span><span class="o">.</span><span class="n">f_globals</span><span class="p">[</span><span class="n">syms</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">syms</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">traverse</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">frame</span>  <span class="c1"># break cyclic dependencies as stated in inspect docs</span>

    <span class="k">return</span> <span class="n">syms</span>

<span class="k">def</span> <span class="nf">disambiguate</span><span class="p">(</span><span class="o">*</span><span class="nb">iter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a Tuple containing the passed expressions with symbols</span>
<span class="sd">    that appear the same when printed replaced with numerically</span>
<span class="sd">    subscripted symbols, and all Dummy symbols replaced with Symbols.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    iter: list of symbols or expressions.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.core.symbol import disambiguate</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Dummy, Symbol, Tuple</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import y</span>

<span class="sd">    &gt;&gt;&gt; tup = Symbol(&#39;_x&#39;), Dummy(&#39;x&#39;), Dummy(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; disambiguate(*tup)</span>
<span class="sd">    (x_2, x, x_1)</span>

<span class="sd">    &gt;&gt;&gt; eqs = Tuple(Symbol(&#39;x&#39;)/y, Dummy(&#39;x&#39;)/y)</span>
<span class="sd">    &gt;&gt;&gt; disambiguate(*eqs)</span>
<span class="sd">    (x_1/y, x/y)</span>

<span class="sd">    &gt;&gt;&gt; ix = Symbol(&#39;x&#39;, integer=True)</span>
<span class="sd">    &gt;&gt;&gt; vx = Symbol(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; disambiguate(vx + ix)</span>
<span class="sd">    (x + x_1,)</span>

<span class="sd">    To make your own mapping of symbols to use, pass only the free symbols</span>
<span class="sd">    of the expressions and create a dictionary:</span>

<span class="sd">    &gt;&gt;&gt; free = eqs.free_symbols</span>
<span class="sd">    &gt;&gt;&gt; mapping = dict(zip(free, disambiguate(*free)))</span>
<span class="sd">    &gt;&gt;&gt; eqs.xreplace(mapping)</span>
<span class="sd">    (x_1/y, x/y)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_iter</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="nb">iter</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
    <span class="n">syms</span> <span class="o">=</span> <span class="n">ordered</span><span class="p">(</span><span class="n">new_iter</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">:</span>
        <span class="n">mapping</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">),</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
        <span class="c1"># the first or only symbol doesn&#39;t get subscripted but make</span>
        <span class="c1"># sure that it&#39;s a Symbol, not a Dummy</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="o">**</span><span class="n">mapping</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">assumptions0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">k0</span><span class="p">:</span>
            <span class="n">reps</span><span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">k0</span>
        <span class="c1"># the others get subscripts (and are made into Symbols)</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">k</span><span class="p">])):</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">skip</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">skip</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ki</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">reps</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">ki</span><span class="o">.</span><span class="n">assumptions0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_iter</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright J. Taylor and others
      <span class="lastupdated">
        Last updated on Sep 24, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>