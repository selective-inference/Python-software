

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Selection &mdash; Selection Documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />


</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../algorithms/index.html">Non-randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../randomized/index.html">Randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../learning/index.html">Learning selection</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">selection</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>Selection</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sympy.core.evalf</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Adaptive numerical evaluation of SymPy expressions, using mpmath</span>
<span class="sd">for mathematical functions.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">mpmath.libmp</span> <span class="k">as</span> <span class="nn">libmp</span>
<span class="kn">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">make_mpc</span><span class="p">,</span> <span class="n">make_mpf</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">mpc</span><span class="p">,</span> <span class="n">mpf</span><span class="p">,</span> <span class="n">nsum</span><span class="p">,</span> <span class="n">quadts</span><span class="p">,</span> <span class="n">quadosc</span><span class="p">,</span> <span class="n">workprec</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="n">inf</span> <span class="k">as</span> <span class="n">mpmath_inf</span>
<span class="kn">from</span> <span class="nn">mpmath.libmp</span> <span class="k">import</span> <span class="p">(</span><span class="n">from_int</span><span class="p">,</span> <span class="n">from_man_exp</span><span class="p">,</span> <span class="n">from_rational</span><span class="p">,</span> <span class="n">fhalf</span><span class="p">,</span>
        <span class="n">fnan</span><span class="p">,</span> <span class="n">fnone</span><span class="p">,</span> <span class="n">fone</span><span class="p">,</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">mpf_abs</span><span class="p">,</span> <span class="n">mpf_add</span><span class="p">,</span>
        <span class="n">mpf_atan</span><span class="p">,</span> <span class="n">mpf_atan2</span><span class="p">,</span> <span class="n">mpf_cmp</span><span class="p">,</span> <span class="n">mpf_cos</span><span class="p">,</span> <span class="n">mpf_e</span><span class="p">,</span> <span class="n">mpf_exp</span><span class="p">,</span> <span class="n">mpf_log</span><span class="p">,</span> <span class="n">mpf_lt</span><span class="p">,</span>
        <span class="n">mpf_mul</span><span class="p">,</span> <span class="n">mpf_neg</span><span class="p">,</span> <span class="n">mpf_pi</span><span class="p">,</span> <span class="n">mpf_pow</span><span class="p">,</span> <span class="n">mpf_pow_int</span><span class="p">,</span> <span class="n">mpf_shift</span><span class="p">,</span> <span class="n">mpf_sin</span><span class="p">,</span>
        <span class="n">mpf_sqrt</span><span class="p">,</span> <span class="n">normalize</span><span class="p">,</span> <span class="n">round_nearest</span><span class="p">,</span> <span class="n">to_int</span><span class="p">,</span> <span class="n">to_str</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">mpmath.libmp</span> <span class="k">import</span> <span class="n">bitcount</span> <span class="k">as</span> <span class="n">mpmath_bitcount</span>
<span class="kn">from</span> <span class="nn">mpmath.libmp.backend</span> <span class="k">import</span> <span class="n">MPZ</span>
<span class="kn">from</span> <span class="nn">mpmath.libmp.libmpc</span> <span class="k">import</span> <span class="n">_infs_nan</span>
<span class="kn">from</span> <span class="nn">mpmath.libmp.libmpf</span> <span class="k">import</span> <span class="n">dps_to_prec</span><span class="p">,</span> <span class="n">prec_to_dps</span>
<span class="kn">from</span> <span class="nn">mpmath.libmp.gammazeta</span> <span class="k">import</span> <span class="n">mpf_bernoulli</span>

<span class="kn">from</span> <span class="nn">.compatibility</span> <span class="k">import</span> <span class="n">SYMPY_INTS</span><span class="p">,</span> <span class="nb">range</span>
<span class="kn">from</span> <span class="nn">.sympify</span> <span class="k">import</span> <span class="n">sympify</span>
<span class="kn">from</span> <span class="nn">.singleton</span> <span class="k">import</span> <span class="n">S</span>

<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="k">import</span> <span class="n">is_sequence</span>

<span class="n">LG10</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">rnd</span> <span class="o">=</span> <span class="n">round_nearest</span>


<span class="k">def</span> <span class="nf">bitcount</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return smallest integer, b, such that |n|/2**b &lt; 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">mpmath_bitcount</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>

<span class="c1"># Used in a few places as placeholder values to denote exponents and</span>
<span class="c1"># precision levels, e.g. of exact numbers. Must be careful to avoid</span>
<span class="c1"># passing these to mpmath functions or returning them in final results.</span>
<span class="n">INF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">mpmath_inf</span><span class="p">)</span>
<span class="n">MINUS_INF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="n">mpmath_inf</span><span class="p">)</span>

<span class="c1"># ~= 100 digits. Real men set this to INF.</span>
<span class="n">DEFAULT_MAXPREC</span> <span class="o">=</span> <span class="mi">333</span>


<span class="k">class</span> <span class="nc">PrecisionExhausted</span><span class="p">(</span><span class="ne">ArithmeticError</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c1">#----------------------------------------------------------------------------#</span>
<span class="c1">#                                                                            #</span>
<span class="c1">#              Helper functions for arithmetic and complex parts             #</span>
<span class="c1">#                                                                            #</span>
<span class="c1">#----------------------------------------------------------------------------#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An mpf value tuple is a tuple of integers (sign, man, exp, bc)</span>
<span class="sd">representing a floating-point number: [1, -1][sign]*man*2**exp where</span>
<span class="sd">sign is 0 or 1 and bc should correspond to the number of bits used to</span>
<span class="sd">represent the mantissa (man) in binary notation, e.g.</span>

<span class="sd">&gt;&gt;&gt; from sympy.core.evalf import bitcount</span>
<span class="sd">&gt;&gt;&gt; sign, man, exp, bc = 0, 5, 1, 3</span>
<span class="sd">&gt;&gt;&gt; n = [1, -1][sign]*man*2**exp</span>
<span class="sd">&gt;&gt;&gt; n, bitcount(man)</span>
<span class="sd">(10, 3)</span>

<span class="sd">A temporary result is a tuple (re, im, re_acc, im_acc) where</span>
<span class="sd">re and im are nonzero mpf value tuples representing approximate</span>
<span class="sd">numbers, or None to denote exact zeros.</span>

<span class="sd">re_acc, im_acc are integers denoting log2(e) where e is the estimated</span>
<span class="sd">relative accuracy of the respective complex part, but may be anything</span>
<span class="sd">if the corresponding complex part is None.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">fastlog</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fast approximation of log2(x) for an mpf value tuple x.</span>

<span class="sd">    Notes: Calculated as exponent + width of mantissa. This is an</span>
<span class="sd">    approximation for two reasons: 1) it gives the ceil(log2(abs(x)))</span>
<span class="sd">    value and 2) it is too high by 1 in the case that x is an exact</span>
<span class="sd">    power of 2. Although this is easy to remedy by testing to see if</span>
<span class="sd">    the odd mpf mantissa is 1 (indicating that one was dealing with</span>
<span class="sd">    an exact power of 2) that would decrease the speed and is not</span>
<span class="sd">    necessary as this is only being used as an approximation for the</span>
<span class="sd">    number of bits in x. The correct return value could be written as</span>
<span class="sd">    &quot;x[2] + (x[3] if x[1] != 1 else 0)&quot;.</span>
<span class="sd">        Since mpf tuples always have an odd mantissa, no check is done</span>
<span class="sd">    to see if the mantissa is a multiple of 2 (in which case the</span>
<span class="sd">    result would be too large by 1).</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import log</span>
<span class="sd">    &gt;&gt;&gt; from sympy.core.evalf import fastlog, bitcount</span>
<span class="sd">    &gt;&gt;&gt; s, m, e = 0, 5, 1</span>
<span class="sd">    &gt;&gt;&gt; bc = bitcount(m)</span>
<span class="sd">    &gt;&gt;&gt; n = [1, -1][s]*m*2**e</span>
<span class="sd">    &gt;&gt;&gt; n, (log(n)/log(2)).evalf(2), fastlog((s, m, e, bc))</span>
<span class="sd">    (10, 3.3, 4)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fzero</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">MINUS_INF</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">pure_complex</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">or_real</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a and b if v matches a + I*b where b is not zero and</span>
<span class="sd">    a and b are Numbers, else None. If `or_real` is True then 0 will</span>
<span class="sd">    be returned for `b` if `v` is a real number.</span>

<span class="sd">    &gt;&gt;&gt; from sympy.core.evalf import pure_complex</span>
<span class="sd">    &gt;&gt;&gt; from sympy import sqrt, I, S</span>
<span class="sd">    &gt;&gt;&gt; a, b, surd = S(2), S(3), sqrt(2)</span>
<span class="sd">    &gt;&gt;&gt; pure_complex(a)</span>
<span class="sd">    &gt;&gt;&gt; pure_complex(a, or_real=True)</span>
<span class="sd">    (2, 0)</span>
<span class="sd">    &gt;&gt;&gt; pure_complex(surd)</span>
<span class="sd">    &gt;&gt;&gt; pure_complex(a + b*I)</span>
<span class="sd">    (2, 3)</span>
<span class="sd">    &gt;&gt;&gt; pure_complex(I)</span>
<span class="sd">    (0, 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">or_real</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">t</span>
        <span class="k">return</span>
    <span class="n">c</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">c</span>


<span class="k">def</span> <span class="nf">scaled_zero</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an mpf representing a power of two with magnitude ``mag``</span>
<span class="sd">    and -1 for precision. Or, if ``mag`` is a scaled_zero tuple, then just</span>
<span class="sd">    remove the sign from within the list that it was initially wrapped</span>
<span class="sd">    in.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.core.evalf import scaled_zero</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Float</span>
<span class="sd">    &gt;&gt;&gt; z, p = scaled_zero(100)</span>
<span class="sd">    &gt;&gt;&gt; z, p</span>
<span class="sd">    (([0], 1, 100, 1), -1)</span>
<span class="sd">    &gt;&gt;&gt; ok = scaled_zero(z)</span>
<span class="sd">    &gt;&gt;&gt; ok</span>
<span class="sd">    (0, 1, 100, 1)</span>
<span class="sd">    &gt;&gt;&gt; Float(ok)</span>
<span class="sd">    1.26765060022823e+30</span>
<span class="sd">    &gt;&gt;&gt; Float(ok, p)</span>
<span class="sd">    0.e+30</span>
<span class="sd">    &gt;&gt;&gt; ok, p = scaled_zero(100, -1)</span>
<span class="sd">    &gt;&gt;&gt; Float(scaled_zero(ok), p)</span>
<span class="sd">    -0.e+30</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">iszero</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">scaled</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">mag</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">mag</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">SYMPY_INTS</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sign</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sign must be +/-1&#39;</span><span class="p">)</span>
        <span class="n">rv</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mpf_shift</span><span class="p">(</span><span class="n">fone</span><span class="p">,</span> <span class="n">mag</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">sign</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="p">([</span><span class="n">s</span><span class="p">],)</span> <span class="o">+</span> <span class="n">rv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">rv</span><span class="p">,</span> <span class="n">p</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;scaled zero expects int or scaled_zero tuple.&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">iszero</span><span class="p">(</span><span class="n">mpf</span><span class="p">,</span> <span class="n">scaled</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">scaled</span><span class="p">:</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">mpf</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mpf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mpf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">mpf</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">mpf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="n">mpf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">mpf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">complex_accuracy</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns relative accuracy of a complex number with given accuracies</span>
<span class="sd">    for the real and imaginary parts. The relative accuracy is defined</span>
<span class="sd">    in the complex norm sense as ||z|+|error|| / |z| where error</span>
<span class="sd">    is equal to (real absolute error) + (imag absolute error)*i.</span>

<span class="sd">    The full expression for the (logarithmic) error can be approximated</span>
<span class="sd">    easily by using the max norm to approximate the complex norm.</span>

<span class="sd">    In the worst case (re and im equal), this is wrong by a factor</span>
<span class="sd">    sqrt(2), or by log2(sqrt(2)) = 0.5 bit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">result</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">im</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">INF</span>
        <span class="k">return</span> <span class="n">re_acc</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">im_acc</span>
    <span class="n">re_size</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
    <span class="n">im_size</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">absolute_error</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">re_size</span> <span class="o">-</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_size</span> <span class="o">-</span> <span class="n">im_acc</span><span class="p">)</span>
    <span class="n">relative_error</span> <span class="o">=</span> <span class="n">absolute_error</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">re_size</span><span class="p">,</span> <span class="n">im_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">relative_error</span>


<span class="k">def</span> <span class="nf">get_abs</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">:</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span>
    <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="n">abs_expr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">N</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)),</span>
                                        <span class="n">prec</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">abs_expr</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;subs&#39;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">libmp</span><span class="o">.</span><span class="n">mpc_abs</span><span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">),</span> <span class="n">prec</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">re</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mpf_abs</span><span class="p">(</span><span class="n">re</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">get_complex_part</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;no = 0 for real part, no = 1 for imaginary part&quot;&quot;&quot;</span>
    <span class="n">workprec</span> <span class="o">=</span> <span class="n">prec</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">workprec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">value</span><span class="p">,</span> <span class="n">accuracy</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">no</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># XXX is the last one correct? Consider re((1+I)**2).n()</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">value</span><span class="p">)</span> <span class="ow">or</span> <span class="n">accuracy</span> <span class="o">&gt;=</span> <span class="n">prec</span> <span class="ow">or</span> <span class="o">-</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">prec</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">accuracy</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">workprec</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">evalf_abs</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_abs</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">evalf_re</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_complex_part</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">evalf_im</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_complex_part</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">finalize_complex</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">re</span> <span class="o">==</span> <span class="n">fzero</span> <span class="ow">and</span> <span class="n">im</span> <span class="o">==</span> <span class="n">fzero</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;got complex zero with unknown accuracy&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">re</span> <span class="o">==</span> <span class="n">fzero</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span>
    <span class="k">elif</span> <span class="n">im</span> <span class="o">==</span> <span class="n">fzero</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">size_re</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
    <span class="n">size_im</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size_re</span> <span class="o">&gt;</span> <span class="n">size_im</span><span class="p">:</span>
        <span class="n">re_acc</span> <span class="o">=</span> <span class="n">prec</span>
        <span class="n">im_acc</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">size_re</span> <span class="o">-</span> <span class="n">size_im</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">im_acc</span> <span class="o">=</span> <span class="n">prec</span>
        <span class="n">re_acc</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">size_im</span> <span class="o">-</span> <span class="n">size_re</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>


<span class="k">def</span> <span class="nf">chop_parts</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Chop off tiny real or complex parts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">value</span>
    <span class="c1"># Method 1: chop based on absolute value</span>
    <span class="k">if</span> <span class="n">re</span> <span class="ow">and</span> <span class="n">re</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_infs_nan</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">prec</span> <span class="o">+</span> <span class="mi">4</span><span class="p">):</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">im</span> <span class="ow">and</span> <span class="n">im</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_infs_nan</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fastlog</span><span class="p">(</span><span class="n">im</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">prec</span> <span class="o">+</span> <span class="mi">4</span><span class="p">):</span>
        <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="c1"># Method 2: chop if inaccurate and relatively small</span>
    <span class="k">if</span> <span class="n">re</span> <span class="ow">and</span> <span class="n">im</span><span class="p">:</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">)</span> <span class="o">-</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">re_acc</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">delta</span> <span class="o">-</span> <span class="n">re_acc</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">prec</span> <span class="o">+</span> <span class="mi">4</span><span class="p">):</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">im_acc</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">delta</span> <span class="o">-</span> <span class="n">im_acc</span> <span class="o">&gt;=</span> <span class="n">prec</span> <span class="o">-</span> <span class="mi">4</span><span class="p">):</span>
            <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>


<span class="k">def</span> <span class="nf">check_target</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">complex_accuracy</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">prec</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">PrecisionExhausted</span><span class="p">(</span><span class="s2">&quot;Failed to distinguish the expression: </span><span class="se">\n\n</span><span class="si">%s</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;from zero. Try simplifying the input, using chop=True, or providing &quot;</span>
            <span class="s2">&quot;a higher maxn for evalf&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">expr</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">get_integer_part</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">return_ints</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    With no = 1, computes ceiling(expr)</span>
<span class="sd">    With no = -1, computes floor(expr)</span>

<span class="sd">    Note: this function either gives the exact result or signals failure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="k">import</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span>
    <span class="c1"># The expression is likely less than 2^30 or so</span>
    <span class="n">assumed_size</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">ire</span><span class="p">,</span> <span class="n">iim</span><span class="p">,</span> <span class="n">ire_acc</span><span class="p">,</span> <span class="n">iim_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">assumed_size</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

    <span class="c1"># We now know the size, so we can calculate how much extra precision</span>
    <span class="c1"># (if any) is needed to get within the nearest integer</span>
    <span class="k">if</span> <span class="n">ire</span> <span class="ow">and</span> <span class="n">iim</span><span class="p">:</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fastlog</span><span class="p">(</span><span class="n">ire</span><span class="p">)</span> <span class="o">-</span> <span class="n">ire_acc</span><span class="p">,</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">iim</span><span class="p">)</span> <span class="o">-</span> <span class="n">iim_acc</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ire</span><span class="p">:</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">ire</span><span class="p">)</span> <span class="o">-</span> <span class="n">ire_acc</span>
    <span class="k">elif</span> <span class="n">iim</span><span class="p">:</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">iim</span><span class="p">)</span> <span class="o">-</span> <span class="n">iim_acc</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># ... or maybe the expression was exactly zero</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">margin</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="k">if</span> <span class="n">gap</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">margin</span><span class="p">:</span>
        <span class="n">prec</span> <span class="o">=</span> <span class="n">margin</span> <span class="o">+</span> <span class="n">assumed_size</span> <span class="o">+</span> <span class="n">gap</span>
        <span class="n">ire</span><span class="p">,</span> <span class="n">iim</span><span class="p">,</span> <span class="n">ire_acc</span><span class="p">,</span> <span class="n">iim_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prec</span> <span class="o">=</span> <span class="n">assumed_size</span>

    <span class="c1"># We can now easily find the nearest integer, but to find floor/ceil, we</span>
    <span class="c1"># must also calculate whether the difference to the nearest integer is</span>
    <span class="c1"># positive or negative (which may fail if very close).</span>
    <span class="k">def</span> <span class="nf">calc_part</span><span class="p">(</span><span class="n">re_im</span><span class="p">,</span> <span class="n">nexpr</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.core.add</span> <span class="k">import</span> <span class="n">Add</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">nexpr</span>
        <span class="n">is_int</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">nint</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">to_int</span><span class="p">(</span><span class="n">nexpr</span><span class="p">,</span> <span class="n">rnd</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">is_int</span><span class="p">:</span>
            <span class="c1"># make sure that we had enough precision to distinguish</span>
            <span class="c1"># between nint and the re or im part (re_im) of expr that</span>
            <span class="c1"># was passed to calc_part</span>
            <span class="n">ire</span><span class="p">,</span> <span class="n">iim</span><span class="p">,</span> <span class="n">ire_acc</span><span class="p">,</span> <span class="n">iim_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span>
                <span class="n">re_im</span> <span class="o">-</span> <span class="n">nint</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>  <span class="c1"># don&#39;t need much precision</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">iim</span>
            <span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="n">fastlog</span><span class="p">(</span><span class="n">ire</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1"># -ve b/c ire is less than 1</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">prec</span><span class="p">:</span>
                <span class="n">ire</span><span class="p">,</span> <span class="n">iim</span><span class="p">,</span> <span class="n">ire_acc</span><span class="p">,</span> <span class="n">iim_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span>
                    <span class="n">re_im</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">iim</span>
                <span class="n">nexpr</span> <span class="o">=</span> <span class="n">ire</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">nexpr</span>
                <span class="n">is_int</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">nint</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">to_int</span><span class="p">(</span><span class="n">nexpr</span><span class="p">,</span> <span class="n">rnd</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_int</span><span class="p">:</span>
            <span class="c1"># if there are subs and they all contain integer re/im parts</span>
            <span class="c1"># then we can (hopefully) safely substitute them into the</span>
            <span class="c1"># expression</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;subs&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">doit</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="k">import</span> <span class="n">as_int</span>
                <span class="c1"># use strict=False with as_int because we take</span>
                <span class="c1"># 2.0 == 2</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">as_int</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="p">[</span><span class="n">as_int</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()]</span>
                            <span class="k">continue</span>
                        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                            <span class="n">doit</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="n">doit</span><span class="p">:</span>
                    <span class="n">re_im</span> <span class="o">=</span> <span class="n">re_im</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

            <span class="n">re_im</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">re_im</span><span class="p">,</span> <span class="o">-</span><span class="n">nint</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">x_acc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">re_im</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">check_target</span><span class="p">(</span><span class="n">re_im</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">x_acc</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">PrecisionExhausted</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">re_im</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">PrecisionExhausted</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">fzero</span>
            <span class="n">nint</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">no</span><span class="o">*</span><span class="p">(</span><span class="n">mpf_cmp</span><span class="p">(</span><span class="n">x</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">fzero</span><span class="p">)</span> <span class="o">==</span> <span class="n">no</span><span class="p">))</span>
        <span class="n">nint</span> <span class="o">=</span> <span class="n">from_int</span><span class="p">(</span><span class="n">nint</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nint</span><span class="p">,</span> <span class="n">INF</span>

    <span class="n">re_</span><span class="p">,</span> <span class="n">im_</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">ire</span><span class="p">:</span>
        <span class="n">re_</span><span class="p">,</span> <span class="n">re_acc</span> <span class="o">=</span> <span class="n">calc_part</span><span class="p">(</span><span class="n">re</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">ire</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iim</span><span class="p">:</span>
        <span class="n">im_</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">calc_part</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">iim</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_ints</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">to_int</span><span class="p">(</span><span class="n">re_</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">to_int</span><span class="p">(</span><span class="n">im_</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">re_</span><span class="p">,</span> <span class="n">im_</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>


<span class="k">def</span> <span class="nf">evalf_ceiling</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_integer_part</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">evalf_floor</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_integer_part</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

<span class="c1">#----------------------------------------------------------------------------#</span>
<span class="c1">#                                                                            #</span>
<span class="c1">#                            Arithmetic operations                           #</span>
<span class="c1">#                                                                            #</span>
<span class="c1">#----------------------------------------------------------------------------#</span>


<span class="k">def</span> <span class="nf">add_terms</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper for evalf_add. Adds a list of (mpfval, accuracy) terms.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    - None, None if there are no non-zero terms;</span>
<span class="sd">    - terms[0] if there is only 1 term;</span>
<span class="sd">    - scaled_zero if the sum of the terms produces a zero by cancellation</span>
<span class="sd">      e.g. mpfs representing 1 and -1 would produce a scaled zero which need</span>
<span class="sd">      special handling since they are not actually zero and they are purposely</span>
<span class="sd">      malformed to ensure that they can&#39;t be used in anything but accuracy</span>
<span class="sd">      calculations;</span>
<span class="sd">    - a tuple that is scaled to target_prec that corresponds to the</span>
<span class="sd">      sum of the terms.</span>

<span class="sd">    The returned mpf tuple will be normalized to target_prec; the input</span>
<span class="sd">    prec is used to define the working precision.</span>

<span class="sd">    XXX explain why this is needed and why one can&#39;t just loop using mpf_add</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terms</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">iszero</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">terms</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># see if any argument is NaN or oo and thus warrants a special return</span>
    <span class="n">special</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="k">import</span> <span class="n">Float</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span> <span class="ow">or</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_infinite</span><span class="p">:</span>
            <span class="n">special</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">special</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">sympy.core.add</span> <span class="k">import</span> <span class="n">Add</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">special</span><span class="p">),</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">return</span> <span class="n">rv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">working_prec</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">prec</span>
    <span class="n">sum_man</span><span class="p">,</span> <span class="n">sum_exp</span><span class="p">,</span> <span class="n">absolute_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MINUS_INF</span>

    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">accuracy</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
        <span class="n">sign</span><span class="p">,</span> <span class="n">man</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">bc</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">sign</span><span class="p">:</span>
            <span class="n">man</span> <span class="o">=</span> <span class="o">-</span><span class="n">man</span>
        <span class="n">absolute_error</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">absolute_error</span><span class="p">,</span> <span class="n">bc</span> <span class="o">+</span> <span class="n">exp</span> <span class="o">-</span> <span class="n">accuracy</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">exp</span> <span class="o">-</span> <span class="n">sum_exp</span>
        <span class="k">if</span> <span class="n">exp</span> <span class="o">&gt;=</span> <span class="n">sum_exp</span><span class="p">:</span>
            <span class="c1"># x much larger than existing sum?</span>
            <span class="c1"># first: quick test</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">working_prec</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">((</span><span class="ow">not</span> <span class="n">sum_man</span><span class="p">)</span> <span class="ow">or</span>
                 <span class="n">delta</span> <span class="o">-</span> <span class="n">bitcount</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">sum_man</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">working_prec</span><span class="p">)):</span>
                <span class="n">sum_man</span> <span class="o">=</span> <span class="n">man</span>
                <span class="n">sum_exp</span> <span class="o">=</span> <span class="n">exp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sum_man</span> <span class="o">+=</span> <span class="p">(</span><span class="n">man</span> <span class="o">&lt;&lt;</span> <span class="n">delta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span>
            <span class="c1"># x much smaller than existing sum?</span>
            <span class="k">if</span> <span class="n">delta</span> <span class="o">-</span> <span class="n">bc</span> <span class="o">&gt;</span> <span class="n">working_prec</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">sum_man</span><span class="p">:</span>
                    <span class="n">sum_man</span><span class="p">,</span> <span class="n">sum_exp</span> <span class="o">=</span> <span class="n">man</span><span class="p">,</span> <span class="n">exp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sum_man</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum_man</span> <span class="o">&lt;&lt;</span> <span class="n">delta</span><span class="p">)</span> <span class="o">+</span> <span class="n">man</span>
                <span class="n">sum_exp</span> <span class="o">=</span> <span class="n">exp</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sum_man</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scaled_zero</span><span class="p">(</span><span class="n">absolute_error</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sum_man</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sum_sign</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">sum_man</span> <span class="o">=</span> <span class="o">-</span><span class="n">sum_man</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sum_sign</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sum_bc</span> <span class="o">=</span> <span class="n">bitcount</span><span class="p">(</span><span class="n">sum_man</span><span class="p">)</span>
    <span class="n">sum_accuracy</span> <span class="o">=</span> <span class="n">sum_exp</span> <span class="o">+</span> <span class="n">sum_bc</span> <span class="o">-</span> <span class="n">absolute_error</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">sum_sign</span><span class="p">,</span> <span class="n">sum_man</span><span class="p">,</span> <span class="n">sum_exp</span><span class="p">,</span> <span class="n">sum_bc</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">,</span>
        <span class="n">rnd</span><span class="p">),</span> <span class="n">sum_accuracy</span>
    <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">evalf_add</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pure_complex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">res</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">im</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">im_acc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>

    <span class="n">oldmaxprec</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxprec&#39;</span><span class="p">,</span> <span class="n">DEFAULT_MAXPREC</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">target_prec</span> <span class="o">=</span> <span class="n">prec</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">options</span><span class="p">[</span><span class="s1">&#39;maxprec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">oldmaxprec</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">prec</span><span class="p">)</span>

        <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span> <span class="o">=</span> <span class="n">add_terms</span><span class="p">(</span>
            <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">terms</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">prec</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
        <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">add_terms</span><span class="p">(</span>
            <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">terms</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">prec</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">complex_accuracy</span><span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">acc</span> <span class="o">&gt;=</span> <span class="n">target_prec</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;verbose&#39;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ADD: wanted&quot;</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">,</span> <span class="s2">&quot;accurate bits, got&quot;</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prec</span> <span class="o">-</span> <span class="n">target_prec</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;maxprec&#39;</span><span class="p">]:</span>
                <span class="k">break</span>

            <span class="n">prec</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">,</span> <span class="n">target_prec</span> <span class="o">-</span> <span class="n">acc</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;verbose&#39;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ADD: restarting with prec&quot;</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>

    <span class="n">options</span><span class="p">[</span><span class="s1">&#39;maxprec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldmaxprec</span>
    <span class="k">if</span> <span class="n">iszero</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">scaled</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">re</span> <span class="o">=</span> <span class="n">scaled_zero</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iszero</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">scaled</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">scaled_zero</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>


<span class="k">def</span> <span class="nf">evalf_mul</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pure_complex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
        <span class="c1"># the only pure complex that is a mul is h*I</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">res</span>
        <span class="n">im</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">im_acc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">im_acc</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># see if any argument is NaN or oo and thus warrants a special return</span>
    <span class="n">special</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="k">import</span> <span class="n">Float</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span> <span class="ow">or</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_infinite</span><span class="p">:</span>
            <span class="n">special</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">special</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">sympy.core.mul</span> <span class="k">import</span> <span class="n">Mul</span>
        <span class="n">special</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">special</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">evalf</span><span class="p">(</span><span class="n">special</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="p">{})</span>

    <span class="c1"># With guard digits, multiplication in the real case does not destroy</span>
    <span class="c1"># accuracy. This is also true in the complex case when considering the</span>
    <span class="c1"># total accuracy; however accuracy for the real or imaginary parts</span>
    <span class="c1"># separately may be lower.</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="n">prec</span>

    <span class="c1"># XXX: big overestimate</span>
    <span class="n">working_prec</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span>

    <span class="c1"># Empty product is 1</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">man</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">bc</span> <span class="o">=</span> <span class="n">MPZ</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>

    <span class="c1"># First, we multiply all pure real or pure imaginary numbers.</span>
    <span class="c1"># direction tells us that the result should be multiplied by</span>
    <span class="c1"># I**direction; all other numbers get put into complex_factors</span>
    <span class="c1"># to be multiplied out after the first phase.</span>
    <span class="n">last</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">)</span>
    <span class="n">complex_factors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span> <span class="ow">and</span> <span class="n">pure_complex</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">last</span> <span class="ow">and</span> <span class="n">arg</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">working_prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">re</span> <span class="ow">and</span> <span class="n">im</span><span class="p">:</span>
            <span class="n">complex_factors</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">re</span><span class="p">:</span>
            <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w_acc</span> <span class="o">=</span> <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span>
        <span class="k">elif</span> <span class="n">im</span><span class="p">:</span>
            <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w_acc</span> <span class="o">=</span> <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span>
            <span class="n">direction</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">direction</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span>
        <span class="n">man</span> <span class="o">*=</span> <span class="n">m</span>
        <span class="n">exp</span> <span class="o">+=</span> <span class="n">e</span>
        <span class="n">bc</span> <span class="o">+=</span> <span class="n">b</span>
        <span class="k">if</span> <span class="n">bc</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">*</span><span class="n">working_prec</span><span class="p">:</span>
            <span class="n">man</span> <span class="o">&gt;&gt;=</span> <span class="n">working_prec</span>
            <span class="n">exp</span> <span class="o">+=</span> <span class="n">working_prec</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">w_acc</span><span class="p">)</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="n">direction</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">complex_factors</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">sign</span><span class="p">,</span> <span class="n">man</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">bitcount</span><span class="p">(</span><span class="n">man</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rnd</span><span class="p">)</span>
        <span class="c1"># multiply by i</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">acc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># initialize with the first term</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">man</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">start</span><span class="p">:</span>
            <span class="c1"># there was a real part; give it an imaginary part</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign</span><span class="p">,</span> <span class="n">man</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">bitcount</span><span class="p">(</span><span class="n">man</span><span class="p">)),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MPZ</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># there is no real part to start (other than the starting 1)</span>
            <span class="n">wre</span><span class="p">,</span> <span class="n">wim</span><span class="p">,</span> <span class="n">wre_acc</span><span class="p">,</span> <span class="n">wim_acc</span> <span class="o">=</span> <span class="n">complex_factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span>
                      <span class="n">complex_accuracy</span><span class="p">((</span><span class="n">wre</span><span class="p">,</span> <span class="n">wim</span><span class="p">,</span> <span class="n">wre_acc</span><span class="p">,</span> <span class="n">wim_acc</span><span class="p">)))</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">wre</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">wim</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">wre</span><span class="p">,</span> <span class="n">wim</span><span class="p">,</span> <span class="n">wre_acc</span><span class="p">,</span> <span class="n">wim_acc</span> <span class="ow">in</span> <span class="n">complex_factors</span><span class="p">[</span><span class="n">i0</span><span class="p">:]:</span>
            <span class="c1"># acc is the overall accuracy of the product; we aren&#39;t</span>
            <span class="c1"># computing exact accuracies of the product.</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span>
                      <span class="n">complex_accuracy</span><span class="p">((</span><span class="n">wre</span><span class="p">,</span> <span class="n">wim</span><span class="p">,</span> <span class="n">wre_acc</span><span class="p">,</span> <span class="n">wim_acc</span><span class="p">)))</span>

            <span class="n">use_prec</span> <span class="o">=</span> <span class="n">working_prec</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">mpf_mul</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">wre</span><span class="p">,</span> <span class="n">use_prec</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">mpf_mul</span><span class="p">(</span><span class="n">mpf_neg</span><span class="p">(</span><span class="n">im</span><span class="p">),</span> <span class="n">wim</span><span class="p">,</span> <span class="n">use_prec</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">mpf_mul</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">wim</span><span class="p">,</span> <span class="n">use_prec</span><span class="p">)</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">mpf_mul</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">wre</span><span class="p">,</span> <span class="n">use_prec</span><span class="p">)</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">mpf_add</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">use_prec</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">mpf_add</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">use_prec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;verbose&#39;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;MUL: wanted&quot;</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="s2">&quot;accurate bits, got&quot;</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
        <span class="c1"># multiply by I</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">mpf_neg</span><span class="p">(</span><span class="n">im</span><span class="p">),</span> <span class="n">re</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">acc</span>


<span class="k">def</span> <span class="nf">evalf_pow</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>

    <span class="n">target_prec</span> <span class="o">=</span> <span class="n">prec</span>
    <span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">args</span>

    <span class="c1"># We handle x**n separately. This has two purposes: 1) it is much</span>
    <span class="c1"># faster, because we avoid calling evalf on the exponent, and 2) it</span>
    <span class="c1"># allows better handling of real/imaginary parts that are exactly zero</span>
    <span class="k">if</span> <span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">p</span>
        <span class="c1"># Exact</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fone</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span>
        <span class="c1"># Exponentiation by p magnifies relative error by |p|, so the</span>
        <span class="c1"># base must be evaluated with increased precision if p is large</span>
        <span class="n">prec</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="c1"># Real to integer power</span>
        <span class="k">if</span> <span class="n">re</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">im</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mpf_pow_int</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">,</span> <span class="kc">None</span>
        <span class="c1"># (x*I)**n = I**n * x**n</span>
        <span class="k">if</span> <span class="n">im</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">re</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">mpf_pow_int</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
            <span class="n">case</span> <span class="o">=</span> <span class="n">p</span> <span class="o">%</span> <span class="mi">4</span>
            <span class="k">if</span> <span class="n">case</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">case</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">target_prec</span>
            <span class="k">if</span> <span class="n">case</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mpf_neg</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">case</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mpf_neg</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">target_prec</span>
        <span class="c1"># Zero raised to an integer power</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="c1"># General complex number to arbitrary integer power</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">libmp</span><span class="o">.</span><span class="n">mpc_pow_int</span><span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="c1"># Assumes full accuracy in input</span>
        <span class="k">return</span> <span class="n">finalize_complex</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>

    <span class="c1"># Pure square root</span>
    <span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Half</span><span class="p">:</span>
        <span class="n">xre</span><span class="p">,</span> <span class="n">xim</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="c1"># General complex square root</span>
        <span class="k">if</span> <span class="n">xim</span><span class="p">:</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">libmp</span><span class="o">.</span><span class="n">mpc_sqrt</span><span class="p">((</span><span class="n">xre</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">xim</span><span class="p">),</span> <span class="n">prec</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">finalize_complex</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xre</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="c1"># Square root of a negative real number</span>
        <span class="k">if</span> <span class="n">mpf_lt</span><span class="p">(</span><span class="n">xre</span><span class="p">,</span> <span class="n">fzero</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mpf_sqrt</span><span class="p">(</span><span class="n">mpf_neg</span><span class="p">(</span><span class="n">xre</span><span class="p">),</span> <span class="n">prec</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span>
        <span class="c1"># Positive square root</span>
        <span class="k">return</span> <span class="n">mpf_sqrt</span><span class="p">(</span><span class="n">xre</span><span class="p">,</span> <span class="n">prec</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1"># We first evaluate the exponent to find its magnitude</span>
    <span class="c1"># This determines the working precision that must be used</span>
    <span class="n">prec</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="n">yre</span><span class="p">,</span> <span class="n">yim</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="c1"># Special cases: x**0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">yre</span> <span class="ow">or</span> <span class="n">yim</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fone</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">ysize</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">yre</span><span class="p">)</span>
    <span class="c1"># Restart if too big</span>
    <span class="c1"># XXX: prec + ysize might exceed maxprec</span>
    <span class="k">if</span> <span class="n">ysize</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">prec</span> <span class="o">+=</span> <span class="n">ysize</span>
        <span class="n">yre</span><span class="p">,</span> <span class="n">yim</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

    <span class="c1"># Pure exponential function; no need to evalf the base</span>
    <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Exp1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">yim</span><span class="p">:</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">libmp</span><span class="o">.</span><span class="n">mpc_exp</span><span class="p">((</span><span class="n">yre</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">yim</span><span class="p">),</span> <span class="n">prec</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">finalize_complex</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mpf_exp</span><span class="p">(</span><span class="n">yre</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">xre</span><span class="p">,</span> <span class="n">xim</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="c1"># 0**y</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">xre</span> <span class="ow">or</span> <span class="n">xim</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1"># (real ** complex) or (complex ** complex)</span>
    <span class="k">if</span> <span class="n">yim</span><span class="p">:</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">libmp</span><span class="o">.</span><span class="n">mpc_pow</span><span class="p">(</span>
            <span class="p">(</span><span class="n">xre</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">xim</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">),</span> <span class="p">(</span><span class="n">yre</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">yim</span><span class="p">),</span>
            <span class="n">target_prec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">finalize_complex</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
    <span class="c1"># complex ** real</span>
    <span class="k">if</span> <span class="n">xim</span><span class="p">:</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">libmp</span><span class="o">.</span><span class="n">mpc_pow_mpf</span><span class="p">((</span><span class="n">xre</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">xim</span><span class="p">),</span> <span class="n">yre</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">finalize_complex</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
    <span class="c1"># negative ** real</span>
    <span class="k">elif</span> <span class="n">mpf_lt</span><span class="p">(</span><span class="n">xre</span><span class="p">,</span> <span class="n">fzero</span><span class="p">):</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">libmp</span><span class="o">.</span><span class="n">mpc_pow_mpf</span><span class="p">((</span><span class="n">xre</span><span class="p">,</span> <span class="n">fzero</span><span class="p">),</span> <span class="n">yre</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">finalize_complex</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
    <span class="c1"># positive ** real</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mpf_pow</span><span class="p">(</span><span class="n">xre</span><span class="p">,</span> <span class="n">yre</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">,</span> <span class="kc">None</span>


<span class="c1">#----------------------------------------------------------------------------#</span>
<span class="c1">#                                                                            #</span>
<span class="c1">#                            Special functions                               #</span>
<span class="c1">#                                                                            #</span>
<span class="c1">#----------------------------------------------------------------------------#</span>
<span class="k">def</span> <span class="nf">evalf_trig</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function handles sin and cos of complex arguments.</span>

<span class="sd">    TODO: should also handle tan of complex arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">cos</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">mpf_cos</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sin</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">mpf_sin</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># 20 extra bits is possibly overkill. It does make the need</span>
    <span class="c1"># to restart very unlikely</span>
    <span class="n">xprec</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">20</span>
    <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">xprec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;subs&#39;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;subs&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">evalf</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">cos</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fone</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sin</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="c1"># For trigonometric functions, we are interested in the</span>
    <span class="c1"># fixed-point (absolute) accuracy of the argument.</span>
    <span class="n">xsize</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
    <span class="c1"># Magnitude &lt;= 1.0. OK to compute directly, because there is no</span>
    <span class="c1"># danger of hitting the first root of cos (with sin, magnitude</span>
    <span class="c1"># &lt;= 2.0 would actually be ok)</span>
    <span class="k">if</span> <span class="n">xsize</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rnd</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span>
    <span class="c1"># Very large</span>
    <span class="k">if</span> <span class="n">xsize</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">xprec</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="n">xsize</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">xprec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="c1"># Need to repeat in case the argument is very close to a</span>
    <span class="c1"># multiple of pi (or pi/2), hitting close to a root</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rnd</span><span class="p">)</span>
        <span class="n">ysize</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="o">-</span><span class="n">ysize</span>
        <span class="n">accuracy</span> <span class="o">=</span> <span class="p">(</span><span class="n">xprec</span> <span class="o">-</span> <span class="n">xsize</span><span class="p">)</span> <span class="o">-</span> <span class="n">gap</span>
        <span class="k">if</span> <span class="n">accuracy</span> <span class="o">&lt;</span> <span class="n">prec</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;verbose&#39;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SIN/COS&quot;</span><span class="p">,</span> <span class="n">accuracy</span><span class="p">,</span> <span class="s2">&quot;wanted&quot;</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="s2">&quot;gap&quot;</span><span class="p">,</span> <span class="n">gap</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">to_str</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">xprec</span> <span class="o">&gt;</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxprec&#39;</span><span class="p">,</span> <span class="n">DEFAULT_MAXPREC</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">accuracy</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">xprec</span> <span class="o">+=</span> <span class="n">gap</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">xprec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">evalf_log</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Abs</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">log</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">evalf</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">workprec</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="n">xre</span><span class="p">,</span> <span class="n">xim</span><span class="p">,</span> <span class="n">xacc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">workprec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">xim</span><span class="p">:</span>
        <span class="c1"># XXX: use get_abs etc instead</span>
        <span class="n">re</span> <span class="o">=</span> <span class="n">evalf_log</span><span class="p">(</span>
            <span class="n">log</span><span class="p">(</span><span class="n">Abs</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">mpf_atan2</span><span class="p">(</span><span class="n">xim</span><span class="p">,</span> <span class="n">xre</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">im</span><span class="p">,</span> <span class="n">re</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">prec</span>

    <span class="n">imaginary_term</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpf_cmp</span><span class="p">(</span><span class="n">xre</span><span class="p">,</span> <span class="n">fzero</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">re</span> <span class="o">=</span> <span class="n">mpf_log</span><span class="p">(</span><span class="n">mpf_abs</span><span class="p">(</span><span class="n">xre</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rnd</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">prec</span> <span class="o">-</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">workprec</span> <span class="ow">and</span> <span class="n">re</span> <span class="o">!=</span> <span class="n">fzero</span><span class="p">:</span>
        <span class="c1"># We actually need to compute 1+x accurately, not x</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">xre</span><span class="p">,</span> <span class="n">xim</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf_add</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">prec2</span> <span class="o">=</span> <span class="n">workprec</span> <span class="o">-</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">xre</span><span class="p">)</span>
        <span class="c1"># xre is now x - 1 so we add 1 back here to calculate x</span>
        <span class="n">re</span> <span class="o">=</span> <span class="n">mpf_log</span><span class="p">(</span><span class="n">mpf_abs</span><span class="p">(</span><span class="n">mpf_add</span><span class="p">(</span><span class="n">xre</span><span class="p">,</span> <span class="n">fone</span><span class="p">,</span> <span class="n">prec2</span><span class="p">)),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rnd</span><span class="p">)</span>

    <span class="n">re_acc</span> <span class="o">=</span> <span class="n">prec</span>

    <span class="k">if</span> <span class="n">imaginary_term</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">mpf_pi</span><span class="p">(</span><span class="n">prec</span><span class="p">),</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">prec</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">evalf_atan</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">xre</span><span class="p">,</span> <span class="n">xim</span><span class="p">,</span> <span class="n">reacc</span><span class="p">,</span> <span class="n">imacc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xre</span> <span class="ow">is</span> <span class="n">xim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="mi">4</span>
    <span class="k">if</span> <span class="n">xim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">return</span> <span class="n">mpf_atan</span><span class="p">(</span><span class="n">xre</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rnd</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">evalf_subs</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">subs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Change all Float entries in `subs` to have precision prec. &quot;&quot;&quot;</span>
    <span class="n">newsubs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">subs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
        <span class="n">newsubs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">newsubs</span>


<span class="k">def</span> <span class="nf">evalf_piecewise</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Float</span><span class="p">,</span> <span class="n">Integer</span>
    <span class="k">if</span> <span class="s1">&#39;subs&#39;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">evalf_subs</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;subs&#39;</span><span class="p">]))</span>
        <span class="n">newopts</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">newopts</span><span class="p">[</span><span class="s1">&#39;subs&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;func&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">evalf</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">newopts</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">evalf</span><span class="p">(</span><span class="n">Float</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">newopts</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">evalf</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">newopts</span><span class="p">)</span>

    <span class="c1"># We still have undefined symbols</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>


<span class="k">def</span> <span class="nf">evalf_bernoulli</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bernoulli number index must be an integer&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">mpf_bernoulli</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rnd</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">fzero</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span>

<span class="c1">#----------------------------------------------------------------------------#</span>
<span class="c1">#                                                                            #</span>
<span class="c1">#                            High-level operations                           #</span>
<span class="c1">#                                                                            #</span>
<span class="c1">#----------------------------------------------------------------------------#</span>


<span class="k">def</span> <span class="nf">as_mpmath</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="k">import</span> <span class="n">Infinity</span><span class="p">,</span> <span class="n">NegativeInfinity</span><span class="p">,</span> <span class="n">Zero</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mpf</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Infinity</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mpf</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NegativeInfinity</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mpf</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>
    <span class="c1"># XXX</span>
    <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mpc</span><span class="p">(</span><span class="n">re</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">im</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mpf</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">do_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">xlow</span><span class="p">,</span> <span class="n">xhigh</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">xlow</span> <span class="o">==</span> <span class="n">xhigh</span><span class="p">:</span>
        <span class="n">xlow</span> <span class="o">=</span> <span class="n">xhigh</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
        <span class="c1"># only the difference in limits matters in this case</span>
        <span class="c1"># so if there is a symbol in common that will cancel</span>
        <span class="c1"># out when taking the difference, then use that</span>
        <span class="c1"># difference</span>
        <span class="k">if</span> <span class="n">xhigh</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">xlow</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">xhigh</span> <span class="o">-</span> <span class="n">xlow</span>
            <span class="k">if</span> <span class="n">diff</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                <span class="n">xlow</span><span class="p">,</span> <span class="n">xhigh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">diff</span>

    <span class="n">oldmaxprec</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxprec&#39;</span><span class="p">,</span> <span class="n">DEFAULT_MAXPREC</span><span class="p">)</span>
    <span class="n">options</span><span class="p">[</span><span class="s1">&#39;maxprec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">oldmaxprec</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">prec</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">workprec</span><span class="p">(</span><span class="n">prec</span> <span class="o">+</span> <span class="mi">5</span><span class="p">):</span>
        <span class="n">xlow</span> <span class="o">=</span> <span class="n">as_mpmath</span><span class="p">(</span><span class="n">xlow</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">xhigh</span> <span class="o">=</span> <span class="n">as_mpmath</span><span class="p">(</span><span class="n">xhigh</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

        <span class="c1"># Integration is like summation, and we can phone home from</span>
        <span class="c1"># the integrand function to update accuracy summation style</span>
        <span class="c1"># Note that this accuracy is inaccurate, since it fails</span>
        <span class="c1"># to account for the variable quadrature weights,</span>
        <span class="c1"># but it is better than nothing</span>

        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">Wild</span>

        <span class="n">have_part</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
        <span class="n">max_real_term</span> <span class="o">=</span> <span class="p">[</span><span class="n">MINUS_INF</span><span class="p">]</span>
        <span class="n">max_imag_term</span> <span class="o">=</span> <span class="p">[</span><span class="n">MINUS_INF</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">prec</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;subs&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">t</span><span class="p">}})</span>

            <span class="n">have_part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">re</span> <span class="ow">or</span> <span class="n">have_part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">have_part</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span> <span class="ow">or</span> <span class="n">have_part</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">max_real_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_real_term</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">))</span>
            <span class="n">max_imag_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_imag_term</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mpc</span><span class="p">(</span><span class="n">re</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">im</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mpf</span><span class="p">(</span><span class="n">re</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;quad&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;osc&#39;</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">D</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">D</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;An integrand of the form sin(A*x+B)*f(x) &quot;</span>
                  <span class="s2">&quot;or cos(A*x+B)*f(x) is required for oscillatory quadrature&quot;</span><span class="p">)</span>
            <span class="n">period</span> <span class="o">=</span> <span class="n">as_mpmath</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="o">/</span><span class="n">m</span><span class="p">[</span><span class="n">A</span><span class="p">],</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">quadosc</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">xlow</span><span class="p">,</span> <span class="n">xhigh</span><span class="p">],</span> <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>
            <span class="c1"># XXX: quadosc does not do error detection yet</span>
            <span class="n">quadrature_error</span> <span class="o">=</span> <span class="n">MINUS_INF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="p">,</span> <span class="n">quadrature_error</span> <span class="o">=</span> <span class="n">quadts</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">xlow</span><span class="p">,</span> <span class="n">xhigh</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">quadrature_error</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">quadrature_error</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">)</span>

    <span class="n">options</span><span class="p">[</span><span class="s1">&#39;maxprec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldmaxprec</span>

    <span class="k">if</span> <span class="n">have_part</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">re</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">_mpf_</span>
        <span class="k">if</span> <span class="n">re</span> <span class="o">==</span> <span class="n">fzero</span><span class="p">:</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span> <span class="o">=</span> <span class="n">scaled_zero</span><span class="p">(</span>
                <span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="n">prec</span><span class="p">,</span> <span class="o">-</span><span class="n">max_real_term</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">quadrature_error</span><span class="p">))</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">scaled_zero</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>  <span class="c1"># handled ok in evalf_integral</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">re_acc</span> <span class="o">=</span> <span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">max_real_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">)</span> <span class="o">-</span>
                          <span class="n">prec</span><span class="p">,</span> <span class="n">quadrature_error</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">have_part</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">_mpf_</span>
        <span class="k">if</span> <span class="n">im</span> <span class="o">==</span> <span class="n">fzero</span><span class="p">:</span>
            <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">scaled_zero</span><span class="p">(</span>
                <span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="n">prec</span><span class="p">,</span> <span class="o">-</span><span class="n">max_imag_term</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">quadrature_error</span><span class="p">))</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">scaled_zero</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>  <span class="c1"># handled ok in evalf_integral</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">im_acc</span> <span class="o">=</span> <span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">max_imag_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">im</span><span class="p">)</span> <span class="o">-</span>
                          <span class="n">prec</span><span class="p">,</span> <span class="n">quadrature_error</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">evalf_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">limits</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">limits</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="n">workprec</span> <span class="o">=</span> <span class="n">prec</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">maxprec</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxprec&#39;</span><span class="p">,</span> <span class="n">INF</span><span class="p">)</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">do_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">workprec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">accuracy</span> <span class="o">=</span> <span class="n">complex_accuracy</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">accuracy</span> <span class="o">&gt;=</span> <span class="n">prec</span><span class="p">:</span>  <span class="c1"># achieved desired precision</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">workprec</span> <span class="o">&gt;=</span> <span class="n">maxprec</span><span class="p">:</span>  <span class="c1"># can&#39;t increase accuracy any more</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">accuracy</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># maybe the answer really is zero and maybe we just haven&#39;t increased</span>
            <span class="c1"># the precision enough. So increase by doubling to not take too long</span>
            <span class="c1"># to get to maxprec.</span>
            <span class="n">workprec</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">workprec</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)</span>
        <span class="n">workprec</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">workprec</span><span class="p">,</span> <span class="n">maxprec</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">check_convergence</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns (h, g, p) where</span>
<span class="sd">    -- h is:</span>
<span class="sd">        &gt; 0 for convergence of rate 1/factorial(n)**h</span>
<span class="sd">        &lt; 0 for divergence of rate factorial(n)**(-h)</span>
<span class="sd">        = 0 for geometric or polynomial convergence or divergence</span>

<span class="sd">    -- abs(g) is:</span>
<span class="sd">        &gt; 1 for geometric convergence of rate 1/h**n</span>
<span class="sd">        &lt; 1 for geometric divergence of rate h**n</span>
<span class="sd">        = 1 for polynomial convergence or divergence</span>

<span class="sd">        (g &lt; 0 indicates an alternating series)</span>

<span class="sd">    -- p is:</span>
<span class="sd">        &gt; 1 for polynomial convergence of rate 1/n**h</span>
<span class="sd">        &lt;= 1 for polynomial divergence of rate n**(-h)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Poly</span>
    <span class="n">npol</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">dpol</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">npol</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">dpol</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-</span> <span class="n">p</span>
    <span class="k">if</span> <span class="n">rate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rate</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">constant</span> <span class="o">=</span> <span class="n">dpol</span><span class="o">.</span><span class="n">LC</span><span class="p">()</span> <span class="o">/</span> <span class="n">npol</span><span class="o">.</span><span class="n">LC</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rate</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">npol</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="n">dpol</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rate</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="mi">0</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="n">npol</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">qc</span> <span class="o">=</span> <span class="n">dpol</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">rate</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="p">(</span><span class="n">qc</span> <span class="o">-</span> <span class="n">pc</span><span class="p">)</span><span class="o">/</span><span class="n">dpol</span><span class="o">.</span><span class="n">LC</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">hypsum</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum a rapidly convergent infinite hypergeometric series with</span>
<span class="sd">    given general term, e.g. e = hypsum(1/factorial(n), n). The</span>
<span class="sd">    quotient between successive terms must be a quotient of integer</span>
<span class="sd">    polynomials.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Float</span><span class="p">,</span> <span class="n">hypersimp</span><span class="p">,</span> <span class="n">lambdify</span>

    <span class="k">if</span> <span class="n">prec</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;does not support inf prec&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">start</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
    <span class="n">hs</span> <span class="o">=</span> <span class="n">hypersimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;a hypergeometric series is required&quot;</span><span class="p">)</span>
    <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>

    <span class="n">func1</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
    <span class="n">func2</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">den</span><span class="p">)</span>

    <span class="n">h</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">check_convergence</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sum diverges like (n!)^</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="n">h</span><span class="p">))</span>

    <span class="n">term</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Non rational term functionality is not implemented.&quot;</span><span class="p">)</span>

    <span class="c1"># Direct summation if geometric or faster</span>
    <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">h</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">term</span> <span class="o">=</span> <span class="p">(</span><span class="n">MPZ</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">prec</span><span class="p">)</span> <span class="o">//</span> <span class="n">term</span><span class="o">.</span><span class="n">q</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">term</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">term</span> <span class="o">*=</span> <span class="n">MPZ</span><span class="p">(</span><span class="n">func1</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">term</span> <span class="o">//=</span> <span class="n">MPZ</span><span class="p">(</span><span class="n">func2</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">term</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">from_man_exp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="n">prec</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">alt</span> <span class="o">=</span> <span class="n">g</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sum diverges like (</span><span class="si">%i</span><span class="s2">)^n&quot;</span> <span class="o">%</span> <span class="nb">abs</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">g</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">alt</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sum diverges like n^</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">))</span>
        <span class="c1"># We have polynomial convergence: use Richardson extrapolation</span>
        <span class="n">vold</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ndig</span> <span class="o">=</span> <span class="n">prec_to_dps</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Need to use at least quad precision because a lot of cancellation</span>
            <span class="c1"># might occur in the extrapolation process; we check the answer to</span>
            <span class="c1"># make sure that the desired precision has been reached, too.</span>
            <span class="n">prec2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">prec</span>
            <span class="n">term0</span> <span class="o">=</span> <span class="p">(</span><span class="n">MPZ</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">prec2</span><span class="p">)</span> <span class="o">//</span> <span class="n">term</span><span class="o">.</span><span class="n">q</span>

            <span class="k">def</span> <span class="nf">summand</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">_term</span><span class="o">=</span><span class="p">[</span><span class="n">term0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">k</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">MPZ</span><span class="p">(</span><span class="n">func1</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//=</span> <span class="n">MPZ</span><span class="p">(</span><span class="n">func2</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">make_mpf</span><span class="p">(</span><span class="n">from_man_exp</span><span class="p">(</span><span class="n">_term</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">prec2</span><span class="p">))</span>

            <span class="k">with</span> <span class="n">workprec</span><span class="p">(</span><span class="n">prec</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">nsum</span><span class="p">(</span><span class="n">summand</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">mpmath_inf</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;richardson&#39;</span><span class="p">)</span>
            <span class="n">vf</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ndig</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vold</span> <span class="o">==</span> <span class="n">vf</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">prec</span> <span class="o">+=</span> <span class="n">prec</span>  <span class="c1"># double precision each time</span>
            <span class="n">vold</span> <span class="o">=</span> <span class="n">vf</span>

        <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">_mpf_</span>


<span class="k">def</span> <span class="nf">evalf_prod</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Sum</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">is_Integer</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">limits</span><span class="p">):</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">doit</span><span class="p">(),</span> <span class="n">prec</span><span class="o">=</span><span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">Sum</span><span class="p">),</span> <span class="n">prec</span><span class="o">=</span><span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>


<span class="k">def</span> <span class="nf">evalf_sum</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Float</span>
    <span class="k">if</span> <span class="s1">&#39;subs&#39;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;subs&#39;</span><span class="p">])</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">function</span>
    <span class="n">limits</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">limits</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mpf</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">prec2</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span> <span class="ow">or</span> <span class="n">a</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="c1"># Use fast hypergeometric summation if possible</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">hypsum</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">prec2</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">-</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">10</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">hypsum</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">delta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="kc">None</span>
    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
        <span class="c1"># Euler-Maclaurin summation for general series</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">prec</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">i</span> <span class="o">*</span> <span class="n">prec</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">euler_maclaurin</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
                <span class="n">eval_integral</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">err</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">evalf</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">err</span><span class="p">),</span> <span class="mi">20</span><span class="p">,</span> <span class="n">options</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">prec2</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">re_acc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">re_acc</span> <span class="o">=</span> <span class="o">-</span><span class="n">err</span>
        <span class="k">if</span> <span class="n">im_acc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">im_acc</span> <span class="o">=</span> <span class="o">-</span><span class="n">err</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>


<span class="c1">#----------------------------------------------------------------------------#</span>
<span class="c1">#                                                                            #</span>
<span class="c1">#                            Symbolic interface                              #</span>
<span class="c1">#                                                                            #</span>
<span class="c1">#----------------------------------------------------------------------------#</span>

<span class="k">def</span> <span class="nf">evalf_symbol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;subs&#39;</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">mpf</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;_cache&#39;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">options</span><span class="p">[</span><span class="s1">&#39;_cache&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;_cache&#39;</span><span class="p">]</span>
        <span class="n">cached</span><span class="p">,</span> <span class="n">cached_prec</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">MINUS_INF</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">cached_prec</span> <span class="o">&gt;=</span> <span class="n">prec</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cached</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span>

<span class="n">evalf_table</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_create_evalf_table</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">evalf_table</span>
    <span class="kn">from</span> <span class="nn">sympy.functions.combinatorial.numbers</span> <span class="k">import</span> <span class="n">bernoulli</span>
    <span class="kn">from</span> <span class="nn">sympy.concrete.products</span> <span class="k">import</span> <span class="n">Product</span>
    <span class="kn">from</span> <span class="nn">sympy.concrete.summations</span> <span class="k">import</span> <span class="n">Sum</span>
    <span class="kn">from</span> <span class="nn">sympy.core.add</span> <span class="k">import</span> <span class="n">Add</span>
    <span class="kn">from</span> <span class="nn">sympy.core.mul</span> <span class="k">import</span> <span class="n">Mul</span>
    <span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="k">import</span> <span class="n">Exp1</span><span class="p">,</span> <span class="n">Float</span><span class="p">,</span> <span class="n">Half</span><span class="p">,</span> <span class="n">ImaginaryUnit</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">NaN</span><span class="p">,</span> <span class="n">NegativeOne</span><span class="p">,</span> <span class="n">One</span><span class="p">,</span> <span class="n">Pi</span><span class="p">,</span> <span class="n">Rational</span><span class="p">,</span> <span class="n">Zero</span>
    <span class="kn">from</span> <span class="nn">sympy.core.power</span> <span class="k">import</span> <span class="n">Pow</span>
    <span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="k">import</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Symbol</span>
    <span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="k">import</span> <span class="n">Abs</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re</span>
    <span class="kn">from</span> <span class="nn">sympy.functions.elementary.exponential</span> <span class="k">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log</span>
    <span class="kn">from</span> <span class="nn">sympy.functions.elementary.integers</span> <span class="k">import</span> <span class="n">ceiling</span><span class="p">,</span> <span class="n">floor</span>
    <span class="kn">from</span> <span class="nn">sympy.functions.elementary.piecewise</span> <span class="k">import</span> <span class="n">Piecewise</span>
    <span class="kn">from</span> <span class="nn">sympy.functions.elementary.trigonometric</span> <span class="k">import</span> <span class="n">atan</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span>
    <span class="kn">from</span> <span class="nn">sympy.integrals.integrals</span> <span class="k">import</span> <span class="n">Integral</span>
    <span class="n">evalf_table</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">Symbol</span><span class="p">:</span> <span class="n">evalf_symbol</span><span class="p">,</span>
        <span class="n">Dummy</span><span class="p">:</span> <span class="n">evalf_symbol</span><span class="p">,</span>
        <span class="n">Float</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">Rational</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">from_rational</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">prec</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">Integer</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">from_int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">prec</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">Zero</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">One</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">fone</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">Half</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">fhalf</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">Pi</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">mpf_pi</span><span class="p">(</span><span class="n">prec</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">Exp1</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">mpf_e</span><span class="p">(</span><span class="n">prec</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">ImaginaryUnit</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">fone</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">),</span>
        <span class="n">NegativeOne</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">fnone</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">NaN</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">fnan</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>

        <span class="n">exp</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">evalf_pow</span><span class="p">(</span>
            <span class="n">Pow</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Exp1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">),</span>

        <span class="n">cos</span><span class="p">:</span> <span class="n">evalf_trig</span><span class="p">,</span>
        <span class="n">sin</span><span class="p">:</span> <span class="n">evalf_trig</span><span class="p">,</span>

        <span class="n">Add</span><span class="p">:</span> <span class="n">evalf_add</span><span class="p">,</span>
        <span class="n">Mul</span><span class="p">:</span> <span class="n">evalf_mul</span><span class="p">,</span>
        <span class="n">Pow</span><span class="p">:</span> <span class="n">evalf_pow</span><span class="p">,</span>

        <span class="n">log</span><span class="p">:</span> <span class="n">evalf_log</span><span class="p">,</span>
        <span class="n">atan</span><span class="p">:</span> <span class="n">evalf_atan</span><span class="p">,</span>
        <span class="n">Abs</span><span class="p">:</span> <span class="n">evalf_abs</span><span class="p">,</span>

        <span class="n">re</span><span class="p">:</span> <span class="n">evalf_re</span><span class="p">,</span>
        <span class="n">im</span><span class="p">:</span> <span class="n">evalf_im</span><span class="p">,</span>
        <span class="n">floor</span><span class="p">:</span> <span class="n">evalf_floor</span><span class="p">,</span>
        <span class="n">ceiling</span><span class="p">:</span> <span class="n">evalf_ceiling</span><span class="p">,</span>

        <span class="n">Integral</span><span class="p">:</span> <span class="n">evalf_integral</span><span class="p">,</span>
        <span class="n">Sum</span><span class="p">:</span> <span class="n">evalf_sum</span><span class="p">,</span>
        <span class="n">Product</span><span class="p">:</span> <span class="n">evalf_prod</span><span class="p">,</span>
        <span class="n">Piecewise</span><span class="p">:</span> <span class="n">evalf_piecewise</span><span class="p">,</span>

        <span class="n">bernoulli</span><span class="p">:</span> <span class="n">evalf_bernoulli</span><span class="p">,</span>
    <span class="p">}</span>


<span class="k">def</span> <span class="nf">evalf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">re</span> <span class="k">as</span> <span class="n">re_</span><span class="p">,</span> <span class="n">im</span> <span class="k">as</span> <span class="n">im_</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">rf</span> <span class="o">=</span> <span class="n">evalf_table</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">func</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c1"># Fall back to ordinary evalf if possible</span>
        <span class="k">if</span> <span class="s1">&#39;subs&#39;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">evalf_subs</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;subs&#39;</span><span class="p">]))</span>
        <span class="n">xe</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xe</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="n">as_real_imag</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">xe</span><span class="p">,</span> <span class="s2">&quot;as_real_imag&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">as_real_imag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span> <span class="c1"># e.g. FiniteSet(-1.0, 1.0).evalf()</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">as_real_imag</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">re_</span><span class="p">)</span> <span class="ow">or</span> <span class="n">im</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">im_</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">if</span> <span class="n">re</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">re</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">reprec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">_to_mpmath</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">allow_ints</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_mpf_</span>
            <span class="n">reprec</span> <span class="o">=</span> <span class="n">prec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">if</span> <span class="n">im</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">imprec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">_to_mpmath</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">allow_ints</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_mpf_</span>
            <span class="n">imprec</span> <span class="o">=</span> <span class="n">prec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">reprec</span><span class="p">,</span> <span class="n">imprec</span>

    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;verbose&quot;</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;### input&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;### output&quot;</span><span class="p">,</span> <span class="n">to_str</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;### raw&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="c1"># r[0], r[2]</span>
        <span class="nb">print</span><span class="p">()</span>
    <span class="n">chop</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;chop&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">chop</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">chop</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">chop_prec</span> <span class="o">=</span> <span class="n">prec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># convert (approximately) from given tolerance;</span>
            <span class="c1"># the formula here will will make 1e-i rounds to 0 for</span>
            <span class="c1"># i in the range +/-27 while 2e-i will not be chopped</span>
            <span class="n">chop_prec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="o">-</span><span class="mf">3.321</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">chop</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.5</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">chop_prec</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">chop_prec</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">chop_parts</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">chop_prec</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;strict&quot;</span><span class="p">):</span>
        <span class="n">check_target</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>


<span class="k">class</span> <span class="nc">EvalfMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mixin class adding evalf capabililty.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">evalf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxn</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">chop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">quad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the given formula to an accuracy of n digits.</span>
<span class="sd">        Optional keyword arguments:</span>

<span class="sd">            subs=&lt;dict&gt;</span>
<span class="sd">                Substitute numerical values for symbols, e.g.</span>
<span class="sd">                subs={x:3, y:1+pi}. The substitutions must be given as a</span>
<span class="sd">                dictionary.</span>

<span class="sd">            maxn=&lt;integer&gt;</span>
<span class="sd">                Allow a maximum temporary working precision of maxn digits</span>
<span class="sd">                (default=100)</span>

<span class="sd">            chop=&lt;bool&gt;</span>
<span class="sd">                Replace tiny real or imaginary parts in subresults</span>
<span class="sd">                by exact zeros (default=False)</span>

<span class="sd">            strict=&lt;bool&gt;</span>
<span class="sd">                Raise PrecisionExhausted if any subresult fails to evaluate</span>
<span class="sd">                to full accuracy, given the available maxprec</span>
<span class="sd">                (default=False)</span>

<span class="sd">            quad=&lt;str&gt;</span>
<span class="sd">                Choose algorithm for numerical quadrature. By default,</span>
<span class="sd">                tanh-sinh quadrature is used. For oscillatory</span>
<span class="sd">                integrals on an infinite interval, try quad=&#39;osc&#39;.</span>

<span class="sd">            verbose=&lt;bool&gt;</span>
<span class="sd">                Print debug information (default=False)</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        When Floats are naively substituted into an expression, precision errors</span>
<span class="sd">        may adversely affect the result. For example, adding 1e16 (a Float) to 1</span>
<span class="sd">        will truncate to 1e16; if 1e16 is then subtracted, the result will be 0.</span>
<span class="sd">        That is exactly what happens in the following:</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">        &gt;&gt;&gt; values = {x: 1e16, y: 1, z: 1e16}</span>
<span class="sd">        &gt;&gt;&gt; (x + y - z).subs(values)</span>
<span class="sd">        0</span>

<span class="sd">        Using the subs argument for evalf is the accurate way to evaluate such an</span>
<span class="sd">        expression:</span>

<span class="sd">        &gt;&gt;&gt; (x + y - z).evalf(subs=values)</span>
<span class="sd">        1.00000000000000</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Float</span><span class="p">,</span> <span class="n">Number</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">15</span>

        <span class="k">if</span> <span class="n">subs</span> <span class="ow">and</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">subs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;subs must be given as a dictionary&#39;</span><span class="p">)</span>

        <span class="c1"># for sake of sage that doesn&#39;t like evalf(1)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">sympy.core.expr</span> <span class="k">import</span> <span class="n">_mag</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">subs</span><span class="p">,</span> <span class="n">maxn</span><span class="p">,</span> <span class="n">chop</span><span class="p">,</span> <span class="n">strict</span><span class="p">,</span> <span class="n">quad</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">_mag</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">rv</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rv</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">evalf_table</span><span class="p">:</span>
            <span class="n">_create_evalf_table</span><span class="p">()</span>
        <span class="n">prec</span> <span class="o">=</span> <span class="n">dps_to_prec</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;maxprec&#39;</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxn</span><span class="o">*</span><span class="n">LG10</span><span class="p">)),</span> <span class="s1">&#39;chop&#39;</span><span class="p">:</span> <span class="n">chop</span><span class="p">,</span>
               <span class="s1">&#39;strict&#39;</span><span class="p">:</span> <span class="n">strict</span><span class="p">,</span> <span class="s1">&#39;verbose&#39;</span><span class="p">:</span> <span class="n">verbose</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">subs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">options</span><span class="p">[</span><span class="s1">&#39;subs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subs</span>
        <span class="k">if</span> <span class="n">quad</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">options</span><span class="p">[</span><span class="s1">&#39;quad&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quad</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="c1"># Fall back to the ordinary evalf</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># If the result is numerical, normalize it</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="c1"># Probably contains symbols or unknown functions</span>
                <span class="k">return</span> <span class="n">v</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">if</span> <span class="n">re</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">im_acc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">re</span> <span class="o">+</span> <span class="n">im</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">re</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">evalf</span>

    <span class="k">def</span> <span class="nf">_evalf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper for evalf. Does the same thing but takes binary precision&quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">_eval_evalf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_to_mpmath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">allow_ints</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># mpmath functions accept ints as input</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;cannot convert to mpmath number&quot;</span>
        <span class="k">if</span> <span class="n">allow_ints</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_as_mpf_val&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">make_mpf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_as_mpf_val</span><span class="p">(</span><span class="n">prec</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">:</span>
                    <span class="n">re</span> <span class="o">=</span> <span class="n">fzero</span>
                <span class="k">return</span> <span class="n">make_mpc</span><span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">re</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">make_mpf</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">make_mpf</span><span class="p">(</span><span class="n">fzero</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">make_mpf</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">)</span>
            <span class="c1"># Number + Number*I is also fine</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">allow_ints</span> <span class="ow">and</span> <span class="n">re</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="n">re</span> <span class="o">=</span> <span class="n">from_int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                <span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">_mpf_</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">allow_ints</span> <span class="ow">and</span> <span class="n">im</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">from_int</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">_mpf_</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">make_mpc</span><span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">N</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calls x.evalf(n, \*\*options).</span>

<span class="sd">    Both .n() and N() are equivalent to .evalf(); use the one that you like better.</span>
<span class="sd">    See also the docstring of .evalf() for information on the options.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Sum, oo, N</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import k</span>
<span class="sd">    &gt;&gt;&gt; Sum(1/k**k, (k, 1, oo))</span>
<span class="sd">    Sum(k**(-k), (k, 1, oo))</span>
<span class="sd">    &gt;&gt;&gt; N(_, 4)</span>
<span class="sd">    1.291</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright J. Taylor and others
      <span class="lastupdated">
        Last updated on Sep 25, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>