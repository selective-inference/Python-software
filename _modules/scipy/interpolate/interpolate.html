

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Selection &mdash; Selection Documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />


</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../algorithms/index.html">Non-randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../randomized/index.html">Randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../learning/index.html">Learning selection</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">selection</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>Selection</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for scipy.interpolate.interpolate</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Classes for interpolating values.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;interp1d&#39;</span><span class="p">,</span> <span class="s1">&#39;interp2d&#39;</span><span class="p">,</span> <span class="s1">&#39;spline&#39;</span><span class="p">,</span> <span class="s1">&#39;spleval&#39;</span><span class="p">,</span> <span class="s1">&#39;splmake&#39;</span><span class="p">,</span> <span class="s1">&#39;spltopp&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ppform&#39;</span><span class="p">,</span> <span class="s1">&#39;lagrange&#39;</span><span class="p">,</span> <span class="s1">&#39;PPoly&#39;</span><span class="p">,</span> <span class="s1">&#39;BPoly&#39;</span><span class="p">,</span> <span class="s1">&#39;NdPPoly&#39;</span><span class="p">,</span>
           <span class="s1">&#39;RegularGridInterpolator&#39;</span><span class="p">,</span> <span class="s1">&#39;interpn&#39;</span><span class="p">]</span>


<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">transpose</span><span class="p">,</span> <span class="n">searchsorted</span><span class="p">,</span> <span class="n">atleast_1d</span><span class="p">,</span> <span class="n">atleast_2d</span><span class="p">,</span>
                   <span class="n">dot</span><span class="p">,</span> <span class="n">ravel</span><span class="p">,</span> <span class="n">poly1d</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">intp</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">spec</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">comb</span>

<span class="kn">from</span> <span class="nn">scipy._lib.six</span> <span class="k">import</span> <span class="n">xrange</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">,</span> <span class="n">string_types</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">fitpack</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">dfitpack</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_fitpack</span>
<span class="kn">from</span> <span class="nn">.polyint</span> <span class="k">import</span> <span class="n">_Interpolator1D</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_ppoly</span>
<span class="kn">from</span> <span class="nn">.fitpack2</span> <span class="k">import</span> <span class="n">RectBivariateSpline</span>
<span class="kn">from</span> <span class="nn">.interpnd</span> <span class="k">import</span> <span class="n">_ndim_coords_from_arrays</span>
<span class="kn">from</span> <span class="nn">._bsplines</span> <span class="k">import</span> <span class="n">make_interp_spline</span><span class="p">,</span> <span class="n">BSpline</span>


<span class="k">def</span> <span class="nf">prod</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Product of a list of numbers; ~40x faster vs np.prod for Python tuples&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">lagrange</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a Lagrange interpolating polynomial.</span>

<span class="sd">    Given two 1-D arrays `x` and `w,` returns the Lagrange interpolating</span>
<span class="sd">    polynomial through the points ``(x, w)``.</span>

<span class="sd">    Warning: This implementation is numerically unstable. Do not expect to</span>
<span class="sd">    be able to use more than about 20 points even if they are chosen optimally.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        `x` represents the x-coordinates of a set of datapoints.</span>
<span class="sd">    w : array_like</span>
<span class="sd">        `w` represents the y-coordinates of a set of datapoints, i.e. f(`x`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lagrange : numpy.poly1d instance</span>
<span class="sd">        The Lagrange interpolating polynomial.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">poly1d</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">poly1d</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">fac</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">pt</span> <span class="o">*=</span> <span class="n">poly1d</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span><span class="o">/</span><span class="n">fac</span>
        <span class="n">p</span> <span class="o">+=</span> <span class="n">pt</span>
    <span class="k">return</span> <span class="n">p</span>


<span class="c1"># !! Need to find argument for keeping initialize.  If it isn&#39;t</span>
<span class="c1"># !! found, get rid of it!</span>


<span class="k">class</span> <span class="nc">interp2d</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    interp2d(x, y, z, kind=&#39;linear&#39;, copy=True, bounds_error=False,</span>
<span class="sd">             fill_value=nan)</span>

<span class="sd">    Interpolate over a 2-D grid.</span>

<span class="sd">    `x`, `y` and `z` are arrays of values used to approximate some function</span>
<span class="sd">    f: ``z = f(x, y)``. This class returns a function whose call method uses</span>
<span class="sd">    spline interpolation to find the value of new points.</span>

<span class="sd">    If `x` and `y` represent a regular grid, consider using</span>
<span class="sd">    RectBivariateSpline.</span>

<span class="sd">    Note that calling `interp2d` with NaNs present in input values results in</span>
<span class="sd">    undefined behaviour.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : array_like</span>
<span class="sd">        Arrays defining the data point coordinates.</span>

<span class="sd">        If the points lie on a regular grid, `x` can specify the column</span>
<span class="sd">        coordinates and `y` the row coordinates, for example::</span>

<span class="sd">          &gt;&gt;&gt; x = [0,1,2];  y = [0,3]; z = [[1,2,3], [4,5,6]]</span>

<span class="sd">        Otherwise, `x` and `y` must specify the full coordinates for each</span>
<span class="sd">        point, for example::</span>

<span class="sd">          &gt;&gt;&gt; x = [0,1,2,0,1,2];  y = [0,0,0,3,3,3]; z = [1,2,3,4,5,6]</span>

<span class="sd">        If `x` and `y` are multi-dimensional, they are flattened before use.</span>
<span class="sd">    z : array_like</span>
<span class="sd">        The values of the function to interpolate at the data points. If</span>
<span class="sd">        `z` is a multi-dimensional array, it is flattened before use.  The</span>
<span class="sd">        length of a flattened `z` array is either</span>
<span class="sd">        len(`x`)*len(`y`) if `x` and `y` specify the column and row coordinates</span>
<span class="sd">        or ``len(z) == len(x) == len(y)`` if `x` and `y` specify coordinates</span>
<span class="sd">        for each point.</span>
<span class="sd">    kind : {&#39;linear&#39;, &#39;cubic&#39;, &#39;quintic&#39;}, optional</span>
<span class="sd">        The kind of spline interpolation to use. Default is &#39;linear&#39;.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If True, the class makes internal copies of x, y and z.</span>
<span class="sd">        If False, references may be used. The default is to copy.</span>
<span class="sd">    bounds_error : bool, optional</span>
<span class="sd">        If True, when interpolated values are requested outside of the</span>
<span class="sd">        domain of the input data (x,y), a ValueError is raised.</span>
<span class="sd">        If False, then `fill_value` is used.</span>
<span class="sd">    fill_value : number, optional</span>
<span class="sd">        If provided, the value to use for points outside of the</span>
<span class="sd">        interpolation domain. If omitted (None), values outside</span>
<span class="sd">        the domain are extrapolated.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    RectBivariateSpline :</span>
<span class="sd">        Much faster 2D interpolation if your input data is on a grid</span>
<span class="sd">    bisplrep, bisplev :</span>
<span class="sd">        Spline interpolation based on FITPACK</span>
<span class="sd">    BivariateSpline : a more recent wrapper of the FITPACK routines</span>
<span class="sd">    interp1d : one dimension version of this function</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The minimum number of data points required along the interpolation</span>
<span class="sd">    axis is ``(k+1)**2``, with k=1 for linear, k=3 for cubic and k=5 for</span>
<span class="sd">    quintic interpolation.</span>

<span class="sd">    The interpolator is constructed by `bisplrep`, with a smoothing factor</span>
<span class="sd">    of 0. If more control over smoothing is needed, `bisplrep` should be</span>
<span class="sd">    used directly.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Construct a 2-D grid and interpolate on it:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import interpolate</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(-5.01, 5.01, 0.25)</span>
<span class="sd">    &gt;&gt;&gt; y = np.arange(-5.01, 5.01, 0.25)</span>
<span class="sd">    &gt;&gt;&gt; xx, yy = np.meshgrid(x, y)</span>
<span class="sd">    &gt;&gt;&gt; z = np.sin(xx**2+yy**2)</span>
<span class="sd">    &gt;&gt;&gt; f = interpolate.interp2d(x, y, z, kind=&#39;cubic&#39;)</span>

<span class="sd">    Now use the obtained interpolation function and plot the result:</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; xnew = np.arange(-5.01, 5.01, 1e-2)</span>
<span class="sd">    &gt;&gt;&gt; ynew = np.arange(-5.01, 5.01, 1e-2)</span>
<span class="sd">    &gt;&gt;&gt; znew = f(xnew, ynew)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, z[0, :], &#39;ro-&#39;, xnew, znew[0, :], &#39;b-&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

        <span class="n">rectangular_grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">rectangular_grid</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When on a regular grid with x.size = m &quot;</span>
                                     <span class="s2">&quot;and y.size = n, if z.ndim == 2, then z &quot;</span>
                                     <span class="s2">&quot;must have shape (n, m)&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;x and y must have equal lengths for non rectangular grid&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid length for input z for non rectangular grid&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">kx</span> <span class="o">=</span> <span class="n">ky</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;linear&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                       <span class="s1">&#39;cubic&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                       <span class="s1">&#39;quintic&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}[</span><span class="n">kind</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported interpolation type.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">rectangular_grid</span><span class="p">:</span>
            <span class="c1"># TODO: surfit is really not meant for interpolation!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tck</span> <span class="o">=</span> <span class="n">fitpack</span><span class="o">.</span><span class="n">bisplrep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">kx</span><span class="o">=</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="o">=</span><span class="n">ky</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">regrid_smth</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">kx</span><span class="o">=</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="o">=</span><span class="n">ky</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tck</span> <span class="o">=</span> <span class="p">(</span><span class="n">tx</span><span class="p">[:</span><span class="n">nx</span><span class="p">],</span> <span class="n">ty</span><span class="p">[:</span><span class="n">ny</span><span class="p">],</span> <span class="n">c</span><span class="p">[:(</span><span class="n">nx</span> <span class="o">-</span> <span class="n">kx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ny</span> <span class="o">-</span> <span class="n">ky</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)],</span>
                        <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="n">bounds_error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolate the function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1D array</span>
<span class="sd">            x-coordinates of the mesh on which to interpolate.</span>
<span class="sd">        y : 1D array</span>
<span class="sd">            y-coordinates of the mesh on which to interpolate.</span>
<span class="sd">        dx : int &gt;= 0, &lt; kx</span>
<span class="sd">            Order of partial derivatives in x.</span>
<span class="sd">        dy : int &gt;= 0, &lt; ky</span>
<span class="sd">            Order of partial derivatives in y.</span>
<span class="sd">        assume_sorted : bool, optional</span>
<span class="sd">            If False, values of `x` and `y` can be in any order and they are</span>
<span class="sd">            sorted first.</span>
<span class="sd">            If True, `x` and `y` have to be arrays of monotonically</span>
<span class="sd">            increasing values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        z : 2D array with shape (len(y), len(x))</span>
<span class="sd">            The interpolated values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y should both be 1-D arrays&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">assume_sorted</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_of_bounds_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">)</span>
            <span class="n">out_of_bounds_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">)</span>

            <span class="n">any_out_of_bounds_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">out_of_bounds_x</span><span class="p">)</span>
            <span class="n">any_out_of_bounds_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">out_of_bounds_y</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">and</span> <span class="p">(</span><span class="n">any_out_of_bounds_x</span> <span class="ow">or</span> <span class="n">any_out_of_bounds_y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Values out of range; x must be in </span><span class="si">%r</span><span class="s2">, y in </span><span class="si">%r</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">),</span>
                                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">)))</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">fitpack</span><span class="o">.</span><span class="n">bisplev</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tck</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">any_out_of_bounds_x</span><span class="p">:</span>
                <span class="n">z</span><span class="p">[:,</span> <span class="n">out_of_bounds_x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>
            <span class="k">if</span> <span class="n">any_out_of_bounds_y</span><span class="p">:</span>
                <span class="n">z</span><span class="p">[</span><span class="n">out_of_bounds_y</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_broadcast_up_to</span><span class="p">(</span><span class="n">arr_from</span><span class="p">,</span> <span class="n">shape_to</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to check that arr_from broadcasts up to shape_to&quot;&quot;&quot;</span>
    <span class="n">shape_from</span> <span class="o">=</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_to</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_from</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape_to</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape_from</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">t</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># all checks pass, do the upcasting that we need later</span>
            <span class="k">if</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">shape_to</span><span class="p">:</span>
                <span class="n">arr_from</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape_to</span><span class="p">,</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">arr_from</span>
            <span class="k">return</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="c1"># at least one check failed</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> argument must be able to broadcast up &#39;</span>
                     <span class="s1">&#39;to shape </span><span class="si">%s</span><span class="s1"> but had shape </span><span class="si">%s</span><span class="s1">&#39;</span>
                     <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shape_to</span><span class="p">,</span> <span class="n">shape_from</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_do_extrapolate</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to check if fill_value == &quot;extrapolate&quot; without warnings&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">fill_value</span> <span class="o">==</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">interp1d</span><span class="p">(</span><span class="n">_Interpolator1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate a 1-D function.</span>

<span class="sd">    `x` and `y` are arrays of values used to approximate some function f:</span>
<span class="sd">    ``y = f(x)``.  This class returns a function whose call method uses</span>
<span class="sd">    interpolation to find the value of new points.</span>

<span class="sd">    Note that calling `interp1d` with NaNs present in input values results in</span>
<span class="sd">    undefined behaviour.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (N,) array_like</span>
<span class="sd">        A 1-D array of real values.</span>
<span class="sd">    y : (...,N,...) array_like</span>
<span class="sd">        A N-D array of real values. The length of `y` along the interpolation</span>
<span class="sd">        axis must be equal to the length of `x`.</span>
<span class="sd">    kind : str or int, optional</span>
<span class="sd">        Specifies the kind of interpolation as a string</span>
<span class="sd">        (&#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">        where &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39; and &#39;cubic&#39; refer to a spline</span>
<span class="sd">        interpolation of zeroth, first, second or third order) or as an</span>
<span class="sd">        integer specifying the order of the spline interpolator to use.</span>
<span class="sd">        Default is &#39;linear&#39;.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Specifies the axis of `y` along which to interpolate.</span>
<span class="sd">        Interpolation defaults to the last axis of `y`.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If True, the class makes internal copies of x and y.</span>
<span class="sd">        If False, references to `x` and `y` are used. The default is to copy.</span>
<span class="sd">    bounds_error : bool, optional</span>
<span class="sd">        If True, a ValueError is raised any time interpolation is attempted on</span>
<span class="sd">        a value outside of the range of x (where extrapolation is</span>
<span class="sd">        necessary). If False, out of bounds values are assigned `fill_value`.</span>
<span class="sd">        By default, an error is raised unless `fill_value=&quot;extrapolate&quot;`.</span>
<span class="sd">    fill_value : array-like or (array-like, array_like) or &quot;extrapolate&quot;, optional</span>
<span class="sd">        - if a ndarray (or float), this value will be used to fill in for</span>
<span class="sd">          requested points outside of the data range. If not provided, then</span>
<span class="sd">          the default is NaN. The array-like must broadcast properly to the</span>
<span class="sd">          dimensions of the non-interpolation axes.</span>
<span class="sd">        - If a two-element tuple, then the first element is used as a</span>
<span class="sd">          fill value for ``x_new &lt; x[0]`` and the second element is used for</span>
<span class="sd">          ``x_new &gt; x[-1]``. Anything that is not a 2-element tuple (e.g.,</span>
<span class="sd">          list or ndarray, regardless of shape) is taken to be a single</span>
<span class="sd">          array-like argument meant to be used for both bounds as</span>
<span class="sd">          ``below, above = fill_value, fill_value``.</span>

<span class="sd">          .. versionadded:: 0.17.0</span>
<span class="sd">        - If &quot;extrapolate&quot;, then points outside the data range will be</span>
<span class="sd">          extrapolated.</span>

<span class="sd">          .. versionadded:: 0.17.0</span>
<span class="sd">    assume_sorted : bool, optional</span>
<span class="sd">        If False, values of `x` can be in any order and they are sorted first.</span>
<span class="sd">        If True, `x` has to be an array of monotonically increasing values.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    splrep, splev</span>
<span class="sd">        Spline interpolation/smoothing based on FITPACK.</span>
<span class="sd">    UnivariateSpline : An object-oriented wrapper of the FITPACK routines.</span>
<span class="sd">    interp2d : 2-D interpolation</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy import interpolate</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(0, 10)</span>
<span class="sd">    &gt;&gt;&gt; y = np.exp(-x/3.0)</span>
<span class="sd">    &gt;&gt;&gt; f = interpolate.interp1d(x, y)</span>

<span class="sd">    &gt;&gt;&gt; xnew = np.arange(0, 9, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; ynew = f(xnew)   # use interpolation function returned by `interp1d`</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;o&#39;, xnew, ynew, &#39;-&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                 <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialize a 1D linear interpolation class.&quot;&quot;&quot;</span>
        <span class="n">_Interpolator1D</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="n">bounds_error</span>  <span class="c1"># used by fill_value setter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy</span> <span class="o">=</span> <span class="n">copy</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span> <span class="s1">&#39;slinear&#39;</span><span class="p">,</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">]:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nearest&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;zero&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;slinear&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}[</span><span class="n">kind</span><span class="p">]</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;spline&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">kind</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;spline&#39;</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is unsupported: Use fitpack &quot;</span>
                                      <span class="s2">&quot;routines for other types.&quot;</span> <span class="o">%</span> <span class="n">kind</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">assume_sorted</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the x array must have exactly one dimension.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the y array must have at least one dimension.&quot;</span><span class="p">)</span>

        <span class="c1"># Force-cast y to a floating-point type, if it&#39;s not yet one</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>

        <span class="c1"># Backward compatibility</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">%</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span>

        <span class="c1"># Interpolation goes internally along the first axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_yi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">del</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>  <span class="c1"># clean up namespace to prevent misuse; use attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kind</span> <span class="o">=</span> <span class="n">kind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>  <span class="c1"># calls the setter, can modify bounds_err</span>

        <span class="c1"># Adjust to interpolation kind; store reference to *unbound*</span>
        <span class="c1"># interpolation methods, in order to avoid circular references to self</span>
        <span class="c1"># stored in the bound instance methods, and therefore delayed garbage</span>
        <span class="c1"># collection.  See: http://docs.python.org/2/reference/datamodel.html</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">):</span>
            <span class="c1"># Make a &quot;view&quot; of the y array that is rotated to the interpolation</span>
            <span class="c1"># axis.</span>
            <span class="n">minval</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
                <span class="c1"># Do division before addition to prevent possible integer</span>
                <span class="c1"># overflow</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_nearest</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check if we can delegate to numpy.interp (2x-10x faster).</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float_</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float_</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_do_extrapolate</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">cond</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_linear_np</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_linear</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minval</span> <span class="o">=</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">rewrite_nan</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span>
            <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Quadratic or cubic spline. If input contains even a single</span>
                <span class="c1"># nan, then the output is all nans. We cannot just feed data</span>
                <span class="c1"># with nans to make_interp_spline because it calls LAPACK.</span>
                <span class="c1"># So, we make up a bogus x and y with no nans and use it</span>
                <span class="c1"># to get the correct shape of the output, which we then fill</span>
                <span class="c1"># with nans.</span>
                <span class="c1"># For slinear or zero order spline, we just pass nans through.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
                    <span class="n">rewrite_nan</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span>
                    <span class="n">rewrite_nan</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_spline</span> <span class="o">=</span> <span class="n">make_interp_spline</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                                              <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rewrite_nan</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_nan_spline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_spline</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minval</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y arrays must have at &quot;</span>
                             <span class="s2">&quot;least </span><span class="si">%d</span><span class="s2"> entries&quot;</span> <span class="o">%</span> <span class="n">minval</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># backwards compat: mimic a public attribute</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_orig</span>

    <span class="nd">@fill_value</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
        <span class="c1"># extrapolation only works for nearest neighbor and linear methods</span>
        <span class="k">if</span> <span class="n">_do_extrapolate</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot extrapolate and raise &quot;</span>
                                 <span class="s2">&quot;at the same time.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
            <span class="c1"># it&#39;s either a pair (_below_range, _above_range) or a single value</span>
            <span class="c1"># for both above and below range</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">below_above</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;fill_value (below)&#39;</span><span class="p">,</span> <span class="s1">&#39;fill_value (above)&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">below_above</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">_check_broadcast_up_to</span><span class="p">(</span>
                        <span class="n">below_above</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">names</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
                <span class="n">below_above</span> <span class="o">=</span> <span class="p">[</span><span class="n">_check_broadcast_up_to</span><span class="p">(</span>
                    <span class="n">fill_value</span><span class="p">,</span> <span class="n">broadcast_shape</span><span class="p">,</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_below</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_above</span> <span class="o">=</span> <span class="n">below_above</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extrapolate</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># backwards compat: fill_value was a public attr; make it writeable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_orig</span> <span class="o">=</span> <span class="n">fill_value</span>

    <span class="k">def</span> <span class="nf">_call_linear_np</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="c1"># Note that out-of-bounds values are taken care of in self._evaluate</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">x_new</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="c1"># 2. Find where in the orignal data, the values to interpolate</span>
        <span class="c1">#    would be inserted.</span>
        <span class="c1">#    Note: If x_new[n] == x[m], then m is returned by searchsorted.</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x_new</span><span class="p">)</span>

        <span class="c1"># 3. Clip x_new_indices so that they are within the range of</span>
        <span class="c1">#    self.x indices and at least 1.  Removes mis-interpolation</span>
        <span class="c1">#    of x_new[n] = x[0]</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">x_new_indices</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># 4. Calculate the slope of regions that each x_new value falls in.</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="n">x_new_indices</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">hi</span> <span class="o">=</span> <span class="n">x_new_indices</span>

        <span class="n">x_lo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span>
        <span class="n">x_hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span>
        <span class="n">y_lo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span>
        <span class="n">y_hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span>

        <span class="c1"># Note that the following two expressions rely on the specifics of the</span>
        <span class="c1"># broadcasting semantics.</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_hi</span> <span class="o">-</span> <span class="n">y_lo</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_hi</span> <span class="o">-</span> <span class="n">x_lo</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># 5. Calculate the actual value for each entry in x_new.</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="n">slope</span><span class="o">*</span><span class="p">(</span><span class="n">x_new</span> <span class="o">-</span> <span class="n">x_lo</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">y_lo</span>

        <span class="k">return</span> <span class="n">y_new</span>

    <span class="k">def</span> <span class="nf">_call_nearest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find nearest neighbour interpolated y_new = f(x_new).&quot;&quot;&quot;</span>

        <span class="c1"># 2. Find where in the averaged data the values to interpolate</span>
        <span class="c1">#    would be inserted.</span>
        <span class="c1">#    Note: use side=&#39;left&#39; (right) to searchsorted() to define the</span>
        <span class="c1">#    halfway point to be nearest to the left (right) neighbour</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span><span class="p">,</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>

        <span class="c1"># 3. Clip x_new_indices so that they are within the range of x indices.</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">x_new_indices</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>

        <span class="c1"># 4. Calculate the actual value for each entry in x_new.</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">[</span><span class="n">x_new_indices</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">y_new</span>

    <span class="k">def</span> <span class="nf">_call_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spline</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_nan_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spline</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="c1"># 1. Handle values in x_new that are outside of x.  Throw error,</span>
        <span class="c1">#    or return a list of mask array indicating the outofbounds values.</span>
        <span class="c1">#    The behavior is set by the bounds_error variable.</span>
        <span class="n">x_new</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extrapolate</span><span class="p">:</span>
            <span class="n">below_bounds</span><span class="p">,</span> <span class="n">above_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_bounds</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_new</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Note fill_value must be broadcast up to the proper size</span>
                <span class="c1"># and flattened to work here</span>
                <span class="n">y_new</span><span class="p">[</span><span class="n">below_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_below</span>
                <span class="n">y_new</span><span class="p">[</span><span class="n">above_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_above</span>
        <span class="k">return</span> <span class="n">y_new</span>

    <span class="k">def</span> <span class="nf">_check_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check the inputs for being in the bounds of the interpolated data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_new : array</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out_of_bounds : bool array</span>
<span class="sd">            The mask on x_new of values that are out of the bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If self.bounds_error is True, we raise an error if any x_new values</span>
        <span class="c1"># fall outside the range of x.  Otherwise, we return an array indicating</span>
        <span class="c1"># which values are outside the boundary region.</span>
        <span class="n">below_bounds</span> <span class="o">=</span> <span class="n">x_new</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">above_bounds</span> <span class="o">=</span> <span class="n">x_new</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># !! Could provide more information about which values are out of bounds</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">and</span> <span class="n">below_bounds</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A value in x_new is below the interpolation &quot;</span>
                             <span class="s2">&quot;range.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">and</span> <span class="n">above_bounds</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A value in x_new is above the interpolation &quot;</span>
                             <span class="s2">&quot;range.&quot;</span><span class="p">)</span>

        <span class="c1"># !! Should we emit a warning if some values are out of bounds?</span>
        <span class="c1"># !! matlab does not.</span>
        <span class="k">return</span> <span class="n">below_bounds</span><span class="p">,</span> <span class="n">above_bounds</span>


<span class="k">class</span> <span class="nc">_PPolyBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for piecewise polynomials.&quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">extrapolate</span> <span class="o">!=</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="n">extrapolate</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> must be between 0 and </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># roll the interpolation axis to be the first one in self.c</span>
            <span class="c1"># More specifically, the target shape for self.c is (k, m, ...),</span>
            <span class="c1"># and axis !=0 means that we have c.shape (..., k, m, ...)</span>
            <span class="c1">#                                               ^</span>
            <span class="c1">#                                              axis</span>
            <span class="c1"># So we roll two of them.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be 1-dimensional&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;at least 2 breakpoints are needed&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;c must have at least 2 dimensions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;polynomial must be at least of order 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;number of coefficients != len(x)-1&quot;</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` must be strictly increasing or decreasing.&quot;</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span> \
               <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">complex_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">float_</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">construct_fast</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the piecewise polynomial without making checks.</span>

<span class="sd">        Takes the same parameters as the constructor. Input arguments</span>
<span class="sd">        `c` and `x` must be arrays of the correct shape and type.  The</span>
<span class="sd">        `c` array can only be of dtypes float and complex, and `x`</span>
<span class="sd">        array must have dtype float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="n">extrapolate</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_ensure_c_contiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        c and x may be modified by the user. The Cython code expects</span>
<span class="sd">        that they are C contiguous.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add additional breakpoints and coefficients to the polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : ndarray, size (k, m, ...)</span>
<span class="sd">            Additional coefficients for polynomials in intervals. Note that</span>
<span class="sd">            the first additional interval will be formed using one of the</span>
<span class="sd">            `self.x` end points.</span>
<span class="sd">        x : ndarray, size (m,)</span>
<span class="sd">            Additional breakpoints. Must be sorted in the same order as</span>
<span class="sd">            `self.x` and either to the right or to the left of the current</span>
<span class="sd">            breakpoints.</span>
<span class="sd">        right</span>
<span class="sd">            Deprecated argument. Has no effect.</span>

<span class="sd">            .. deprecated:: 0.19</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`right` is deprecated and will be removed.&quot;</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid dimensions for c&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid dimensions for x&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and c have incompatible sizes&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="ow">or</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;c and self.c have incompatible shapes&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is not sorted.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is in the different order &quot;</span>
                                 <span class="s2">&quot;than `self.x`.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;append&#39;</span>
            <span class="k">elif</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;prepend&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is neither on the left or on the right &quot;</span>
                                 <span class="s2">&quot;from `self.x`.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is in the different order &quot;</span>
                                 <span class="s2">&quot;than `self.x`.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;append&#39;</span>
            <span class="k">elif</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;prepend&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is neither on the left or on the right &quot;</span>
                                 <span class="s2">&quot;from `self.x`.&quot;</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dtype</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">k2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span>
                      <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;append&#39;</span><span class="p">:</span>
            <span class="n">c2</span><span class="p">[</span><span class="n">k2</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
            <span class="n">c2</span><span class="p">[</span><span class="n">k2</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;prepend&#39;</span><span class="p">:</span>
            <span class="n">c2</span><span class="p">[</span><span class="n">k2</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="p">:</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="n">c2</span><span class="p">[</span><span class="n">k2</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c2</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the piecewise polynomial or its derivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Points to evaluate the interpolant at.</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of derivative to evaluate. Must be non-negative.</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used.</span>
<span class="sd">            If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : array_like</span>
<span class="sd">            Interpolated values. Shape is determined by replacing</span>
<span class="sd">            the interpolation axis in the original array with the shape of x.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Derivatives are evaluated piecewise for each polynomial</span>
<span class="sd">        segment, even if the polynomial is not differentiable at the</span>
<span class="sd">        breakpoints. The polynomial intervals are considered half-open,</span>
<span class="sd">        ``[a, b)``, except for the last interval which is closed</span>
<span class="sd">        ``[a, b]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x_shape</span><span class="p">,</span> <span class="n">x_ndim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>

        <span class="c1"># With periodic extrapolation we map x to the segment</span>
        <span class="c1"># [self.x[0], self.x[-1]].</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x_shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># transpose to move the calculated values to the interpolation axis</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">x_ndim</span><span class="p">:</span><span class="n">x_ndim</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[:</span><span class="n">x_ndim</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="n">x_ndim</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">:]</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>


<span class="k">class</span> <span class="nc">PPoly</span><span class="p">(</span><span class="n">_PPolyBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Piecewise polynomial in terms of coefficients and breakpoints</span>

<span class="sd">    The polynomial between ``x[i]`` and ``x[i + 1]`` is written in the</span>
<span class="sd">    local power basis::</span>

<span class="sd">        S = sum(c[m, i] * (xp - x[i])**(k-m) for m in range(k+1))</span>

<span class="sd">    where ``k`` is the degree of the polynomial.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    c : ndarray, shape (k, m, ...)</span>
<span class="sd">        Polynomial coefficients, order `k` and `m` intervals</span>
<span class="sd">    x : ndarray, shape (m+1,)</span>
<span class="sd">        Polynomial breakpoints. Must be sorted in either increasing or</span>
<span class="sd">        decreasing order.</span>
<span class="sd">    extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">        If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">        based on first and last intervals, or to return NaNs. If &#39;periodic&#39;,</span>
<span class="sd">        periodic extrapolation is used. Default is True.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Interpolation axis. Default is zero.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Breakpoints.</span>
<span class="sd">    c : ndarray</span>
<span class="sd">        Coefficients of the polynomials. They are reshaped</span>
<span class="sd">        to a 3-dimensional array with the last dimension representing</span>
<span class="sd">        the trailing dimensions of the original coefficient array.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Interpolation axis.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>
<span class="sd">    derivative</span>
<span class="sd">    antiderivative</span>
<span class="sd">    integrate</span>
<span class="sd">    solve</span>
<span class="sd">    roots</span>
<span class="sd">    extend</span>
<span class="sd">    from_spline</span>
<span class="sd">    from_bernstein_basis</span>
<span class="sd">    construct_fast</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    BPoly : piecewise polynomials in the Bernstein basis</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    High-order polynomials in the power basis can be numerically</span>
<span class="sd">    unstable.  Precision problems can start to appear for orders</span>
<span class="sd">    larger than 20-30.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">_ppoly</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">),</span> <span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the derivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of derivative to evaluate. Default is 1, i.e. compute the</span>
<span class="sd">            first derivative. If negative, the antiderivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pp : PPoly</span>
<span class="sd">            Piecewise polynomial of order k2 = k - n representing the derivative</span>
<span class="sd">            of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Derivatives are evaluated piecewise for each polynomial</span>
<span class="sd">        segment, even if the polynomial is not differentiable at the</span>
<span class="sd">        breakpoints. The polynomial intervals are considered half-open,</span>
<span class="sd">        ``[a, b)``, except for the last interval which is closed</span>
<span class="sd">        ``[a, b]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">)</span>

        <span class="c1"># reduce order</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># derivative of order 0 is zero</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># multiply by the correct rising factorials</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">nu</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># construct a compatible polynomial</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">antiderivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the antiderivative.</span>

<span class="sd">        Antiderivative is also the indefinite integral of the function,</span>
<span class="sd">        and derivative is its inverse operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of antiderivative to evaluate. Default is 1, i.e. compute</span>
<span class="sd">            the first integral. If negative, the derivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pp : PPoly</span>
<span class="sd">            Piecewise polynomial of order k2 = k + n representing</span>
<span class="sd">            the antiderivative of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The antiderivative returned by this function is continuous and</span>
<span class="sd">        continuously differentiable to order n-1, up to floating point</span>
<span class="sd">        rounding error.</span>

<span class="sd">        If antiderivative is computed and ``self.extrapolate=&#39;periodic&#39;``,</span>
<span class="sd">        it will be set to False for the returned instance. This is done because</span>
<span class="sd">        the antiderivative is no longer periodic and its correct evaluation</span>
<span class="sd">        outside of the initially given x interval is difficult.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span>
                     <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>

        <span class="c1"># divide by the correct rising factorials</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">nu</span><span class="p">)</span>
        <span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">]</span> <span class="o">/=</span> <span class="n">factor</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># fix continuity of added degrees of freedom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>
        <span class="n">_ppoly</span><span class="o">.</span><span class="n">fix_continuity</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">nu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="c1"># construct a compatible polynomial</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a definite integral over a piecewise polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : float</span>
<span class="sd">            Lower integration bound</span>
<span class="sd">        b : float</span>
<span class="sd">            Upper integration bound</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used.</span>
<span class="sd">            If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ig : array_like</span>
<span class="sd">            Definite integral of the piecewise polynomial over [a, b]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="c1"># Swap integration bounds if needed</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">range_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]),),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>

        <span class="c1"># Compute the integral.</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="c1"># Split the integral into the part over period (can be several</span>
            <span class="c1"># of them) and the remaining part.</span>

            <span class="n">xs</span><span class="p">,</span> <span class="n">xe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">period</span> <span class="o">=</span> <span class="n">xe</span> <span class="o">-</span> <span class="n">xs</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span>
            <span class="n">n_periods</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">period</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n_periods</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">range_int</span><span class="p">)</span>
                <span class="n">range_int</span> <span class="o">*=</span> <span class="n">n_periods</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">range_int</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Map a to [xs, xe], b is always a + left.</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">xs</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">xs</span><span class="p">)</span> <span class="o">%</span> <span class="n">period</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">left</span>

            <span class="c1"># If b &lt;= xe then we need to integrate over [a, b], otherwise</span>
            <span class="c1"># over [a, xe] and from xs to what is remained.</span>
            <span class="n">remainder_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">range_int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">xe</span><span class="p">:</span>
                <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">remainder_int</span><span class="p">)</span>
                <span class="n">range_int</span> <span class="o">+=</span> <span class="n">remainder_int</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">remainder_int</span><span class="p">)</span>
                <span class="n">range_int</span> <span class="o">+=</span> <span class="n">remainder_int</span>

                <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">a</span> <span class="o">-</span> <span class="n">xe</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">remainder_int</span><span class="p">)</span>
                <span class="n">range_int</span> <span class="o">+=</span> <span class="n">remainder_int</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">range_int</span><span class="p">)</span>

        <span class="c1"># Return</span>
        <span class="n">range_int</span> <span class="o">*=</span> <span class="n">sign</span>
        <span class="k">return</span> <span class="n">range_int</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">discontinuity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find real solutions of the the equation ``pp(x) == y``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : float, optional</span>
<span class="sd">            Right-hand side. Default is zero.</span>
<span class="sd">        discontinuity : bool, optional</span>
<span class="sd">            Whether to report sign changes across discontinuities at</span>
<span class="sd">            breakpoints as roots.</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            If bool, determines whether to return roots from the polynomial</span>
<span class="sd">            extrapolated based on first and last intervals, &#39;periodic&#39; works</span>
<span class="sd">            the same as False. If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        roots : ndarray</span>
<span class="sd">            Roots of the polynomial(s).</span>

<span class="sd">            If the PPoly object describes multiple polynomials, the</span>
<span class="sd">            return value is an object array whose each element is an</span>
<span class="sd">            ndarray containing the roots.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This routine works only on real-valued polynomials.</span>

<span class="sd">        If the piecewise polynomial contains sections that are</span>
<span class="sd">        identically zero, the root list will contain the start point</span>
<span class="sd">        of the corresponding interval, followed by a ``nan`` value.</span>

<span class="sd">        If the polynomial is discontinuous across a breakpoint, and</span>
<span class="sd">        there is a sign change across the breakpoint, this is reported</span>
<span class="sd">        if the `discont` parameter is True.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Finding roots of ``[x**2 - 1, (x - 1)**2]`` defined on intervals</span>
<span class="sd">        ``[-2, 1], [1, 2]``:</span>

<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import PPoly</span>
<span class="sd">        &gt;&gt;&gt; pp = PPoly(np.array([[1, -4, 3], [1, 0, 0]]).T, [-2, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; pp.roots()</span>
<span class="sd">        array([-1.,  1.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Root finding is only for &quot;</span>
                             <span class="s2">&quot;real-valued polynomials&quot;</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">_ppoly</span><span class="o">.</span><span class="n">real_roots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">discontinuity</span><span class="p">),</span>
                              <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="c1"># this for-loop is equivalent to ``r2[...] = r``, but that&#39;s broken</span>
            <span class="c1"># in numpy 1.6.0</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">root</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="n">r2</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>

            <span class="k">return</span> <span class="n">r2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">roots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">discontinuity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find real roots of the the piecewise polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        discontinuity : bool, optional</span>
<span class="sd">            Whether to report sign changes across discontinuities at</span>
<span class="sd">            breakpoints as roots.</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            If bool, determines whether to return roots from the polynomial</span>
<span class="sd">            extrapolated based on first and last intervals, &#39;periodic&#39; works</span>
<span class="sd">            the same as False. If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        roots : ndarray</span>
<span class="sd">            Roots of the polynomial(s).</span>

<span class="sd">            If the PPoly object describes multiple polynomials, the</span>
<span class="sd">            return value is an object array whose each element is an</span>
<span class="sd">            ndarray containing the roots.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        PPoly.solve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">discontinuity</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_spline</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tck</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a piecewise polynomial from a spline</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tck</span>
<span class="sd">            A spline, as returned by `splrep` or a BSpline object.</span>
<span class="sd">        extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used. Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tck</span><span class="p">,</span> <span class="n">BSpline</span><span class="p">):</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">tck</span><span class="o">.</span><span class="n">tck</span>
            <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">extrapolate</span> <span class="o">=</span> <span class="n">tck</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">tck</span>

        <span class="n">cvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">fitpack</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tck</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
            <span class="n">cvals</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">y</span><span class="o">/</span><span class="n">spec</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">cvals</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_bernstein_basis</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a piecewise polynomial in the power basis</span>
<span class="sd">        from a polynomial in Bernstein basis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bp : BPoly</span>
<span class="sd">            A Bernstein basis polynomial, as created by BPoly</span>
<span class="sd">        extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used. Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bp</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># polynomial order</span>

        <span class="n">rest</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">bp</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">bp</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">a</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">bp</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="o">-</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">s</span>
                <span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">val</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span><span class="o">+</span><span class="n">rest</span><span class="p">]</span><span class="o">**</span><span class="n">s</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">bp</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">bp</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BPoly</span><span class="p">(</span><span class="n">_PPolyBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Piecewise polynomial in terms of coefficients and breakpoints.</span>

<span class="sd">    The polynomial between ``x[i]`` and ``x[i + 1]`` is written in the</span>
<span class="sd">    Bernstein polynomial basis::</span>

<span class="sd">        S = sum(c[a, i] * b(a, k; x) for a in range(k+1)),</span>

<span class="sd">    where ``k`` is the degree of the polynomial, and::</span>

<span class="sd">        b(a, k; x) = binom(k, a) * t**a * (1 - t)**(k - a),</span>

<span class="sd">    with ``t = (x - x[i]) / (x[i+1] - x[i])`` and ``binom`` is the binomial</span>
<span class="sd">    coefficient.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    c : ndarray, shape (k, m, ...)</span>
<span class="sd">        Polynomial coefficients, order `k` and `m` intervals</span>
<span class="sd">    x : ndarray, shape (m+1,)</span>
<span class="sd">        Polynomial breakpoints. Must be sorted in either increasing or</span>
<span class="sd">        decreasing order.</span>
<span class="sd">    extrapolate : bool, optional</span>
<span class="sd">        If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">        based on first and last intervals, or to return NaNs. If &#39;periodic&#39;,</span>
<span class="sd">        periodic extrapolation is used. Default is True.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Interpolation axis. Default is zero.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Breakpoints.</span>
<span class="sd">    c : ndarray</span>
<span class="sd">        Coefficients of the polynomials. They are reshaped</span>
<span class="sd">        to a 3-dimensional array with the last dimension representing</span>
<span class="sd">        the trailing dimensions of the original coefficient array.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Interpolation axis.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>
<span class="sd">    extend</span>
<span class="sd">    derivative</span>
<span class="sd">    antiderivative</span>
<span class="sd">    integrate</span>
<span class="sd">    construct_fast</span>
<span class="sd">    from_power_basis</span>
<span class="sd">    from_derivatives</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    PPoly : piecewise polynomials in the power basis</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Properties of Bernstein polynomials are well documented in the literature.</span>
<span class="sd">    Here&#39;s a non-exhaustive list:</span>

<span class="sd">    .. [1] http://en.wikipedia.org/wiki/Bernstein_polynomial</span>

<span class="sd">    .. [2] Kenneth I. Joy, Bernstein polynomials,</span>
<span class="sd">      http://www.idav.ucdavis.edu/education/CAGDNotes/Bernstein-Polynomials.pdf</span>

<span class="sd">    .. [3] E. H. Doha, A. H. Bhrawy, and M. A. Saker, Boundary Value Problems,</span>
<span class="sd">         vol 2011, article ID 829546, :doi:`10.1155/2011/829543`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import BPoly</span>
<span class="sd">    &gt;&gt;&gt; x = [0, 1]</span>
<span class="sd">    &gt;&gt;&gt; c = [[1], [2], [3]]</span>
<span class="sd">    &gt;&gt;&gt; bp = BPoly(c, x)</span>

<span class="sd">    This creates a 2nd order polynomial</span>

<span class="sd">    .. math::</span>

<span class="sd">        B(x) = 1 \\times b_{0, 2}(x) + 2 \\times b_{1, 2}(x) + 3 \\times b_{2, 2}(x) \\\\</span>
<span class="sd">             = 1 \\times (1-x)^2 + 2 \\times 2 x (1 - x) + 3 \\times x^2</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">_ppoly</span><span class="o">.</span><span class="n">evaluate_bernstein</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">),</span> <span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the derivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of derivative to evaluate. Default is 1, i.e. compute the</span>
<span class="sd">            first derivative. If negative, the antiderivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bp : BPoly</span>
<span class="sd">            Piecewise polynomial of order k - nu representing the derivative of</span>
<span class="sd">            this polynomial.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nu</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nu</span><span class="p">):</span>
                <span class="n">bp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">derivative</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">bp</span>

        <span class="c1"># reduce order</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For a polynomial</span>
            <span class="c1">#    B(x) = \sum_{a=0}^{k} c_a b_{a, k}(x),</span>
            <span class="c1"># we use the fact that</span>
            <span class="c1">#   b&#39;_{a, k} = k ( b_{a-1, k-1} - b_{a, k-1} ),</span>
            <span class="c1"># which leads to</span>
            <span class="c1">#   B&#39;(x) = \sum_{a=0}^{k-1} (c_{a+1} - c_a) b_{a, k-1}</span>
            <span class="c1">#</span>
            <span class="c1"># finally, for an interval [y, y + dy] with dy != 1,</span>
            <span class="c1"># we need to correct for an extra power of dy</span>

            <span class="n">rest</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)[(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span><span class="o">+</span><span class="n">rest</span><span class="p">]</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx</span>

        <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># derivative of order 0 is zero</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># construct a compatible polynomial</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">antiderivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the antiderivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of antiderivative to evaluate. Default is 1, i.e. compute</span>
<span class="sd">            the first integral. If negative, the derivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bp : BPoly</span>
<span class="sd">            Piecewise polynomial of order k + nu representing the</span>
<span class="sd">            antiderivative of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If antiderivative is computed and ``self.extrapolate=&#39;periodic&#39;``,</span>
<span class="sd">        it will be set to False for the returned instance. This is done because</span>
<span class="sd">        the antiderivative is no longer periodic and its correct evaluation</span>
<span class="sd">        outside of the initially given x interval is difficult.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nu</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nu</span><span class="p">):</span>
                <span class="n">bp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">bp</span>

        <span class="c1"># Construct the indefinite integrals on individual intervals</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">c2</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">c2</span> <span class="o">*=</span> <span class="n">delta</span><span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">)]</span>

        <span class="c1"># Now fix continuity: on the very first interval, take the integration</span>
        <span class="c1"># constant to be zero; on an interval [x_j, x_{j+1}) with j&gt;0,</span>
        <span class="c1"># the integration constant is then equal to the jump of the `bp` at x_j.</span>
        <span class="c1"># The latter is given by the coefficient of B_{n+1, n+1}</span>
        <span class="c1"># *on the previous interval* (other B. polynomials are zero at the</span>
        <span class="c1"># breakpoint). Finally, use the fact that BPs form a partition of unity.</span>
        <span class="n">c2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">c2</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a definite integral over a piecewise polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : float</span>
<span class="sd">            Lower integration bound</span>
<span class="sd">        b : float</span>
<span class="sd">            Upper integration bound</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">            and last intervals, or to return NaNs. If &#39;periodic&#39;, periodic</span>
<span class="sd">            extrapolation is used. If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array_like</span>
<span class="sd">            Definite integral of the piecewise polynomial over [a, b]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX: can probably use instead the fact that</span>
        <span class="c1"># \int_0^{1} B_{j, n}(x) \dx = 1/(n+1)</span>
        <span class="n">ib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="c1"># ib.extrapolate shouldn&#39;t be &#39;periodic&#39;, it is converted to</span>
        <span class="c1"># False for &#39;periodic. in antiderivative() call.</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="o">!=</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">ib</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="n">extrapolate</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="c1"># Split the integral into the part over period (can be several</span>
            <span class="c1"># of them) and the remaining part.</span>

            <span class="c1"># For simplicity and clarity convert to a &lt;= b case.</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">xs</span><span class="p">,</span> <span class="n">xe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">period</span> <span class="o">=</span> <span class="n">xe</span> <span class="o">-</span> <span class="n">xs</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span>
            <span class="n">n_periods</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">period</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">n_periods</span> <span class="o">*</span> <span class="p">(</span><span class="n">ib</span><span class="p">(</span><span class="n">xe</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>

            <span class="c1"># Map a and b to [xs, xe].</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">xs</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">xs</span><span class="p">)</span> <span class="o">%</span> <span class="n">period</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">left</span>

            <span class="c1"># If b &lt;= xe then we need to integrate over [a, b], otherwise</span>
            <span class="c1"># over [a, xe] and from xs to what is remained.</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">xe</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">ib</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">ib</span><span class="p">(</span><span class="n">xe</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">ib</span><span class="p">(</span><span class="n">xs</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">a</span> <span class="o">-</span> <span class="n">xe</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ib</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raise_degree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raise_degree</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">_PPolyBase</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="n">extend</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_PPolyBase</span><span class="o">.</span><span class="n">extend</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_power_basis</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a piecewise polynomial in Bernstein basis</span>
<span class="sd">        from a power basis polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pp : PPoly</span>
<span class="sd">            A piecewise polynomial in the power basis</span>
<span class="sd">        extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used. Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>   <span class="c1"># polynomial order</span>

        <span class="n">rest</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">/</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span><span class="o">+</span><span class="n">rest</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_derivatives</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">orders</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a piecewise polynomial in the Bernstein basis,</span>
<span class="sd">        compatible with the specified values and derivatives at breakpoints.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xi : array_like</span>
<span class="sd">            sorted 1D array of x-coordinates</span>
<span class="sd">        yi : array_like or list of array_likes</span>
<span class="sd">            ``yi[i][j]`` is the ``j``-th derivative known at ``xi[i]``</span>
<span class="sd">        orders : None or int or array_like of ints. Default: None.</span>
<span class="sd">            Specifies the degree of local polynomials. If not None, some</span>
<span class="sd">            derivatives are ignored.</span>
<span class="sd">        extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used. Default is True.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``k`` derivatives are specified at a breakpoint ``x``, the</span>
<span class="sd">        constructed polynomial is exactly ``k`` times continuously</span>
<span class="sd">        differentiable at ``x``, unless the ``order`` is provided explicitly.</span>
<span class="sd">        In the latter case, the smoothness of the polynomial at</span>
<span class="sd">        the breakpoint is controlled by the ``order``.</span>

<span class="sd">        Deduces the number of derivatives to match at each end</span>
<span class="sd">        from ``order`` and the number of derivatives available. If</span>
<span class="sd">        possible it uses the same number of derivatives from</span>
<span class="sd">        each end; if the number is odd it tries to take the</span>
<span class="sd">        extra one from y2. In any case if not enough derivatives</span>
<span class="sd">        are available at one end or another it draws enough to</span>
<span class="sd">        make up the total from the other end.</span>

<span class="sd">        If the order is too high and not enough derivatives are available,</span>
<span class="sd">        an exception is raised.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import BPoly</span>
<span class="sd">        &gt;&gt;&gt; BPoly.from_derivatives([0, 1], [[1, 2], [3, 4]])</span>

<span class="sd">        Creates a polynomial `f(x)` of degree 3, defined on `[0, 1]`</span>
<span class="sd">        such that `f(0) = 1, df/dx(0) = 2, f(1) = 3, df/dx(1) = 4`</span>

<span class="sd">        &gt;&gt;&gt; BPoly.from_derivatives([0, 1, 2], [[0, 1], [0], [2]])</span>

<span class="sd">        Creates a piecewise polynomial `f(x)`, such that</span>
<span class="sd">        `f(0) = f(1) = 0`, `f(2) = 2`, and `df/dx(0) = 1`.</span>
<span class="sd">        Based on the number of derivatives provided, the order of the</span>
<span class="sd">        local polynomials is 2 on `[0, 1]` and 1 on `[1, 2]`.</span>
<span class="sd">        Notice that no restriction is imposed on the derivatives at</span>
<span class="sd">        `x = 1` and `x = 2`.</span>

<span class="sd">        Indeed, the explicit form of the polynomial is::</span>

<span class="sd">            f(x) = | x * (1 - x),  0 &lt;= x &lt; 1</span>
<span class="sd">                   | 2 * (x - 1),  1 &lt;= x &lt;= 2</span>

<span class="sd">        So that f&#39;(1-0) = -1 and f&#39;(1+0) = 2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;xi and yi need to have the same length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x coordinates are not in increasing order&quot;</span><span class="p">)</span>

        <span class="c1"># number of intervals</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># global poly order is k-1, local orders are &lt;=k and can vary</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Using a 1D array for y? Please .reshape(-1, 1).&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">orders</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orders</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orders</span><span class="p">,</span> <span class="p">(</span><span class="n">integer_types</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="n">orders</span> <span class="o">=</span> <span class="p">[</span><span class="n">orders</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">orders</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">o</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">orders</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Orders must be positive.&quot;</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">orders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">orders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y1</span><span class="p">))</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">n1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">))</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">n2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">n1</span><span class="o">+</span><span class="n">n2</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
                    <span class="n">mesg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Point </span><span class="si">%g</span><span class="s2"> has </span><span class="si">%d</span><span class="s2"> derivatives, point </span><span class="si">%g</span><span class="s2">&quot;</span>
                            <span class="s2">&quot; has </span><span class="si">%d</span><span class="s2"> derivatives, but order </span><span class="si">%d</span><span class="s2"> requested&quot;</span> <span class="o">%</span> <span class="p">(</span>
                               <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">y1</span><span class="p">),</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">),</span> <span class="n">orders</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">mesg</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">n1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n2</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`order` input incompatible with&quot;</span>
                                     <span class="s2">&quot; length y1 or y2.&quot;</span><span class="p">)</span>

            <span class="n">b</span> <span class="o">=</span> <span class="n">BPoly</span><span class="o">.</span><span class="n">_construct_from_derivatives</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                                  <span class="n">y1</span><span class="p">[:</span><span class="n">n1</span><span class="p">],</span> <span class="n">y2</span><span class="p">[:</span><span class="n">n2</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">BPoly</span><span class="o">.</span><span class="n">_raise_degree</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
            <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">xi</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_construct_from_derivatives</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">yb</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the coefficients of a polynomial in the Bernstein basis</span>
<span class="sd">        given the values and derivatives at the edges.</span>

<span class="sd">        Return the coefficients of a polynomial in the Bernstein basis</span>
<span class="sd">        defined on `[xa, xb]` and having the values and derivatives at the</span>
<span class="sd">        endpoints ``xa`` and ``xb`` as specified by ``ya`` and ``yb``.</span>
<span class="sd">        The polynomial constructed is of the minimal possible degree, i.e.,</span>
<span class="sd">        if the lengths of ``ya`` and ``yb`` are ``na`` and ``nb``, the degree</span>
<span class="sd">        of the polynomial is ``na + nb - 1``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xa : float</span>
<span class="sd">            Left-hand end point of the interval</span>
<span class="sd">        xb : float</span>
<span class="sd">            Right-hand end point of the interval</span>
<span class="sd">        ya : array_like</span>
<span class="sd">            Derivatives at ``xa``. ``ya[0]`` is the value of the function, and</span>
<span class="sd">            ``ya[i]`` for ``i &gt; 0`` is the value of the ``i``-th derivative.</span>
<span class="sd">        yb : array_like</span>
<span class="sd">            Derivatives at ``xb``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            coefficient array of a polynomial having specified derivatives</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This uses several facts from life of Bernstein basis functions.</span>
<span class="sd">        First of all,</span>

<span class="sd">            .. math:: b&#39;_{a, n} = n (b_{a-1, n-1} - b_{a, n-1})</span>

<span class="sd">        If B(x) is a linear combination of the form</span>

<span class="sd">            .. math:: B(x) = \sum_{a=0}^{n} c_a b_{a, n},</span>

<span class="sd">        then :math: B&#39;(x) = n \sum_{a=0}^{n-1} (c_{a+1} - c_{a}) b_{a, n-1}.</span>
<span class="sd">        Iterating the latter one, one finds for the q-th derivative</span>

<span class="sd">            .. math:: B^{q}(x) = n!/(n-q)! \sum_{a=0}^{n-q} Q_a b_{a, n-q},</span>

<span class="sd">        with</span>

<span class="sd">          .. math:: Q_a = \sum_{j=0}^{q} (-)^{j+q} comb(q, j) c_{j+a}</span>

<span class="sd">        This way, only `a=0` contributes to :math: `B^{q}(x = xa)`, and</span>
<span class="sd">        `c_q` are found one by one by iterating `q = 0, ..., na`.</span>

<span class="sd">        At `x = xb` it&#39;s the same with `a = n - q`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ya</span><span class="p">,</span> <span class="n">yb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ya</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ya</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">yb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;ya and yb have incompatible dimensions.&#39;</span><span class="p">)</span>

        <span class="n">dta</span><span class="p">,</span> <span class="n">dtb</span> <span class="o">=</span> <span class="n">ya</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">yb</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span> <span class="ow">or</span>
               <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtb</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)):</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float_</span>

        <span class="n">na</span><span class="p">,</span> <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ya</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">yb</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">na</span> <span class="o">+</span> <span class="n">nb</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">na</span><span class="o">+</span><span class="n">nb</span><span class="p">,)</span> <span class="o">+</span> <span class="n">ya</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

        <span class="c1"># compute coefficients of a polynomial degree na+nb-1</span>
        <span class="c1"># walk left-to-right</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">na</span><span class="p">):</span>
            <span class="n">c</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">ya</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">/</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xb</span> <span class="o">-</span> <span class="n">xa</span><span class="p">)</span><span class="o">**</span><span class="n">q</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
                <span class="n">c</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="c1"># now walk right-to-left</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb</span><span class="p">):</span>
            <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yb</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">/</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">q</span> <span class="o">*</span> <span class="p">(</span><span class="n">xb</span> <span class="o">-</span> <span class="n">xa</span><span class="p">)</span><span class="o">**</span><span class="n">q</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
                <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="n">q</span><span class="o">+</span><span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">c</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_raise_degree</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Raise a degree of a polynomial in the Bernstein basis.</span>

<span class="sd">        Given the coefficients of a polynomial degree `k`, return (the</span>
<span class="sd">        coefficients of) the equivalent polynomial of degree `k+d`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : array_like</span>
<span class="sd">            coefficient array, 1D</span>
<span class="sd">        d : integer</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            coefficient array, 1D array of length `c.shape[0] + d`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This uses the fact that a Bernstein polynomial `b_{a, k}` can be</span>
<span class="sd">        identically represented as a linear combination of polynomials of</span>
<span class="sd">        a higher degree `k+d`:</span>

<span class="sd">            .. math:: b_{a, k} = comb(k, a) \sum_{j=0}^{d} b_{a+j, k+d} \</span>
<span class="sd">                                 comb(d, j) / comb(k+d, a+j)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>


<span class="k">class</span> <span class="nc">NdPPoly</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Piecewise tensor product polynomial</span>

<span class="sd">    The value at point `xp = (x&#39;, y&#39;, z&#39;, ...)` is evaluated by first</span>
<span class="sd">    computing the interval indices `i` such that::</span>

<span class="sd">        x[0][i[0]] &lt;= x&#39; &lt; x[0][i[0]+1]</span>
<span class="sd">        x[1][i[1]] &lt;= y&#39; &lt; x[1][i[1]+1]</span>
<span class="sd">        ...</span>

<span class="sd">    and then computing::</span>

<span class="sd">        S = sum(c[k0-m0-1,...,kn-mn-1,i[0],...,i[n]]</span>
<span class="sd">                * (xp[0] - x[0][i[0]])**m0</span>
<span class="sd">                * ...</span>
<span class="sd">                * (xp[n] - x[n][i[n]])**mn</span>
<span class="sd">                for m0 in range(k[0]+1)</span>
<span class="sd">                ...</span>
<span class="sd">                for mn in range(k[n]+1))</span>

<span class="sd">    where ``k[j]`` is the degree of the polynomial in dimension j. This</span>
<span class="sd">    representation is the piecewise multivariate power basis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    c : ndarray, shape (k0, ..., kn, m0, ..., mn, ...)</span>
<span class="sd">        Polynomial coefficients, with polynomial order `kj` and</span>
<span class="sd">        `mj+1` intervals for each dimension `j`.</span>
<span class="sd">    x : ndim-tuple of ndarrays, shapes (mj+1,)</span>
<span class="sd">        Polynomial breakpoints for each dimension. These must be</span>
<span class="sd">        sorted in increasing order.</span>
<span class="sd">    extrapolate : bool, optional</span>
<span class="sd">        Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">        and last intervals, or to return NaNs. Default: True.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    x : tuple of ndarrays</span>
<span class="sd">        Breakpoints.</span>
<span class="sd">    c : ndarray</span>
<span class="sd">        Coefficients of the polynomials.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>
<span class="sd">    construct_fast</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    PPoly : piecewise polynomials in 1D</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    High-order polynomials in the power basis can be numerically</span>
<span class="sd">    unstable.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x arrays must all be 1-dimensional&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x arrays must all contain at least 2 points&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;c must have at least 2*len(x) dimensions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x-coordinates are not in increasing order&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ndim</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and c do not agree on the number of intervals&quot;</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">construct_fast</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the piecewise polynomial without making checks.</span>

<span class="sd">        Takes the same parameters as the constructor. Input arguments</span>
<span class="sd">        `c` and `x` must be arrays of the correct shape and type.  The</span>
<span class="sd">        `c` array can only be of dtypes float and complex, and `x`</span>
<span class="sd">        array must have dtype float.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="n">extrapolate</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span> \
               <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">complex_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">float_</span>

    <span class="k">def</span> <span class="nf">_ensure_c_contiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the piecewise polynomial or its derivative</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            Points to evaluate the interpolant at.</span>
<span class="sd">        nu : tuple, optional</span>
<span class="sd">            Orders of derivatives to evaluate. Each must be non-negative.</span>
<span class="sd">        extrapolate : bool, optional</span>
<span class="sd">            Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">            and last intervals, or to return NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : array-like</span>
<span class="sd">            Interpolated values. Shape is determined by replacing</span>
<span class="sd">            the interpolation axis in the original array with the shape of x.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Derivatives are evaluated piecewise for each polynomial</span>
<span class="sd">        segment, even if the polynomial is not differentiable at the</span>
<span class="sd">        breakpoints. The polynomial intervals are considered half-open,</span>
<span class="sd">        ``[a, b)``, except for the last interval which is closed</span>
<span class="sd">        ``[a, b]``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">_ndim_coords_from_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x_shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndim</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">nu</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid number of derivative orders nu&quot;</span><span class="p">)</span>

        <span class="n">dim1</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">ndim</span><span class="p">])</span>
        <span class="n">dim2</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ndim</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">])</span>
        <span class="n">dim3</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">:])</span>
        <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">ndim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>

        <span class="n">_ppoly</span><span class="o">.</span><span class="n">evaluate_nd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">dim3</span><span class="p">),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
                           <span class="n">ks</span><span class="p">,</span>
                           <span class="n">x</span><span class="p">,</span>
                           <span class="n">nu</span><span class="p">,</span>
                           <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">),</span>
                           <span class="n">out</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">_derivative_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute 1D derivative along a selected dimension in-place</span>
<span class="sd">        May result to non-contiguous c array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_antiderivative_inplace</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">%</span> <span class="n">ndim</span>

        <span class="c1"># reduce order</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># noop</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="n">nu</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># derivative of order 0 is zero</span>
            <span class="n">shp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">shp</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># multiply by the correct rising factorials</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">nu</span><span class="p">)</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">c2</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c2</span>

    <span class="k">def</span> <span class="nf">_antiderivative_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute 1D antiderivative along a selected dimension</span>
<span class="sd">        May result to non-contiguous c array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derivative_inplace</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">%</span> <span class="n">ndim</span>

        <span class="n">perm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">perm</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>

        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nu</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                     <span class="n">dtype</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">c2</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>

        <span class="c1"># divide by the correct rising factorials</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">nu</span><span class="p">)</span>
        <span class="n">c2</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">]</span> <span class="o">/=</span> <span class="n">factor</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># fix continuity of added degrees of freedom</span>
        <span class="n">perm2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">perm2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">perm2</span><span class="p">[</span><span class="n">ndim</span><span class="o">+</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm2</span><span class="p">[</span><span class="n">ndim</span><span class="o">+</span><span class="n">axis</span><span class="p">],</span> <span class="n">perm2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">perm2</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_ppoly</span><span class="o">.</span><span class="n">fix_continuity</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">nu</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">perm2</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>

        <span class="c1"># Done</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c2</span>

    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the derivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : ndim-tuple of int</span>
<span class="sd">            Order of derivatives to evaluate for each dimension.</span>
<span class="sd">            If negative, the antiderivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pp : NdPPoly</span>
<span class="sd">            Piecewise polynomial of orders (k[0] - nu[0], ..., k[n] - nu[n])</span>
<span class="sd">            representing the derivative of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Derivatives are evaluated piecewise for each polynomial</span>
<span class="sd">        segment, even if the polynomial is not differentiable at the</span>
<span class="sd">        breakpoints. The polynomial intervals in each dimension are</span>
<span class="sd">        considered half-open, ``[a, b)``, except for the last interval</span>
<span class="sd">        which is closed ``[a, b]``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nu</span><span class="p">):</span>
            <span class="n">p</span><span class="o">.</span><span class="n">_derivative_inplace</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">antiderivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the antiderivative.</span>

<span class="sd">        Antiderivative is also the indefinite integral of the function,</span>
<span class="sd">        and derivative is its inverse operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : ndim-tuple of int</span>
<span class="sd">            Order of derivatives to evaluate for each dimension.</span>
<span class="sd">            If negative, the derivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pp : PPoly</span>
<span class="sd">            Piecewise polynomial of order k2 = k + n representing</span>
<span class="sd">            the antiderivative of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The antiderivative returned by this function is continuous and</span>
<span class="sd">        continuously differentiable to order n-1, up to floating point</span>
<span class="sd">        rounding error.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nu</span><span class="p">):</span>
            <span class="n">p</span><span class="o">.</span><span class="n">_antiderivative_inplace</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">integrate_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute NdPPoly representation for one dimensional definite integral</span>

<span class="sd">        The result is a piecewise polynomial representing the integral:</span>

<span class="sd">        .. math::</span>

<span class="sd">           p(y, z, ...) = \int_a^b dx\, p(x, y, z, ...)</span>

<span class="sd">        where the dimension integrated over is specified with the</span>
<span class="sd">        `axis` parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a, b : float</span>
<span class="sd">            Lower and upper bound for integration.</span>
<span class="sd">        axis : int</span>
<span class="sd">            Dimension over which to compute the 1D integrals</span>
<span class="sd">        extrapolate : bool, optional</span>
<span class="sd">            Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">            and last intervals, or to return NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ig : NdPPoly or array-like</span>
<span class="sd">            Definite integral of the piecewise polynomial over [a, b].</span>
<span class="sd">            If the polynomial was 1-dimensional, an array is returned,</span>
<span class="sd">            otherwise, an NdPPoly object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">%</span> <span class="n">ndim</span>

        <span class="c1"># reuse 1D integration routines</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="n">swap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">swap</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">swap</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">swap</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">swap</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">swap</span><span class="p">[</span><span class="n">ndim</span> <span class="o">+</span> <span class="n">axis</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">swap</span><span class="p">[</span><span class="n">ndim</span> <span class="o">+</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">swap</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">PPoly</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span>
                                 <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="c1"># Construct result</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ranges</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a definite integral over a piecewise polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ranges : ndim-tuple of 2-tuples float</span>
<span class="sd">            Sequence of lower and upper bounds for each dimension,</span>
<span class="sd">            ``[(a[0], b[0]), ..., (a[ndim-1], b[ndim-1])]``</span>
<span class="sd">        extrapolate : bool, optional</span>
<span class="sd">            Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">            and last intervals, or to return NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ig : array_like</span>
<span class="sd">            Definite integral of the piecewise polynomial over</span>
<span class="sd">            [a[0], b[0]] x ... x [a[ndim-1], b[ndim-1]]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Range not a sequence of correct length&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>

        <span class="c1"># Reuse 1D integration routine</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ranges</span><span class="p">):</span>
            <span class="n">swap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="n">swap</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">swap</span><span class="p">[</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">n</span><span class="p">])</span>
            <span class="k">del</span> <span class="n">swap</span><span class="p">[</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">swap</span><span class="p">)</span>

            <span class="n">p</span> <span class="o">=</span> <span class="n">PPoly</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>

        <span class="k">return</span> <span class="n">c</span>


<span class="k">class</span> <span class="nc">RegularGridInterpolator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolation on a regular grid in arbitrary dimensions</span>

<span class="sd">    The data must be defined on a regular grid; the grid spacing however may be</span>
<span class="sd">    uneven.  Linear and nearest-neighbour interpolation are supported. After</span>
<span class="sd">    setting up the interpolator object, the interpolation method (*linear* or</span>
<span class="sd">    *nearest*) may be chosen at each evaluation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : tuple of ndarray of float, with shapes (m1, ), ..., (mn, )</span>
<span class="sd">        The points defining the regular grid in n dimensions.</span>

<span class="sd">    values : array_like, shape (m1, ..., mn, ...)</span>
<span class="sd">        The data on the regular grid in n dimensions.</span>

<span class="sd">    method : str, optional</span>
<span class="sd">        The method of interpolation to perform. Supported are &quot;linear&quot; and</span>
<span class="sd">        &quot;nearest&quot;. This parameter will become the default for the object&#39;s</span>
<span class="sd">        ``__call__`` method. Default is &quot;linear&quot;.</span>

<span class="sd">    bounds_error : bool, optional</span>
<span class="sd">        If True, when interpolated values are requested outside of the</span>
<span class="sd">        domain of the input data, a ValueError is raised.</span>
<span class="sd">        If False, then `fill_value` is used.</span>

<span class="sd">    fill_value : number, optional</span>
<span class="sd">        If provided, the value to use for points outside of the</span>
<span class="sd">        interpolation domain. If None, values outside</span>
<span class="sd">        the domain are extrapolated.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Contrary to LinearNDInterpolator and NearestNDInterpolator, this class</span>
<span class="sd">    avoids expensive triangulation of the input data by taking advantage of the</span>
<span class="sd">    regular grid structure.</span>

<span class="sd">    .. versionadded:: 0.14</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Evaluate a simple example function on the points of a 3D grid:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import RegularGridInterpolator</span>
<span class="sd">    &gt;&gt;&gt; def f(x, y, z):</span>
<span class="sd">    ...     return 2 * x**3 + 3 * y**2 - z</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(1, 4, 11)</span>
<span class="sd">    &gt;&gt;&gt; y = np.linspace(4, 7, 22)</span>
<span class="sd">    &gt;&gt;&gt; z = np.linspace(7, 9, 33)</span>
<span class="sd">    &gt;&gt;&gt; data = f(*np.meshgrid(x, y, z, indexing=&#39;ij&#39;, sparse=True))</span>

<span class="sd">    ``data`` is now a 3D array with ``data[i,j,k] = f(x[i], y[j], z[k])``.</span>
<span class="sd">    Next, define an interpolating function from this data:</span>

<span class="sd">    &gt;&gt;&gt; my_interpolating_function = RegularGridInterpolator((x, y, z), data)</span>

<span class="sd">    Evaluate the interpolating function at the two points</span>
<span class="sd">    ``(x,y,z) = (2.1, 6.2, 8.3)`` and ``(3.3, 5.2, 7.1)``:</span>

<span class="sd">    &gt;&gt;&gt; pts = np.array([[2.1, 6.2, 8.3], [3.3, 5.2, 7.1]])</span>
<span class="sd">    &gt;&gt;&gt; my_interpolating_function(pts)</span>
<span class="sd">    array([ 125.80469388,  146.30069388])</span>

<span class="sd">    which is indeed a close approximation to</span>
<span class="sd">    ``[f(2.1, 6.2, 8.3), f(3.3, 5.2, 7.1)]``.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    NearestNDInterpolator : Nearest neighbour interpolation on unstructured</span>
<span class="sd">                            data in N dimensions</span>

<span class="sd">    LinearNDInterpolator : Piecewise linear interpolant on unstructured data</span>
<span class="sd">                           in N dimensions</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Python package *regulargrid* by Johannes Buchner, see</span>
<span class="sd">           https://pypi.python.org/pypi/regulargrid/</span>
<span class="sd">    .. [2] Trilinear interpolation. (2013, January 17). In Wikipedia, The Free</span>
<span class="sd">           Encyclopedia. Retrieved 27 Feb 2013 01:28.</span>
<span class="sd">           http://en.wikipedia.org/w/index.php?title=Trilinear_interpolation&amp;oldid=533448871</span>
<span class="sd">    .. [3] Weiser, Alan, and Sergio E. Zarantonello. &quot;A note on piecewise linear</span>
<span class="sd">           and multilinear table interpolation in many dimensions.&quot; MATH.</span>
<span class="sd">           COMPUT. 50.181 (1988): 189-196.</span>
<span class="sd">           http://www.ams.org/journals/mcom/1988-50-181/S0025-5718-1988-0917826-0/S0025-5718-1988-0917826-0.pdf</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># this class is based on code originally programmed by Johannes Buchner,</span>
    <span class="c1"># see https://github.com/JohannesBuchner/regulargrid</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Method &#39;</span><span class="si">%s</span><span class="s2">&#39; is not defined&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="n">bounds_error</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">):</span>
            <span class="c1"># allow reasonable duck-typed values</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">%d</span><span class="s2"> point arrays, but values has </span><span class="si">%d</span><span class="s2"> &quot;</span>
                             <span class="s2">&quot;dimensions&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;astype&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill_value_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">fill_value_dtype</span><span class="p">,</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;same_kind&#39;</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill_value must be either &#39;None&#39; or &quot;</span>
                                 <span class="s2">&quot;of a type compatible with values&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The points in dimension </span><span class="si">%d</span><span class="s2"> must be strictly &quot;</span>
                                 <span class="s2">&quot;ascending&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The points in dimension </span><span class="si">%d</span><span class="s2"> must be &quot;</span>
                                 <span class="s2">&quot;1-dimensional&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">%d</span><span class="s2"> points and </span><span class="si">%d</span><span class="s2"> values in &quot;</span>
                                 <span class="s2">&quot;dimension </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolation at coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xi : ndarray of shape (..., ndim)</span>
<span class="sd">            The coordinates to sample the gridded data at</span>

<span class="sd">        method : str</span>
<span class="sd">            The method of interpolation to perform. Supported are &quot;linear&quot; and</span>
<span class="sd">            &quot;nearest&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">method</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Method &#39;</span><span class="si">%s</span><span class="s2">&#39; is not defined&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">_ndim_coords_from_arrays</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="n">ndim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The requested sample points xi have dimension &quot;</span>
                             <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">, but this RegularGridInterpolator has &quot;</span>
                             <span class="s2">&quot;dimension </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ndim</span><span class="p">))</span>

        <span class="n">xi_shape</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">xi_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">),</span>
                                      <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One of the requested xi is out of bounds &quot;</span>
                                     <span class="s2">&quot;in dimension </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>

        <span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">,</span> <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_indices</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_linear</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span>
                                           <span class="n">norm_distances</span><span class="p">,</span>
                                           <span class="n">out_of_bounds</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_nearest</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span>
                                            <span class="n">norm_distances</span><span class="p">,</span>
                                            <span class="n">out_of_bounds</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">out_of_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xi_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ndim</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">_evaluate_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">,</span> <span class="n">out_of_bounds</span><span class="p">):</span>
        <span class="c1"># slice for broadcasting over trailing dimensions in self.values</span>
        <span class="n">vslice</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>

        <span class="c1"># find relevant values</span>
        <span class="c1"># each i and i+1 represents a edge</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">])</span>
        <span class="n">values</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">for</span> <span class="n">edge_indices</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">edge_indices</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">):</span>
                <span class="n">weight</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ei</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">yi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">edge_indices</span><span class="p">])</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">vslice</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">_evaluate_nearest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">,</span> <span class="n">out_of_bounds</span><span class="p">):</span>
        <span class="n">idx_res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">):</span>
            <span class="n">idx_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yi</span> <span class="o">&lt;=</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">idx_res</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_find_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">):</span>
        <span class="c1"># find relevant edges between which xi are situated</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># compute distance to lower edge in unity units</span>
        <span class="n">norm_distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># check for out of bounds xi</span>
        <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="c1"># iterate through dimensions</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">grid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">i</span><span class="p">[</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">i</span><span class="p">[</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">norm_distances</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span>
                                  <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span><span class="p">:</span>
                <span class="n">out_of_bounds</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">out_of_bounds</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">,</span> <span class="n">out_of_bounds</span>


<span class="k">def</span> <span class="nf">interpn</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multidimensional interpolation on regular grids.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : tuple of ndarray of float, with shapes (m1, ), ..., (mn, )</span>
<span class="sd">        The points defining the regular grid in n dimensions.</span>

<span class="sd">    values : array_like, shape (m1, ..., mn, ...)</span>
<span class="sd">        The data on the regular grid in n dimensions.</span>

<span class="sd">    xi : ndarray of shape (..., ndim)</span>
<span class="sd">        The coordinates to sample the gridded data at</span>

<span class="sd">    method : str, optional</span>
<span class="sd">        The method of interpolation to perform. Supported are &quot;linear&quot; and</span>
<span class="sd">        &quot;nearest&quot;, and &quot;splinef2d&quot;. &quot;splinef2d&quot; is only supported for</span>
<span class="sd">        2-dimensional data.</span>

<span class="sd">    bounds_error : bool, optional</span>
<span class="sd">        If True, when interpolated values are requested outside of the</span>
<span class="sd">        domain of the input data, a ValueError is raised.</span>
<span class="sd">        If False, then `fill_value` is used.</span>

<span class="sd">    fill_value : number, optional</span>
<span class="sd">        If provided, the value to use for points outside of the</span>
<span class="sd">        interpolation domain. If None, values outside</span>
<span class="sd">        the domain are extrapolated.  Extrapolation is not supported by method</span>
<span class="sd">        &quot;splinef2d&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values_x : ndarray, shape xi.shape[:-1] + values.shape[ndim:]</span>
<span class="sd">        Interpolated values at input coordinates.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    .. versionadded:: 0.14</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    NearestNDInterpolator : Nearest neighbour interpolation on unstructured</span>
<span class="sd">                            data in N dimensions</span>

<span class="sd">    LinearNDInterpolator : Piecewise linear interpolant on unstructured data</span>
<span class="sd">                           in N dimensions</span>

<span class="sd">    RegularGridInterpolator : Linear and nearest-neighbor Interpolation on a</span>
<span class="sd">                              regular grid in arbitrary dimensions</span>

<span class="sd">    RectBivariateSpline : Bivariate spline approximation over a rectangular mesh</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># sanity check &#39;method&#39; kwarg</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;splinef2d&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;interpn only understands the methods &#39;linear&#39;, &quot;</span>
                         <span class="s2">&quot;&#39;nearest&#39;, and &#39;splinef2d&#39;. You provided </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span>
                         <span class="n">method</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;splinef2d&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The method spline2fd can only be used for &quot;</span>
                         <span class="s2">&quot;2-dimensional input data&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">bounds_error</span> <span class="ow">and</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;splinef2d&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The method spline2fd does not support extrapolation.&quot;</span><span class="p">)</span>

    <span class="c1"># sanity check consistency of input dimensions</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">%d</span><span class="s2"> point arrays, but values has </span><span class="si">%d</span><span class="s2"> &quot;</span>
                         <span class="s2">&quot;dimensions&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="n">ndim</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndim</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;splinef2d&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The method spline2fd can only be used for &quot;</span>
                         <span class="s2">&quot;scalar data with one point per coordinate&quot;</span><span class="p">)</span>

    <span class="c1"># sanity check input grid</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The points in dimension </span><span class="si">%d</span><span class="s2"> must be strictly &quot;</span>
                             <span class="s2">&quot;ascending&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The points in dimension </span><span class="si">%d</span><span class="s2"> must be &quot;</span>
                             <span class="s2">&quot;1-dimensional&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">%d</span><span class="s2"> points and </span><span class="si">%d</span><span class="s2"> values in &quot;</span>
                             <span class="s2">&quot;dimension </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">))</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">])</span>

    <span class="c1"># sanity check requested xi</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">_ndim_coords_from_arrays</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The requested sample points xi have dimension &quot;</span>
                         <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">, but this RegularGridInterpolator has &quot;</span>
                         <span class="s2">&quot;dimension </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bounds_error</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">),</span>
                                               <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One of the requested xi is out of bounds &quot;</span>
                             <span class="s2">&quot;in dimension </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>

    <span class="c1"># perform interpolation</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">RegularGridInterpolator</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                                         <span class="n">bounds_error</span><span class="o">=</span><span class="n">bounds_error</span><span class="p">,</span>
                                         <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interp</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">RegularGridInterpolator</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                                         <span class="n">bounds_error</span><span class="o">=</span><span class="n">bounds_error</span><span class="p">,</span>
                                         <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interp</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;splinef2d&quot;</span><span class="p">:</span>
        <span class="n">xi_shape</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># RectBivariateSpline doesn&#39;t support fill_value; we need to wrap here</span>
        <span class="n">idx_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">xi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                           <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">xi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># make a copy of values for RectBivariateSpline</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">RectBivariateSpline</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">values</span><span class="p">[:])</span>
        <span class="n">result</span><span class="p">[</span><span class="n">idx_valid</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">idx_valid</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">xi</span><span class="p">[</span><span class="n">idx_valid</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">idx_valid</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fill_value</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xi_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>


<span class="c1"># backward compatibility wrapper</span>
<span class="k">class</span> <span class="nc">ppform</span><span class="p">(</span><span class="n">PPoly</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deprecated piecewise polynomial class.</span>

<span class="sd">    New code should use the `PPoly` class instead.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">breaks</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;ppform is deprecated -- use PPoly instead&quot;</span><span class="p">,</span>
                      <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">breaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">breaks</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">breaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">breaks</span><span class="p">)</span>

        <span class="n">PPoly</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">breaks</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">breaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">breaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">breaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PPoly</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">PPoly</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">~</span><span class="p">((</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">))]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromspline</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="n">cvals</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="c1"># Note: this spline representation is incompatible with FITPACK</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">sivals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">fact</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">_fitpack</span><span class="o">.</span><span class="n">_bspleval</span><span class="p">(</span><span class="n">xk</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">xk</span><span class="p">,</span> <span class="n">cvals</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">/=</span> <span class="n">fact</span>
            <span class="n">sivals</span><span class="p">[</span><span class="n">order</span><span class="o">-</span><span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sivals</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">fill</span><span class="p">)</span>


<span class="c1"># The 3 private functions below can be called by splmake().</span>


<span class="k">def</span> <span class="nf">_dot0</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Similar to numpy.dot, but sum over last axis of a and 1st axis of b&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_find_smoothest</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># construct Bmatrix, and Jmatrix</span>
    <span class="c1"># e = J*c</span>
    <span class="c1"># minimize norm(e,2) given B*c=yk</span>
    <span class="c1"># if desired B can be given</span>
    <span class="c1"># conds is ignored</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xk</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">order</span>
    <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">_fitpack</span><span class="o">.</span><span class="n">_bsplmat</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">xk</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">_fitpack</span><span class="o">.</span><span class="n">_bspldismat</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">xk</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">K</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">V2</span> <span class="o">=</span> <span class="n">vh</span><span class="p">[</span><span class="o">-</span><span class="n">ind</span><span class="p">:,:]</span><span class="o">.</span><span class="n">T</span>
    <span class="n">V1</span> <span class="o">=</span> <span class="n">vh</span><span class="p">[:</span><span class="o">-</span><span class="n">ind</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">J</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">V2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">V2</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">V2</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="n">K</span><span class="p">)</span> <span class="o">-</span> <span class="n">tmp</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">V1</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">s</span><span class="p">))</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_dot0</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">yk</span><span class="p">)</span>


<span class="c1"># conds is a tuple of an array and a vector</span>
<span class="c1">#  giving the left-hand and the right-hand side</span>
<span class="c1">#  of the additional equations to add to B</span>


<span class="k">def</span> <span class="nf">_find_user</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">conds</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">lh</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rh</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">B</span><span class="p">,</span> <span class="n">lh</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">yk</span><span class="p">,</span> <span class="n">rh</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">M</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;over-specification of conditions&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">M</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_find_smoothest</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>


<span class="c1"># Remove the 3 private functions above as well when removing splmake</span>
<span class="nd">@np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;splmake is deprecated in scipy 0.19.0, &quot;</span>
                      <span class="s2">&quot;use make_interp_spline instead.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">splmake</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;smoothest&#39;</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a representation of a spline given data-points at internal knots</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xk : array_like</span>
<span class="sd">        The input array of x values of rank 1</span>
<span class="sd">    yk : array_like</span>
<span class="sd">        The input array of y values of rank N. `yk` can be an N-d array to</span>
<span class="sd">        represent more than one curve, through the same `xk` points. The first</span>
<span class="sd">        dimension is assumed to be the interpolating dimension and is the same</span>
<span class="sd">        length of `xk`.</span>
<span class="sd">    order : int, optional</span>
<span class="sd">        Order of the spline</span>
<span class="sd">    kind : str, optional</span>
<span class="sd">        Can be &#39;smoothest&#39;, &#39;not_a_knot&#39;, &#39;fixed&#39;, &#39;clamped&#39;, &#39;natural&#39;,</span>
<span class="sd">        &#39;periodic&#39;, &#39;symmetric&#39;, &#39;user&#39;, &#39;mixed&#39; and it is ignored if order &lt; 2</span>
<span class="sd">    conds : optional</span>
<span class="sd">        Conds</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    splmake : tuple</span>
<span class="sd">        Return a (`xk`, `cvals`, `k`) representation of a spline given</span>
<span class="sd">        data-points where the (internal) knots are at the data-points.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">yk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">yk</span><span class="p">)</span>

    <span class="n">order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;order must not be negative&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">order</span>
    <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">,</span> <span class="n">order</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;_find_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">kind</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># the constraint matrix</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">_fitpack</span><span class="o">.</span><span class="n">_bsplmat</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">xk</span><span class="p">)</span>
    <span class="n">coefs</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">conds</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xk</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">order</span>


<span class="nd">@np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;spleval is deprecated in scipy 0.19.0, &quot;</span>
        <span class="s2">&quot;use BSpline instead.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">spleval</span><span class="p">(</span><span class="n">xck</span><span class="p">,</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a fixed spline represented by the given tuple at the new x-values</span>

<span class="sd">    The `xj` values are the interior knot points.  The approximation</span>
<span class="sd">    region is `xj[0]` to `xj[-1]`.  If N+1 is the length of `xj`, then `cvals`</span>
<span class="sd">    should have length N+k where `k` is the order of the spline.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    (xj, cvals, k) : tuple</span>
<span class="sd">        Parameters that define the fixed spline</span>
<span class="sd">    xj : array_like</span>
<span class="sd">        Interior knot points</span>
<span class="sd">    cvals : array_like</span>
<span class="sd">        Curvature</span>
<span class="sd">    k : int</span>
<span class="sd">        Order of the spline</span>
<span class="sd">    xnew : array_like</span>
<span class="sd">        Locations to calculate spline</span>
<span class="sd">    deriv : int</span>
<span class="sd">        Deriv</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spleval : ndarray</span>
<span class="sd">        If `cvals` represents more than one curve (`cvals.ndim` &gt; 1) and/or</span>
<span class="sd">        `xnew` is N-d, then the result is `xnew.shape` + `cvals.shape[1:]`</span>
<span class="sd">        providing the interpolation of multiple curves.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Internally, an additional `k`-1 knot points are added on either side of</span>
<span class="sd">    the spline.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">xj</span><span class="p">,</span> <span class="n">cvals</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">xck</span>
    <span class="n">oldshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xnew</span><span class="p">)</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">xnew</span><span class="p">)</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="n">cvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">sh</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cvals</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><span class="n">sh</span><span class="p">):</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="n">index</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">cvals</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="n">res</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">_fitpack</span><span class="o">.</span><span class="n">_bspleval</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">xj</span><span class="p">,</span> <span class="n">cvals</span><span class="o">.</span><span class="n">real</span><span class="p">[</span><span class="n">sl</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="n">deriv</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">_fitpack</span><span class="o">.</span><span class="n">_bspleval</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">xj</span><span class="p">,</span> <span class="n">cvals</span><span class="o">.</span><span class="n">imag</span><span class="p">[</span><span class="n">sl</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="n">deriv</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">_fitpack</span><span class="o">.</span><span class="n">_bspleval</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">xj</span><span class="p">,</span> <span class="n">cvals</span><span class="p">[</span><span class="n">sl</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="n">deriv</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">oldshape</span> <span class="o">+</span> <span class="n">sh</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="nd">@np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;spltopp is deprecated in scipy 0.19.0, &quot;</span>
                      <span class="s2">&quot;use PPoly.from_spline instead.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">spltopp</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">cvals</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a piece-wise polynomial object from a fixed-spline tuple.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ppform</span><span class="o">.</span><span class="n">fromspline</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">cvals</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>


<span class="nd">@np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;spline is deprecated in scipy 0.19.0, &quot;</span>
                      <span class="s2">&quot;use Bspline class instead.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">spline</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">,</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;smoothest&#39;</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate a curve at new points using a spline fit</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xk, yk : array_like</span>
<span class="sd">        The x and y values that define the curve.</span>
<span class="sd">    xnew : array_like</span>
<span class="sd">        The x values where spline should estimate the y values.</span>
<span class="sd">    order : int</span>
<span class="sd">        Default is 3.</span>
<span class="sd">    kind : string</span>
<span class="sd">        One of {&#39;smoothest&#39;}</span>
<span class="sd">    conds : Don&#39;t know</span>
<span class="sd">        Don&#39;t know</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spline : ndarray</span>
<span class="sd">        An array of y values; the spline evaluated at the positions `xnew`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">spleval</span><span class="p">(</span><span class="n">splmake</span><span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">),</span> <span class="n">xnew</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright J. Taylor and others
      <span class="lastupdated">
        Last updated on Sep 24, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>