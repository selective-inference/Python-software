

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Selection &mdash; Selection Documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />


</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../algorithms/index.html">Non-randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../randomized/index.html">Randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../learning/index.html">Learning selection</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">selection</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>Selection</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for selectinf.randomized.query</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">norm</span> <span class="k">as</span> <span class="n">ndist</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">bisect</span>

<span class="kn">from</span> <span class="nn">regreg.affine</span> <span class="k">import</span> <span class="n">power_L</span>
<span class="kn">import</span> <span class="nn">regreg.api</span> <span class="k">as</span> <span class="nn">rr</span>

<span class="kn">from</span> <span class="nn">.selective_MLE_utils</span> <span class="k">import</span> <span class="n">solve_barrier_affine</span> <span class="k">as</span> <span class="n">solve_barrier_affine_C</span>

<span class="kn">from</span> <span class="nn">..distributions.api</span> <span class="k">import</span> <span class="n">discrete_family</span>
<span class="kn">from</span> <span class="nn">..constraints.affine</span> <span class="k">import</span> <span class="p">(</span><span class="n">sample_from_constraints</span><span class="p">,</span>
                                  <span class="n">constraints</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..algorithms.softmax</span> <span class="k">import</span> <span class="n">softmax_objective</span>

<div class="viewcode-block" id="query"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.query">[docs]</a><span class="k">class</span> <span class="nc">query</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is the base of randomized selective inference</span>
<span class="sd">    based on convex programs.</span>

<span class="sd">    The main mechanism is to take an initial penalized program</span>

<span class="sd">    .. math::</span>

<span class="sd">        \text{minimize}_B \ell(B) + {\cal P}(B)</span>

<span class="sd">    and add a randomization and small ridge term yielding</span>

<span class="sd">    .. math::</span>

<span class="sd">        \text{minimize}_B \ell(B) + {\cal P}(B) - </span>
<span class="sd">        \langle \omega, B \rangle + \frac{\epsilon}{2} \|B\|^2_2</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="query.__init__"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.query.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">randomization</span><span class="p">,</span> <span class="n">perturb</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        randomization : `selection.randomized.randomization.randomization`</span>
<span class="sd">            Instance of a randomization scheme. </span>
<span class="sd">            Describes the law of $\omega$.</span>

<span class="sd">        perturb : ndarray, optional</span>
<span class="sd">            Value of randomization vector, an instance of $\omega$.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomization</span> <span class="o">=</span> <span class="n">randomization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perturb</span> <span class="o">=</span> <span class="n">perturb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solved</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_randomized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup</span> <span class="o">=</span> <span class="kc">False</span></div>

    <span class="c1"># Methods reused by subclasses</span>

<div class="viewcode-block" id="query.randomize"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.query.randomize">[docs]</a>    <span class="k">def</span> <span class="nf">randomize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perturb</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        The actual randomization step.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        perturb : ndarray, optional</span>
<span class="sd">            Value of randomization vector, an instance of $\omega$.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_randomized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">randomized_loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomization</span><span class="o">.</span><span class="n">randomize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">perturb</span><span class="o">=</span><span class="n">perturb</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_randomized</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="query.get_sampler"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.query.get_sampler">[docs]</a>    <span class="k">def</span> <span class="nf">get_sampler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_sampler&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampler</span></div>

<div class="viewcode-block" id="query.set_sampler"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.query.set_sampler">[docs]</a>    <span class="k">def</span> <span class="nf">set_sampler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampler</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sampler</span> <span class="o">=</span> <span class="n">sampler</span></div>

    <span class="n">sampler</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_sampler</span><span class="p">,</span> <span class="n">set_sampler</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Sampler of optimization (augmented) variables.&#39;</span><span class="p">)</span>

    <span class="c1"># implemented by subclasses</span>

<div class="viewcode-block" id="query.solve"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.query.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;abstract method&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="query.setup_sampler"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.query.setup_sampler">[docs]</a>    <span class="k">def</span> <span class="nf">setup_sampler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setup query to prepare for sampling.</span>
<span class="sd">        Should set a few key attributes:</span>

<span class="sd">            - observed_score_state</span>
<span class="sd">            - observed_opt_state</span>
<span class="sd">            - opt_transform</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;abstract method -- only keyword arguments&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="query.summary"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.query.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">observed_target</span><span class="p">,</span> 
                <span class="n">target_cov</span><span class="p">,</span> 
                <span class="n">target_score_cov</span><span class="p">,</span> 
                <span class="n">alternatives</span><span class="p">,</span>
                <span class="n">opt_sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">target_sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">parameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">level</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                <span class="n">ndraw</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
                <span class="n">burnin</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                <span class="n">compute_intervals</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce p-values and confidence intervals for targets</span>
<span class="sd">        of model including selected features</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        target : one of [&#39;selected&#39;, &#39;full&#39;]</span>

<span class="sd">        features : np.bool</span>
<span class="sd">            Binary encoding of which features to use in final</span>
<span class="sd">            model and targets.</span>

<span class="sd">        parameter : np.array</span>
<span class="sd">            Hypothesized value for parameter -- defaults to 0.</span>

<span class="sd">        level : float</span>
<span class="sd">            Confidence level.</span>

<span class="sd">        ndraw : int (optional)</span>
<span class="sd">            Defaults to 1000.</span>

<span class="sd">        burnin : int (optional)</span>
<span class="sd">            Defaults to 1000.</span>

<span class="sd">        compute_intervals : bool</span>
<span class="sd">            Compute confidence intervals?</span>

<span class="sd">        dispersion : float (optional)</span>
<span class="sd">            Use a known value for dispersion, or Pearson&#39;s X^2?</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">observed_target</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">opt_sample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">opt_sample</span><span class="p">,</span> <span class="n">logW</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">ndraw</span><span class="p">,</span> <span class="n">burnin</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opt_sample</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># only a sample, so weights are 1s</span>
                <span class="n">opt_sample</span> <span class="o">=</span> <span class="n">opt_sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">logW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ndraw</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">opt_sample</span><span class="p">,</span> <span class="n">logW</span> <span class="o">=</span> <span class="n">opt_sample</span>
            <span class="n">ndraw</span> <span class="o">=</span> <span class="n">opt_sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">pivots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">coefficient_pvalues</span><span class="p">(</span><span class="n">observed_target</span><span class="p">,</span>
                                                  <span class="n">target_cov</span><span class="p">,</span>
                                                  <span class="n">target_score_cov</span><span class="p">,</span>
                                                  <span class="n">parameter</span><span class="o">=</span><span class="n">parameter</span><span class="p">,</span>
                                                  <span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="n">opt_sample</span><span class="p">,</span> <span class="n">logW</span><span class="p">),</span>
                                                  <span class="n">normal_sample</span><span class="o">=</span><span class="n">target_sample</span><span class="p">,</span>
                                                  <span class="n">alternatives</span><span class="o">=</span><span class="n">alternatives</span><span class="p">)</span>

        <span class="n">MLE_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selective_MLE</span><span class="p">(</span><span class="n">observed_target</span><span class="p">,</span>
                                           <span class="n">target_cov</span><span class="p">,</span>
                                           <span class="n">target_score_cov</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">parameter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">pvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">coefficient_pvalues</span><span class="p">(</span><span class="n">observed_target</span><span class="p">,</span>
                                                       <span class="n">target_cov</span><span class="p">,</span>
                                                       <span class="n">target_score_cov</span><span class="p">,</span>
                                                       <span class="n">parameter</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">parameter</span><span class="p">),</span>
                                                       <span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="n">opt_sample</span><span class="p">,</span> <span class="n">logW</span><span class="p">),</span>
                                                       <span class="n">normal_sample</span><span class="o">=</span><span class="n">target_sample</span><span class="p">,</span>
                                                       <span class="n">alternatives</span><span class="o">=</span><span class="n">alternatives</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pvalues</span> <span class="o">=</span> <span class="n">pivots</span>

        <span class="n">intervals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">compute_intervals</span><span class="p">:</span>

            <span class="n">MLE_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selective_MLE</span><span class="p">(</span><span class="n">observed_target</span><span class="p">,</span>
                                               <span class="n">target_cov</span><span class="p">,</span>
                                               <span class="n">target_score_cov</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span>

            <span class="n">intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">confidence_intervals</span><span class="p">(</span><span class="n">observed_target</span><span class="p">,</span>
                                                          <span class="n">target_cov</span><span class="p">,</span>
                                                          <span class="n">target_score_cov</span><span class="p">,</span>
                                                          <span class="n">sample</span><span class="o">=</span><span class="p">(</span><span class="n">opt_sample</span><span class="p">,</span> <span class="n">logW</span><span class="p">),</span>
                                                          <span class="n">normal_sample</span><span class="o">=</span><span class="n">target_sample</span><span class="p">,</span>
                                                          <span class="n">initial_guess</span><span class="o">=</span><span class="n">MLE_intervals</span><span class="p">,</span>
                                                          <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pivots</span><span class="p">,</span> <span class="n">pvalues</span><span class="p">,</span> <span class="n">intervals</span></div>

<div class="viewcode-block" id="query.selective_MLE"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.query.selective_MLE">[docs]</a>    <span class="k">def</span> <span class="nf">selective_MLE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">observed_target</span><span class="p">,</span> 
                      <span class="n">target_cov</span><span class="p">,</span> 
                      <span class="n">target_score_cov</span><span class="p">,</span> 
                      <span class="n">level</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                      <span class="n">solve_args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;tol&#39;</span><span class="p">:</span><span class="mf">1.e-12</span><span class="p">}):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        observed_target : ndarray</span>
<span class="sd">            Observed estimate of target.</span>

<span class="sd">        target_cov : ndarray</span>
<span class="sd">            Estimated covaraince of target.</span>

<span class="sd">        target_score_cov : ndarray</span>
<span class="sd">            Estimated covariance of target and score of randomized query.</span>

<span class="sd">        level : float, optional</span>
<span class="sd">            Confidence level.</span>

<span class="sd">        solve_args : dict, optional</span>
<span class="sd">            Arguments passed to solver.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">selective_MLE</span><span class="p">(</span><span class="n">observed_target</span><span class="p">,</span>
                                          <span class="n">target_cov</span><span class="p">,</span>
                                          <span class="n">target_score_cov</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">observed_opt_state</span><span class="p">,</span>
                                          <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                          <span class="n">solve_args</span><span class="o">=</span><span class="n">solve_args</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="gaussian_query"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.gaussian_query">[docs]</a><span class="k">class</span> <span class="nc">gaussian_query</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>

    <span class="n">useC</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class with Gaussian perturbation to the objective -- </span>
<span class="sd">    easy to apply CLT to such things</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="gaussian_query.fit"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.gaussian_query.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perturb</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfeature</span>

        <span class="c1"># take a new perturbation if supplied</span>
        <span class="k">if</span> <span class="n">perturb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initial_omega</span> <span class="o">=</span> <span class="n">perturb</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_omega</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initial_omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomizer</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span></div>

    <span class="c1"># Private methods</span>

    <span class="k">def</span> <span class="nf">_setup_sampler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                       <span class="n">A_scaling</span><span class="p">,</span>
                       <span class="n">b_scaling</span><span class="p">,</span>
                       <span class="n">opt_linear</span><span class="p">,</span>
                       <span class="n">opt_offset</span><span class="p">,</span>
                       <span class="c1"># optional dispersion parameter</span>
                       <span class="c1"># for covariance of randomization</span>
                       <span class="n">dispersion</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">A_scaling</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_opt_state</span><span class="p">)</span> <span class="o">-</span> <span class="n">b_scaling</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;constraints not satisfied&#39;</span><span class="p">)</span>

        <span class="p">(</span><span class="n">cond_mean</span><span class="p">,</span> 
         <span class="n">cond_cov</span><span class="p">,</span> 
         <span class="n">cond_precision</span><span class="p">,</span> 
         <span class="n">logdens_linear</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_implied_gaussian</span><span class="p">(</span><span class="n">opt_linear</span><span class="p">,</span> 
                                                        <span class="n">opt_offset</span><span class="p">,</span>
                                                        <span class="n">dispersion</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">log_density</span><span class="p">(</span><span class="n">logdens_linear</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cond_prec</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">score</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">score</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mean_term</span> <span class="o">=</span> <span class="n">logdens_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">score</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mean_term</span> <span class="o">=</span> <span class="n">logdens_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">score</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">opt</span> <span class="o">+</span> <span class="n">mean_term</span>
            <span class="k">return</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arg</span> <span class="o">*</span> <span class="n">cond_prec</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">log_density</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">log_density</span><span class="p">,</span> 
                                        <span class="n">logdens_linear</span><span class="p">,</span> 
                                        <span class="n">opt_offset</span><span class="p">,</span> 
                                        <span class="n">cond_precision</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cond_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond_cov</span> <span class="o">=</span> <span class="n">cond_mean</span><span class="p">,</span> <span class="n">cond_cov</span>

        <span class="n">affine_con</span> <span class="o">=</span> <span class="n">constraints</span><span class="p">(</span><span class="n">A_scaling</span><span class="p">,</span>
                                 <span class="n">b_scaling</span><span class="p">,</span>
                                 <span class="n">mean</span><span class="o">=</span><span class="n">cond_mean</span><span class="p">,</span>
                                 <span class="n">covariance</span><span class="o">=</span><span class="n">cond_cov</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">affine_gaussian_sampler</span><span class="p">(</span><span class="n">affine_con</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">observed_opt_state</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">observed_score_state</span><span class="p">,</span>
                                               <span class="n">log_density</span><span class="p">,</span>
                                               <span class="p">(</span><span class="n">logdens_linear</span><span class="p">,</span> <span class="n">opt_offset</span><span class="p">),</span>
                                               <span class="n">selection_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_variable</span><span class="p">,</span>
                                               <span class="n">useC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">useC</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_implied_gaussian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                                <span class="n">opt_linear</span><span class="p">,</span> 
                                <span class="n">opt_offset</span><span class="p">,</span>
                                <span class="c1"># optional dispersion parameter</span>
                                <span class="c1"># for covariance of randomization</span>
                                <span class="n">dispersion</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">prec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomizer</span><span class="o">.</span><span class="n">cov_prec</span> 
        <span class="n">prec</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">/</span> <span class="n">dispersion</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="ow">in</span> <span class="p">[(),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)]:</span>
            <span class="n">cond_precision</span> <span class="o">=</span> <span class="n">opt_linear</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">opt_linear</span><span class="p">)</span> <span class="o">*</span> <span class="n">prec</span>
            <span class="n">cond_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cond_precision</span><span class="p">)</span>
            <span class="n">logdens_linear</span> <span class="o">=</span> <span class="n">cond_cov</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">opt_linear</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">prec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cond_precision</span> <span class="o">=</span> <span class="n">opt_linear</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">opt_linear</span><span class="p">))</span>
            <span class="n">cond_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cond_precision</span><span class="p">)</span>
            <span class="n">logdens_linear</span> <span class="o">=</span> <span class="n">cond_cov</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">opt_linear</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>

        <span class="n">cond_mean</span> <span class="o">=</span> <span class="o">-</span><span class="n">logdens_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_score_state</span> <span class="o">+</span> <span class="n">opt_offset</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cond_mean</span><span class="p">,</span> <span class="n">cond_cov</span><span class="p">,</span> <span class="n">cond_precision</span><span class="p">,</span> <span class="n">logdens_linear</span></div>

<div class="viewcode-block" id="multiple_queries"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.multiple_queries">[docs]</a><span class="k">class</span> <span class="nc">multiple_queries</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Combine several queries of a given data</span>
<span class="sd">    through randomized algorithms.</span>
<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="multiple_queries.__init__"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.multiple_queries.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objectives</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        objectives : sequence</span>
<span class="sd">           A sequences of randomized objective functions.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        Each element of `objectives` must</span>
<span class="sd">        have a `setup_sampler` method that returns</span>
<span class="sd">        a description of the distribution of the</span>
<span class="sd">        data implicated in the objective function,</span>
<span class="sd">        typically through the score or gradient</span>
<span class="sd">        of the objective function.</span>
<span class="sd">        These descriptions are passed to a function</span>
<span class="sd">        `form_covariances` to linearly decompose</span>
<span class="sd">        each score in terms of a target</span>
<span class="sd">        and an asymptotically independent piece.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        None</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">objectives</span> <span class="o">=</span> <span class="n">objectives</span></div>

<div class="viewcode-block" id="multiple_queries.fit"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.multiple_queries.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">objective</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objectives</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">objective</span><span class="o">.</span><span class="n">_setup</span><span class="p">:</span>
                <span class="n">objective</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span></div>

<div class="viewcode-block" id="multiple_queries.summary"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.multiple_queries.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">observed_target</span><span class="p">,</span>
                <span class="n">opt_sampling_info</span><span class="p">,</span>  <span class="c1"># a sequence of (target_cov, score_cov) </span>
                                    <span class="c1"># objects in theory all target_cov</span>
                                    <span class="c1"># should be about the same...</span>
                <span class="n">alternatives</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">parameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">level</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                <span class="n">ndraw</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
                <span class="n">burnin</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                <span class="n">compute_intervals</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce p-values and confidence intervals for targets</span>
<span class="sd">        of model including selected features</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        observed_target : ndarray</span>
<span class="sd">            Observed estimate of target.</span>

<span class="sd">        alternatives : [str], optional</span>
<span class="sd">            Sequence of strings describing the alternatives,</span>
<span class="sd">            should be values of [&#39;twosided&#39;, &#39;less&#39;, &#39;greater&#39;]</span>

<span class="sd">        parameter : np.array</span>
<span class="sd">            Hypothesized value for parameter -- defaults to 0.</span>

<span class="sd">        level : float</span>
<span class="sd">            Confidence level.</span>

<span class="sd">        ndraw : int (optional)</span>
<span class="sd">            Defaults to 1000.</span>

<span class="sd">        burnin : int (optional)</span>
<span class="sd">            Defaults to 1000.</span>

<span class="sd">        compute_intervals : bool</span>
<span class="sd">            Compute confidence intervals?</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">observed_target</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alternatives</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alternatives</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;twosided&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">observed_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objectives</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">opt_sampling_info</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;number of objectives and sampling cov infos do not match&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objectives</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">opt_sampling_info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">opt_sampling_info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;did not input target and score covariance info&quot;</span><span class="p">)</span>
            <span class="n">opt_sample</span><span class="p">,</span> <span class="n">opt_logW</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objectives</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">ndraw</span><span class="p">,</span> <span class="n">burnin</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">objectives</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sampler</span><span class="p">,</span> 
                                           <span class="n">opt_sample</span><span class="p">,</span> 
                                           <span class="n">opt_logW</span><span class="p">,</span>
                                           <span class="n">opt_sampling_info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> 
                                           <span class="n">opt_sampling_info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">pivots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficient_pvalues</span><span class="p">(</span><span class="n">observed_target</span><span class="p">,</span>
                                          <span class="n">parameter</span><span class="o">=</span><span class="n">parameter</span><span class="p">,</span>
                                          <span class="n">alternatives</span><span class="o">=</span><span class="n">alternatives</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">parameter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">pvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficient_pvalues</span><span class="p">(</span><span class="n">observed_target</span><span class="p">,</span>
                                               <span class="n">parameter</span><span class="o">=</span><span class="n">parameter</span><span class="p">,</span>
                                               <span class="n">alternatives</span><span class="o">=</span><span class="n">alternatives</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pvalues</span> <span class="o">=</span> <span class="n">pivots</span>

        <span class="n">intervals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">compute_intervals</span><span class="p">:</span>
            <span class="n">intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">confidence_intervals</span><span class="p">(</span><span class="n">observed_target</span><span class="p">,</span>
                                                  <span class="n">level</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pivots</span><span class="p">,</span> <span class="n">pvalues</span><span class="p">,</span> <span class="n">intervals</span></div>
        

<div class="viewcode-block" id="multiple_queries.coefficient_pvalues"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.multiple_queries.coefficient_pvalues">[docs]</a>    <span class="k">def</span> <span class="nf">coefficient_pvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">observed_target</span><span class="p">,</span>
                            <span class="n">parameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">sample_args</span><span class="o">=</span><span class="p">(),</span>
                            <span class="n">alternatives</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Construct selective p-values</span>
<span class="sd">        for each parameter of the target.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        observed_target : ndarray</span>
<span class="sd">            Observed estimate of target.</span>

<span class="sd">        parameter : ndarray (optional)</span>
<span class="sd">            A vector of parameters with shape `self.shape`</span>
<span class="sd">            at which to evaluate p-values. Defaults</span>
<span class="sd">            to `np.zeros(self.shape)`.</span>

<span class="sd">        sample_args : sequence</span>
<span class="sd">           Arguments to `self.sample` if sample is not found</span>
<span class="sd">           for a given objective.</span>

<span class="sd">        alternatives : [str], optional</span>
<span class="sd">            Sequence of strings describing the alternatives,</span>
<span class="sd">            should be values of [&#39;twosided&#39;, &#39;less&#39;, &#39;greater&#39;]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pvalues : ndarray</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objectives</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_sample</span><span class="p">,</span> <span class="n">_logW</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objectives</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="o">*</span><span class="n">sample_args</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sample</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">_logW</span>

        <span class="n">ndraw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># nsample for normal samples taken from the 1st objective</span>

        <span class="n">_intervals</span> <span class="o">=</span> <span class="n">optimization_intervals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span><span class="p">,</span> 
                                            <span class="n">observed_target</span><span class="p">,</span> 
                                            <span class="n">ndraw</span><span class="p">)</span>

        <span class="n">pvals</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">observed_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">observed_target</span><span class="p">)</span>
            <span class="n">keep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">pvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_intervals</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">candidate</span><span class="o">=</span><span class="n">parameter</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">alternative</span><span class="o">=</span><span class="n">alternatives</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pvals</span><span class="p">)</span></div>


<div class="viewcode-block" id="multiple_queries.confidence_intervals"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.multiple_queries.confidence_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">confidence_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">observed_target</span><span class="p">,</span>
                             <span class="n">sample_args</span><span class="o">=</span><span class="p">(),</span>
                             <span class="n">level</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Construct selective confidence intervals</span>
<span class="sd">        for each parameter of the target.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        observed_target : ndarray</span>
<span class="sd">            Observed estimate of target.</span>

<span class="sd">        sample_args : sequence</span>
<span class="sd">           Arguments to `self.sample` if sample is not found</span>
<span class="sd">           for a given objective.</span>

<span class="sd">        level : float</span>
<span class="sd">            Confidence level.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        limits : ndarray</span>
<span class="sd">            Confidence intervals for each target.</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objectives</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_sample</span><span class="p">,</span> <span class="n">_logW</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objectives</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="o">*</span><span class="n">sample_args</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_sample</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">_logW</span>

        <span class="n">ndraw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># nsample for normal samples taken from the 1st objective</span>

        <span class="n">_intervals</span> <span class="o">=</span> <span class="n">optimization_intervals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span><span class="p">,</span> 
                                            <span class="n">observed_target</span><span class="p">,</span> 
                                            <span class="n">ndraw</span><span class="p">)</span>

        <span class="n">limits</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">observed_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">observed_target</span><span class="p">)</span>
            <span class="n">keep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_intervals</span><span class="o">.</span><span class="n">confidence_interval</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span>       </div></div>


<div class="viewcode-block" id="optimization_sampler"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.optimization_sampler">[docs]</a><span class="k">class</span> <span class="nc">optimization_sampler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<div class="viewcode-block" id="optimization_sampler.__init__"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.optimization_sampler.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;abstract method&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="optimization_sampler.sample"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.optimization_sampler.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;abstract method&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="optimization_sampler.log_cond_density"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.optimization_sampler.log_cond_density">[docs]</a>    <span class="k">def</span> <span class="nf">log_cond_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">opt_sample</span><span class="p">,</span>
                         <span class="n">target_sample</span><span class="p">,</span>
                         <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Density of opt_sample | target_sample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;abstract method&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="optimization_sampler.hypothesis_test"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.optimization_sampler.hypothesis_test">[docs]</a>    <span class="k">def</span> <span class="nf">hypothesis_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">test_stat</span><span class="p">,</span>
                        <span class="n">observed_value</span><span class="p">,</span>
                        <span class="n">target_cov</span><span class="p">,</span>
                        <span class="n">score_cov</span><span class="p">,</span>
                        <span class="n">sample_args</span><span class="o">=</span><span class="p">(),</span>
                        <span class="n">sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">parameter</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;twosided&#39;</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sample `target` from selective density</span>
<span class="sd">        using sampler with</span>
<span class="sd">        gradient map `self.gradient` and</span>
<span class="sd">        projection map `self.projection`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        test_stat : callable</span>
<span class="sd">           Test statistic to evaluate on sample from</span>
<span class="sd">           selective distribution.</span>

<span class="sd">        observed_value : float</span>
<span class="sd">           Observed value of test statistic.</span>
<span class="sd">           Used in p-value calculation.</span>

<span class="sd">        sample_args : sequence</span>
<span class="sd">           Arguments to `self.sample` if sample is None.</span>

<span class="sd">        sample : np.array (optional)</span>
<span class="sd">           If not None, assumed to be a sample of shape (-1,) + `self.shape`</span>
<span class="sd">           representing a sample of the target from parameters.</span>
<span class="sd">           Allows reuse of the same sample for construction of confidence</span>
<span class="sd">           intervals, hypothesis tests, etc. If not None,</span>
<span class="sd">           `ndraw, burnin, stepsize` are ignored.</span>

<span class="sd">        parameter : np.float (optional)</span>

<span class="sd">        alternative : [&#39;greater&#39;, &#39;less&#39;, &#39;twosided&#39;]</span>
<span class="sd">            What alternative to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        pvalue : float</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">alternative</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;greater&#39;</span><span class="p">,</span> <span class="s1">&#39;less&#39;</span><span class="p">,</span> <span class="s1">&#39;twosided&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alternative should be one of [&#39;greater&#39;, &#39;less&#39;, &#39;twosided&#39;]&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample</span><span class="p">,</span> <span class="n">logW</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="o">*</span><span class="n">sample_args</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span>

        <span class="n">sample_test_stat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">test_stat</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample</span><span class="p">]))</span>

        <span class="n">target_inv_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">target_cov</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">target_inv_cov</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">parameter</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">+</span> <span class="n">logW</span><span class="p">)</span>

        <span class="n">family</span> <span class="o">=</span> <span class="n">discrete_family</span><span class="p">(</span><span class="n">sample_test_stat</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="n">family</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">observed_value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;greater&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pval</span>
        <span class="k">elif</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;less&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">pval</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pval</span><span class="p">)</span></div>

<div class="viewcode-block" id="optimization_sampler.confidence_intervals"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.optimization_sampler.confidence_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">confidence_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">observed_target</span><span class="p">,</span>
                             <span class="n">target_cov</span><span class="p">,</span>
                             <span class="n">score_cov</span><span class="p">,</span>
                             <span class="n">sample_args</span><span class="o">=</span><span class="p">(),</span>
                             <span class="n">sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">normal_sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">level</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                             <span class="n">initial_guess</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd"> </span>
<span class="sd">        observed : np.float</span>
<span class="sd">            A vector of parameters with shape `self.shape`,</span>
<span class="sd">            representing coordinates of the target.</span>

<span class="sd">        sample_args : sequence</span>
<span class="sd">           Arguments to `self.sample` if sample is None.</span>

<span class="sd">        sample : np.array (optional)</span>
<span class="sd">           If not None, assumed to be a sample of shape (-1,) + `self.shape`</span>
<span class="sd">           representing a sample of the target from parameters `self.reference`.</span>
<span class="sd">           Allows reuse of the same sample for construction of confidence</span>
<span class="sd">           intervals, hypothesis tests, etc.</span>

<span class="sd">        level : float (optional)</span>
<span class="sd">            Specify the</span>
<span class="sd">            confidence level.</span>

<span class="sd">        initial_guess : np.float</span>
<span class="sd">            Initial guesses at upper and lower limits, optional.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        Construct selective confidence intervals</span>
<span class="sd">        for each parameter of the target.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        intervals : [(float, float)]</span>
<span class="sd">            List of confidence intervals.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample</span><span class="p">,</span> <span class="n">logW</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="o">*</span><span class="n">sample_args</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">sample</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span> <span class="c1"># why times 5?</span>
            <span class="n">logW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">logW</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample</span><span class="p">,</span> <span class="n">logW</span> <span class="o">=</span> <span class="n">sample</span>

        <span class="n">ndraw</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">_intervals</span> <span class="o">=</span> <span class="n">optimization_intervals</span><span class="p">([(</span><span class="bp">self</span><span class="p">,</span> 
                                              <span class="n">sample</span><span class="p">,</span> 
                                              <span class="n">logW</span><span class="p">,</span>
                                              <span class="n">target_cov</span><span class="p">,</span> 
                                              <span class="n">score_cov</span><span class="p">)],</span>
                                            <span class="n">observed_target</span><span class="p">,</span> 
                                            <span class="n">ndraw</span><span class="p">,</span> 
                                            <span class="n">normal_sample</span><span class="o">=</span><span class="n">normal_sample</span><span class="p">)</span>

        <span class="n">limits</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">observed_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">observed_target</span><span class="p">)</span>
            <span class="n">keep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="k">if</span> <span class="n">initial_guess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">l</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">_intervals</span><span class="o">.</span><span class="n">confidence_interval</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">_intervals</span><span class="o">.</span><span class="n">confidence_interval</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                                      <span class="n">guess</span><span class="o">=</span><span class="n">initial_guess</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">limits</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span></div>

<div class="viewcode-block" id="optimization_sampler.coefficient_pvalues"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.optimization_sampler.coefficient_pvalues">[docs]</a>    <span class="k">def</span> <span class="nf">coefficient_pvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">observed_target</span><span class="p">,</span>
                            <span class="n">target_cov</span><span class="p">,</span>
                            <span class="n">score_cov</span><span class="p">,</span>
                            <span class="n">parameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">sample_args</span><span class="o">=</span><span class="p">(),</span>
                            <span class="n">sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">normal_sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">alternatives</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Construct selective p-values</span>
<span class="sd">        for each parameter of the target.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        observed : np.float</span>
<span class="sd">            A vector of parameters with shape `self.shape`,</span>
<span class="sd">            representing coordinates of the target.</span>

<span class="sd">        parameter : np.float (optional)</span>
<span class="sd">            A vector of parameters with shape `self.shape`</span>
<span class="sd">            at which to evaluate p-values. Defaults</span>
<span class="sd">            to `np.zeros(self.shape)`.</span>

<span class="sd">        sample_args : sequence</span>
<span class="sd">           Arguments to `self.sample` if sample is None.</span>

<span class="sd">        sample : np.array (optional)</span>
<span class="sd">           If not None, assumed to be a sample of shape (-1,) + `self.shape`</span>
<span class="sd">           representing a sample of the target from parameters `self.reference`.</span>
<span class="sd">           Allows reuse of the same sample for construction of confidence</span>
<span class="sd">           intervals, hypothesis tests, etc.</span>

<span class="sd">        alternatives : list of [&#39;greater&#39;, &#39;less&#39;, &#39;twosided&#39;]</span>
<span class="sd">            What alternative to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pvalues : np.float</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">alternatives</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alternatives</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;twosided&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">observed_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample</span><span class="p">,</span> <span class="n">logW</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="o">*</span><span class="n">sample_args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample</span><span class="p">,</span> <span class="n">logW</span> <span class="o">=</span> <span class="n">sample</span>
            <span class="n">ndraw</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">observed_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">_intervals</span> <span class="o">=</span> <span class="n">optimization_intervals</span><span class="p">([(</span><span class="bp">self</span><span class="p">,</span> 
                                              <span class="n">sample</span><span class="p">,</span> 
                                              <span class="n">logW</span><span class="p">,</span>
                                              <span class="n">target_cov</span><span class="p">,</span> 
                                              <span class="n">score_cov</span><span class="p">)],</span>
                                            <span class="n">observed_target</span><span class="p">,</span> 
                                            <span class="n">ndraw</span><span class="p">,</span> 
                                            <span class="n">normal_sample</span><span class="o">=</span><span class="n">normal_sample</span><span class="p">)</span>
        <span class="n">pvals</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">observed_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">observed_target</span><span class="p">)</span>
            <span class="n">keep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">pvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_intervals</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> 
                                          <span class="n">candidate</span><span class="o">=</span><span class="n">parameter</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
                                          <span class="n">alternative</span><span class="o">=</span><span class="n">alternatives</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pvals</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_reconstruct_score_from_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                       <span class="n">target_sample</span><span class="p">,</span>
                                       <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">direction</span><span class="p">,</span> <span class="n">nuisance</span> <span class="o">=</span> <span class="n">transform</span>
            <span class="n">score_sample</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">target_sample</span><span class="p">,</span>
                                              <span class="n">direction</span><span class="p">)</span> <span class="o">+</span> 
                            <span class="n">nuisance</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">score_sample</span> <span class="o">=</span> <span class="n">target_sample</span>
        <span class="k">return</span> <span class="n">score_sample</span></div>

<div class="viewcode-block" id="affine_gaussian_sampler"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.affine_gaussian_sampler">[docs]</a><span class="k">class</span> <span class="nc">affine_gaussian_sampler</span><span class="p">(</span><span class="n">optimization_sampler</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Sample from an affine truncated Gaussian</span>
<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="affine_gaussian_sampler.__init__"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.affine_gaussian_sampler.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">affine_con</span><span class="p">,</span>
                 <span class="n">initial_point</span><span class="p">,</span>
                 <span class="n">observed_score_state</span><span class="p">,</span>
                 <span class="n">log_cond_density</span><span class="p">,</span>
                 <span class="n">logdens_transform</span><span class="p">,</span> <span class="c1"># described how score enters log_density.</span>
                 <span class="n">selection_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">useC</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        affine_con : `selection.constraints.affine.constraints`</span>
<span class="sd">             Affine constraints</span>

<span class="sd">        initial_point : ndarray</span>
<span class="sd">             Feasible point for affine constraints.</span>

<span class="sd">        observed_score_state : ndarray</span>
<span class="sd">             Observed score of convex loss (slightly modified).</span>
<span class="sd">             Essentially (asymptotically) equivalent </span>
<span class="sd">             to $\nabla \ell(\beta^*) + </span>
<span class="sd">             Q(\beta^*)\beta^*$ where $\beta^*$ is population</span>
<span class="sd">             minimizer. For linear regression, it is always</span>
<span class="sd">             $-X^Ty$.</span>

<span class="sd">        log_cond_density : callable</span>
<span class="sd">             Density of optimization variables given score</span>

<span class="sd">        logdens_transform : tuple</span>
<span class="sd">             Description of how conditional mean</span>
<span class="sd">             of optimization variables depends on score.</span>

<span class="sd">        selection_info : optional</span>
<span class="sd">             Function of optimization variables that</span>
<span class="sd">             will be conditioned on.</span>

<span class="sd">        useC : bool, optional</span>
<span class="sd">            Use python or C solver.</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">affine_con</span> <span class="o">=</span> <span class="n">affine_con</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine_con</span><span class="o">.</span><span class="n">covariance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine_con</span><span class="o">.</span><span class="n">mean</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initial_point</span> <span class="o">=</span> <span class="n">initial_point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed_score_state</span> <span class="o">=</span> <span class="n">observed_score_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_info</span> <span class="o">=</span> <span class="n">selection_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log_cond_density</span> <span class="o">=</span> <span class="n">log_cond_density</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logdens_transform</span> <span class="o">=</span> <span class="n">logdens_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">useC</span> <span class="o">=</span> <span class="n">useC</span></div>

<div class="viewcode-block" id="affine_gaussian_sampler.log_cond_density"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.affine_gaussian_sampler.log_cond_density">[docs]</a>    <span class="k">def</span> <span class="nf">log_cond_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">opt_sample</span><span class="p">,</span>
                         <span class="n">target_sample</span><span class="p">,</span>
                         <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">direction</span><span class="p">,</span> <span class="n">nuisance</span> <span class="o">=</span> <span class="n">transform</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_density_ray</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>   <span class="c1"># candidate</span>
                                              <span class="c1"># has been added to</span>
                                              <span class="c1"># target</span>
                                         <span class="n">direction</span><span class="p">,</span>
                                         <span class="n">nuisance</span><span class="p">,</span>
                                         <span class="n">target_sample</span><span class="p">,</span>
                                         <span class="n">opt_sample</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># target must be in score coordinates</span>
            <span class="n">score_sample</span> <span class="o">=</span> <span class="n">target_sample</span>

            <span class="c1"># probably should switch</span>
            <span class="c1"># order of signature</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_cond_density</span><span class="p">(</span><span class="n">opt_sample</span><span class="p">,</span>
                                          <span class="n">score_sample</span><span class="p">)</span></div>

<div class="viewcode-block" id="affine_gaussian_sampler.sample"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.affine_gaussian_sampler.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndraw</span><span class="p">,</span> <span class="n">burnin</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sample `target` from selective density</span>
<span class="sd">        using projected Langevin sampler with</span>
<span class="sd">        gradient map `self.gradient` and</span>
<span class="sd">        projection map `self.projection`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ndraw : int</span>
<span class="sd">           How long a chain to return?</span>

<span class="sd">        burnin : int</span>
<span class="sd">           How many samples to discard?</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">_sample</span> <span class="o">=</span> <span class="n">sample_from_constraints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">affine_con</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">initial_point</span><span class="p">,</span>
                                          <span class="n">ndraw</span><span class="o">=</span><span class="n">ndraw</span><span class="p">,</span>
                                          <span class="n">burnin</span><span class="o">=</span><span class="n">burnin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_sample</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="affine_gaussian_sampler.selective_MLE"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.affine_gaussian_sampler.selective_MLE">[docs]</a>    <span class="k">def</span> <span class="nf">selective_MLE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                      <span class="n">observed_target</span><span class="p">,</span> 
                      <span class="n">target_cov</span><span class="p">,</span> 
                      <span class="n">target_score_cov</span><span class="p">,</span> 
                      <span class="c1"># initial (observed) value of optimization variables -- </span>
                      <span class="c1"># used as a feasible point.</span>
                      <span class="c1"># precise value used only for independent estimator </span>
                      <span class="n">init_soln</span><span class="p">,</span> 
                      <span class="n">solve_args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;tol&#39;</span><span class="p">:</span><span class="mf">1.e-12</span><span class="p">},</span> 
                      <span class="n">level</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Selective MLE based on approximation of</span>
<span class="sd">        CGF.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        observed_target : ndarray</span>
<span class="sd">            Observed estimate of target.</span>

<span class="sd">        target_cov : ndarray</span>
<span class="sd">            Estimated covaraince of target.</span>

<span class="sd">        target_score_cov : ndarray</span>
<span class="sd">            Estimated covariance of target and score of randomized query.</span>

<span class="sd">        init_soln : ndarray</span>
<span class="sd">            Feasible point for optimization problem.</span>

<span class="sd">        level : float, optional</span>
<span class="sd">            Confidence level.</span>

<span class="sd">        solve_args : dict, optional</span>
<span class="sd">            Arguments passed to solver.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">selective_MLE</span><span class="p">(</span><span class="n">observed_target</span><span class="p">,</span> 
                             <span class="n">target_cov</span><span class="p">,</span> 
                             <span class="n">target_score_cov</span><span class="p">,</span> 
                             <span class="n">init_soln</span><span class="p">,</span> 
                             <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">logdens_transform</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">affine_con</span><span class="o">.</span><span class="n">linear_part</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">affine_con</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span>
                             <span class="n">solve_args</span><span class="o">=</span><span class="n">solve_args</span><span class="p">,</span>
                             <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                             <span class="n">useC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">useC</span><span class="p">)</span></div>

<div class="viewcode-block" id="affine_gaussian_sampler.reparam_map"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.affine_gaussian_sampler.reparam_map">[docs]</a>    <span class="k">def</span> <span class="nf">reparam_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                    <span class="n">parameter_target</span><span class="p">,</span> 
                    <span class="n">observed_target</span><span class="p">,</span> 
                    <span class="n">target_cov</span><span class="p">,</span> 
                    <span class="n">target_score_cov</span><span class="p">,</span> 
                    <span class="n">init_soln</span><span class="p">,</span> 
                    <span class="n">solve_args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;tol&#39;</span><span class="p">:</span><span class="mf">1.e-12</span><span class="p">},</span>
                    <span class="n">useC</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="n">prec_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">target_cov</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">prec_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">logdens_lin</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logdens_transform</span>
        <span class="n">target_lin</span> <span class="o">=</span> <span class="o">-</span> <span class="n">logdens_lin</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_score_cov</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec_target</span><span class="p">))</span>
        <span class="n">target_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">-</span> <span class="n">target_lin</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">observed_target</span><span class="p">)</span>

        <span class="n">cov_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span>
        <span class="n">prec_opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cov_opt</span><span class="p">)</span>

        <span class="n">mean_param</span> <span class="o">=</span> <span class="n">target_lin</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">parameter_target</span><span class="p">)</span> <span class="o">+</span> <span class="n">target_offset</span>
        <span class="n">conjugate_arg</span> <span class="o">=</span> <span class="n">prec_opt</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mean_param</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">useC</span><span class="p">:</span>
            <span class="n">solver</span> <span class="o">=</span> <span class="n">solve_barrier_affine_C</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">solver</span> <span class="o">=</span> <span class="n">_solve_barrier_affine_py</span>

        <span class="n">val</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">hess</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">conjugate_arg</span><span class="p">,</span>
                                 <span class="n">prec_opt</span><span class="p">,</span> <span class="c1"># JT: I think this quadratic is wrong should involve target_cov and target_lin too?</span>
                                 <span class="n">init_soln</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">affine_con</span><span class="o">.</span><span class="n">linear_part</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">affine_con</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">solve_args</span><span class="p">)</span>
            
        <span class="n">inter_map</span> <span class="o">=</span> <span class="n">target_cov</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_lin</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec_opt</span><span class="p">))</span>
        <span class="n">param_map</span> <span class="o">=</span> <span class="n">parameter_target</span> <span class="o">+</span> <span class="n">inter_map</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mean_param</span> <span class="o">-</span> <span class="n">soln</span><span class="p">)</span>
        <span class="n">log_normalizer_map</span> <span class="o">=</span> <span class="p">((</span><span class="n">parameter_target</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec_target</span> <span class="o">+</span> <span class="n">target_lin</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec_opt</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_lin</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">parameter_target</span><span class="p">))</span><span class="o">/</span><span class="mf">2.</span> 
                              <span class="o">-</span> <span class="n">parameter_target</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_lin</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec_opt</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">soln</span><span class="p">))</span> <span class="o">-</span> <span class="n">target_offset</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec_opt</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_offset</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span> 
                              <span class="o">+</span> <span class="n">val</span> <span class="o">-</span> <span class="p">(</span><span class="n">param_map</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec_target</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">param_map</span><span class="p">))</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

        <span class="n">jacobian_map</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span> <span class="o">+</span> <span class="n">inter_map</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_lin</span><span class="p">))</span> <span class="o">-</span> <span class="n">inter_map</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hess</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec_opt</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_lin</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">param_map</span><span class="p">,</span> <span class="n">log_normalizer_map</span><span class="p">,</span> <span class="n">jacobian_map</span></div>

    <span class="k">def</span> <span class="nf">_log_density_ray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">candidate</span><span class="p">,</span>
                         <span class="n">direction</span><span class="p">,</span>
                         <span class="n">nuisance</span><span class="p">,</span>
                         <span class="n">gaussian_sample</span><span class="p">,</span>
                         <span class="n">opt_sample</span><span class="p">):</span>

        <span class="c1"># implicitly caching (opt_sample, gaussian_sample) ?</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_direction&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_direction</span> <span class="o">==</span> <span class="n">direction</span><span class="p">)):</span>

            <span class="n">logdens_lin</span><span class="p">,</span> <span class="n">logdens_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logdens_transform</span>

            <span class="k">if</span> <span class="n">opt_sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                <span class="n">prec</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">quadratic_term</span> <span class="o">=</span> <span class="n">logdens_lin</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">prec</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="n">logdens_lin</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">nuisance</span> <span class="o">+</span> <span class="n">logdens_offset</span><span class="p">)</span> <span class="o">+</span> 
                       <span class="n">logdens_lin</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="o">*</span> <span class="n">gaussian_sample</span> <span class="o">+</span>
                       <span class="n">opt_sample</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">linear_term</span> <span class="o">=</span> <span class="n">logdens_lin</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="o">*</span> <span class="n">prec</span> <span class="o">*</span> <span class="n">arg</span>
                <span class="n">constant_term</span> <span class="o">=</span> <span class="n">arg</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">prec</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;linear_term&#39;</span><span class="p">:</span><span class="n">linear_term</span><span class="p">,</span>
                               <span class="s1">&#39;quadratic_term&#39;</span><span class="p">:</span><span class="n">quadratic_term</span><span class="p">,</span>
                               <span class="s1">&#39;constant_term&#39;</span><span class="p">:</span><span class="n">constant_term</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_direction</span> <span class="o">=</span> <span class="n">direction</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># density is a Gaussian evaluated at</span>
                <span class="c1"># O_i + A(N + (Z_i + theta) * gamma + b)</span>

                <span class="c1"># b is logdens_offset</span>
                <span class="c1"># A is logdens_linear</span>
                <span class="c1"># Z_i is gaussian_sample[i] (real-valued)</span>
                <span class="c1"># gamma is direction</span>
                <span class="c1"># O_i is opt_sample[i]</span>

                <span class="c1"># let arg1 = O_i</span>
                <span class="c1"># let arg2 = A(N+b + Z_i \cdot gamma)</span>
                <span class="c1"># then it is of the form (arg1 + arg2 + theta * A gamma)</span>

                <span class="n">logdens_lin</span><span class="p">,</span> <span class="n">logdens_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logdens_transform</span>
                <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span>
                <span class="n">prec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
                <span class="n">linear_part</span> <span class="o">=</span> <span class="n">logdens_lin</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="c1"># A gamma</span>

                <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">opt_sample</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">pass</span> <span class="c1"># stop3 what&#39;s this for?</span>
                <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span>

                <span class="n">quadratic_term</span> <span class="o">=</span> <span class="n">linear_part</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">linear_part</span><span class="p">)</span>

                <span class="n">arg1</span> <span class="o">=</span> <span class="n">opt_sample</span><span class="o">.</span><span class="n">T</span>
                <span class="n">arg2</span> <span class="o">=</span> <span class="n">logdens_lin</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">gaussian_sample</span><span class="p">)</span> <span class="o">+</span> 
                                       <span class="p">(</span><span class="n">nuisance</span> <span class="o">+</span> <span class="n">logdens_offset</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">])</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="n">arg1</span> <span class="o">+</span> <span class="n">arg2</span>
                <span class="n">linear_term</span> <span class="o">=</span> <span class="n">linear_part</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="n">constant_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">prec</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">*</span> <span class="n">arg</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;linear_term&#39;</span><span class="p">:</span><span class="n">linear_term</span><span class="p">,</span>
                               <span class="s1">&#39;quadratic_term&#39;</span><span class="p">:</span><span class="n">quadratic_term</span><span class="p">,</span>
                               <span class="s1">&#39;constant_term&#39;</span><span class="p">:</span><span class="n">constant_term</span><span class="p">}</span>
        <span class="p">(</span><span class="n">linear_term</span><span class="p">,</span> 
         <span class="n">quadratic_term</span><span class="p">,</span>
         <span class="n">constant_term</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;linear_term&#39;</span><span class="p">],</span> 
                           <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;quadratic_term&#39;</span><span class="p">],</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;constant_term&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">candidate</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">quadratic_term</span> <span class="o">-</span> 
                 <span class="n">candidate</span> <span class="o">*</span> <span class="n">linear_term</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">constant_term</span><span class="p">)</span></div>

<div class="viewcode-block" id="optimization_intervals"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.optimization_intervals">[docs]</a><span class="k">class</span> <span class="nc">optimization_intervals</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<div class="viewcode-block" id="optimization_intervals.__init__"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.optimization_intervals.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">opt_sampling_info</span><span class="p">,</span> <span class="c1"># a sequence of </span>
                                    <span class="c1"># (opt_sampler, </span>
                                    <span class="c1">#  opt_sample, </span>
                                    <span class="c1">#  opt_logweights,</span>
                                    <span class="c1">#  target_cov, </span>
                                    <span class="c1">#  score_cov) objects</span>
                                    <span class="c1">#  in theory all target_cov </span>
                                    <span class="c1">#  should be about the same...</span>
                 <span class="n">observed</span><span class="p">,</span>
                 <span class="n">nsample</span><span class="p">,</span> <span class="c1"># how large a normal sample</span>
                 <span class="n">target_cov</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">normal_sample</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># not all opt_samples will be of the same size as nsample </span>
        <span class="c1"># let&#39;s repeat them as necessary</span>
        
        <span class="n">tiled_sampling_info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">opt_sampler</span><span class="p">,</span> 
             <span class="n">opt_sample</span><span class="p">,</span> 
             <span class="n">opt_logW</span><span class="p">,</span>
             <span class="n">t_cov</span><span class="p">,</span> 
             <span class="n">t_score_cov</span><span class="p">)</span> <span class="ow">in</span> <span class="n">opt_sampling_info</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">opt_sample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opt_sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nsample</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">opt_sample</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">tiled_opt_sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">opt_sample</span><span class="p">,</span> 
                                              <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nsample</span> <span class="o">/</span> 
                                              <span class="n">opt_sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))[:</span><span class="n">nsample</span><span class="p">]</span>
                        <span class="n">tiled_opt_logW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">opt_logW</span><span class="p">,</span>
                                                 <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nsample</span> <span class="o">/</span> 
                                                             <span class="n">opt_logW</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))[:</span><span class="n">nsample</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tiled_opt_sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">opt_sample</span><span class="p">,</span> 
                                              <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nsample</span> <span class="o">/</span> 
                                              <span class="n">opt_sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="mi">1</span><span class="p">))[:</span><span class="n">nsample</span><span class="p">]</span>
                        <span class="n">tiled_opt_logW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">opt_logW</span><span class="p">,</span>
                                                 <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nsample</span> <span class="o">/</span> 
                                                              <span class="n">opt_logW</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="mi">1</span><span class="p">))[:</span><span class="n">nsample</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tiled_opt_sample</span> <span class="o">=</span> <span class="n">opt_sample</span><span class="p">[:</span><span class="n">nsample</span><span class="p">]</span>
                    <span class="n">tiled_opt_logW</span> <span class="o">=</span> <span class="n">opt_logW</span><span class="p">[:</span><span class="n">nsample</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tiled_sample</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">tiled_sampling_info</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">opt_sampler</span><span class="p">,</span> 
                                        <span class="n">tiled_opt_sample</span><span class="p">,</span> 
                                        <span class="n">tiled_opt_logW</span><span class="p">,</span>
                                        <span class="n">t_cov</span><span class="p">,</span> 
                                        <span class="n">t_score_cov</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span> <span class="o">=</span> <span class="n">tiled_sampling_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logden</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">opt_sampler</span><span class="p">,</span> <span class="n">opt_sample</span><span class="p">,</span> <span class="n">opt_logW</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">opt_sampling_info</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_logden</span> <span class="o">+=</span> <span class="n">opt_sampler</span><span class="o">.</span><span class="n">log_cond_density</span><span class="p">(</span>
                                <span class="n">opt_sample</span><span class="p">,</span>
                                <span class="n">opt_sampler</span><span class="o">.</span><span class="n">observed_score_state</span><span class="p">,</span>
                                <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">_logden</span> <span class="o">-=</span> <span class="n">opt_logW</span>
            <span class="k">if</span> <span class="n">opt_sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nsample</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_logden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_logden</span><span class="p">,</span> 
                                       <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nsample</span> <span class="o">/</span> 
                                       <span class="n">opt_sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))[:</span><span class="n">nsample</span><span class="p">]</span>

        <span class="c1"># this is our observed unpenalized estimator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed</span> <span class="o">=</span> <span class="n">observed</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># average covariances in case they might be different</span>

        <span class="k">if</span> <span class="n">target_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_cov</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">target_cov</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">opt_sampling_info</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_cov</span> <span class="o">+=</span> <span class="n">target_cov</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_cov</span> <span class="o">/=</span> <span class="nb">len</span><span class="p">(</span><span class="n">opt_sampling_info</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">normal_sample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normal_sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                                      <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
                                      <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_cov</span><span class="p">,</span> 
                                      <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">nsample</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normal_sample</span> <span class="o">=</span> <span class="n">normal_sample</span></div>

<div class="viewcode-block" id="optimization_intervals.pivot"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.optimization_intervals.pivot">[docs]</a>    <span class="k">def</span> <span class="nf">pivot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">linear_func</span><span class="p">,</span>
              <span class="n">candidate</span><span class="p">,</span>
              <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;twosided&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        alternative : [&#39;greater&#39;, &#39;less&#39;, &#39;twosided&#39;]</span>
<span class="sd">            What alternative to use.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pvalue : np.float</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">alternative</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;greater&#39;</span><span class="p">,</span> <span class="s1">&#39;less&#39;</span><span class="p">,</span> <span class="s1">&#39;twosided&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alternative should be one of [&#39;greater&#39;, &#39;less&#39;, &#39;twosided&#39;]&quot;</span><span class="p">)</span>

        <span class="n">observed_stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">linear_func</span><span class="p">)</span>
        <span class="n">sample_stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_sample</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">linear_func</span><span class="p">)</span>

        <span class="n">target_cov</span> <span class="o">=</span> <span class="n">linear_func</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_cov</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">linear_func</span><span class="p">))</span>

        <span class="n">nuisance</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">translate_dirs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">opt_sampler</span><span class="p">,</span> 
             <span class="n">opt_sample</span><span class="p">,</span> 
             <span class="n">_</span><span class="p">,</span> 
             <span class="n">_</span><span class="p">,</span> 
             <span class="n">target_score_cov</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span><span class="p">:</span>

            <span class="n">cur_score_cov</span> <span class="o">=</span> <span class="n">linear_func</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_score_cov</span><span class="p">)</span>

            <span class="c1"># cur_nuisance is in the view&#39;s score coordinates</span>
            <span class="n">cur_nuisance</span> <span class="o">=</span> <span class="n">opt_sampler</span><span class="o">.</span><span class="n">observed_score_state</span> <span class="o">-</span> <span class="n">cur_score_cov</span> <span class="o">*</span> <span class="n">observed_stat</span> <span class="o">/</span> <span class="n">target_cov</span>
            <span class="n">nuisance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_nuisance</span><span class="p">)</span>
            <span class="n">translate_dirs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_score_cov</span> <span class="o">/</span> <span class="n">target_cov</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">(</span><span class="n">sample_stat</span><span class="p">,</span>  <span class="c1"># normal sample </span>
                                <span class="n">candidate</span><span class="p">,</span>    <span class="c1"># candidate value</span>
                                <span class="n">nuisance</span><span class="p">,</span>       <span class="c1"># nuisance sufficient stats for each view</span>
                                <span class="n">translate_dirs</span><span class="p">)</span> <span class="c1"># points will be moved like sample * target_score_cov</span>

        <span class="n">pivot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">sample_stat</span> <span class="o">+</span> <span class="n">candidate</span> <span class="o">&lt;=</span> <span class="n">observed_stat</span><span class="p">)</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;twosided&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pivot</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">alternative</span> <span class="o">==</span> <span class="s1">&#39;less&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pivot</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pivot</span></div>

<div class="viewcode-block" id="optimization_intervals.confidence_interval"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.optimization_intervals.confidence_interval">[docs]</a>    <span class="k">def</span> <span class="nf">confidence_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                            <span class="n">linear_func</span><span class="p">,</span> 
                            <span class="n">level</span><span class="o">=</span><span class="mf">0.90</span><span class="p">,</span> 
                            <span class="n">how_many_sd</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                            <span class="n">guess</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">sample_stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_sample</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">linear_func</span><span class="p">)</span>
        <span class="n">observed_stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">linear_func</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">_rootU</span><span class="p">(</span><span class="n">gamma</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">linear_func</span><span class="p">,</span>
                              <span class="n">observed_stat</span> <span class="o">+</span> <span class="n">gamma</span><span class="p">,</span>
                              <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;less&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">level</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="k">def</span> <span class="nf">_rootL</span><span class="p">(</span><span class="n">gamma</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">linear_func</span><span class="p">,</span>
                              <span class="n">observed_stat</span> <span class="o">+</span> <span class="n">gamma</span><span class="p">,</span>
                              <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;less&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">level</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>

        <span class="k">if</span> <span class="n">guess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grid_min</span><span class="p">,</span> <span class="n">grid_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">how_many_sd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sample_stat</span><span class="p">),</span> <span class="n">how_many_sd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sample_stat</span><span class="p">)</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">bisect</span><span class="p">(</span><span class="n">_rootU</span><span class="p">,</span> <span class="n">grid_min</span><span class="p">,</span> <span class="n">grid_max</span><span class="p">)</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">bisect</span><span class="p">(</span><span class="n">_rootL</span><span class="p">,</span> <span class="n">grid_min</span><span class="p">,</span> <span class="n">grid_max</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">guess</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">guess</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            
            <span class="c1"># find interval bracketing upper solution</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">Lu</span><span class="p">,</span> <span class="n">Uu</span> <span class="o">=</span> <span class="n">guess</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">delta</span><span class="p">,</span> <span class="n">guess</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span>
                <span class="n">valU</span> <span class="o">=</span> <span class="n">_rootU</span><span class="p">(</span><span class="n">Uu</span><span class="p">)</span>
                <span class="n">valL</span> <span class="o">=</span> <span class="n">_rootU</span><span class="p">(</span><span class="n">Lu</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">valU</span> <span class="o">*</span> <span class="n">valL</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">delta</span> <span class="o">*=</span> <span class="mi">2</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">bisect</span><span class="p">(</span><span class="n">_rootU</span><span class="p">,</span> <span class="n">Lu</span><span class="p">,</span> <span class="n">Uu</span><span class="p">)</span>

            <span class="c1"># find interval bracketing lower solution</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">Ll</span><span class="p">,</span> <span class="n">Ul</span> <span class="o">=</span> <span class="n">guess</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">delta</span><span class="p">,</span> <span class="n">guess</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span>
                <span class="n">valU</span> <span class="o">=</span> <span class="n">_rootL</span><span class="p">(</span><span class="n">Ul</span><span class="p">)</span>
                <span class="n">valL</span> <span class="o">=</span> <span class="n">_rootL</span><span class="p">(</span><span class="n">Ll</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">valU</span> <span class="o">*</span> <span class="n">valL</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">delta</span> <span class="o">*=</span> <span class="mi">2</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">bisect</span><span class="p">(</span><span class="n">_rootL</span><span class="p">,</span> <span class="n">Ll</span><span class="p">,</span> <span class="n">Ul</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lower</span> <span class="o">+</span> <span class="n">observed_stat</span><span class="p">,</span> <span class="n">upper</span> <span class="o">+</span> <span class="n">observed_stat</span></div>

    <span class="c1"># Private methods</span>

    <span class="k">def</span> <span class="nf">_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">stat_sample</span><span class="p">,</span>
                 <span class="n">candidate</span><span class="p">,</span>
                 <span class="n">nuisance</span><span class="p">,</span>
                 <span class="n">translate_dirs</span><span class="p">):</span>

        <span class="c1"># Here we should loop through the views</span>
        <span class="c1"># and move the score of each view </span>
        <span class="c1"># for each projected (through linear_func) normal sample</span>
        <span class="c1"># using the linear decomposition</span>

        <span class="c1"># We need access to the map that takes observed_score for each view</span>
        <span class="c1"># and constructs the full randomization -- this is the reconstruction map</span>
        <span class="c1"># for each view</span>

        <span class="c1"># The data state for each view will be set to be N_i + A_i \hat{\theta}_i</span>
        <span class="c1"># where N_i is the nuisance sufficient stat for the i-th view&#39;s</span>
        <span class="c1"># data with respect to \hat{\theta} and N_i  will not change because</span>
        <span class="c1"># it depends on the observed \hat{\theta} and observed score of i-th view</span>

        <span class="c1"># In this function, \hat{\theta}_i will change with the Monte Carlo sample</span>

        <span class="n">score_sample</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">_lognum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">opt_info</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_sampling_info</span><span class="p">):</span>
            <span class="n">opt_sampler</span><span class="p">,</span> <span class="n">opt_sample</span> <span class="o">=</span> <span class="n">opt_info</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

            <span class="n">_lognum</span> <span class="o">+=</span> <span class="n">opt_sampler</span><span class="o">.</span><span class="n">log_cond_density</span><span class="p">(</span><span class="n">opt_sample</span><span class="p">,</span>
                                                    <span class="n">stat_sample</span> <span class="o">+</span> <span class="n">candidate</span><span class="p">,</span>
                                                    <span class="n">transform</span><span class="o">=</span>
                                                    <span class="p">(</span><span class="n">translate_dirs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                     <span class="n">nuisance</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="n">_logratio</span> <span class="o">=</span> <span class="n">_lognum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logden</span>
        <span class="n">_logratio</span> <span class="o">-=</span> <span class="n">_logratio</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">_logratio</span><span class="p">)</span></div>

<div class="viewcode-block" id="naive_confidence_intervals"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.naive_confidence_intervals">[docs]</a><span class="k">def</span> <span class="nf">naive_confidence_intervals</span><span class="p">(</span><span class="n">diag_cov</span><span class="p">,</span> <span class="n">observed</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute naive Gaussian based confidence</span>
<span class="sd">    intervals for target.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    diag_cov : diagonal of a covariance matrix</span>

<span class="sd">    observed : np.float</span>
<span class="sd">        A vector of observed data of shape `target.shape`</span>

<span class="sd">    alpha : float (optional)</span>
<span class="sd">        1 - confidence level.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    intervals : np.float</span>
<span class="sd">        Gaussian based confidence intervals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">level</span>
    <span class="n">diag_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">diag_cov</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">diag_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">quantile</span> <span class="o">=</span> <span class="o">-</span> <span class="n">ndist</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">LU</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">diag_cov</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">LU</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">observed</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">quantile</span>
        <span class="n">LU</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">observed</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">quantile</span>
    <span class="k">return</span> <span class="n">LU</span><span class="o">.</span><span class="n">T</span></div>

<div class="viewcode-block" id="naive_pvalues"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.naive_pvalues">[docs]</a><span class="k">def</span> <span class="nf">naive_pvalues</span><span class="p">(</span><span class="n">diag_cov</span><span class="p">,</span> <span class="n">observed</span><span class="p">,</span> <span class="n">parameter</span><span class="p">):</span>
    <span class="n">diag_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">diag_cov</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">diag_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">diag_cov</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="n">ndist</span><span class="o">.</span><span class="n">cdf</span><span class="p">((</span><span class="n">observed</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">parameter</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">/</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">pvalues</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">pval</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">pval</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pvalues</span></div>

<span class="c1"># private function</span>

<span class="k">def</span> <span class="nf">_solve_barrier_affine_py</span><span class="p">(</span><span class="n">conjugate_arg</span><span class="p">,</span>
                             <span class="n">precision</span><span class="p">,</span>
                             <span class="n">feasible_point</span><span class="p">,</span>
                             <span class="n">con_linear</span><span class="p">,</span>
                             <span class="n">con_offset</span><span class="p">,</span>
                             <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">nstep</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                             <span class="n">min_its</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
                             <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-10</span><span class="p">):</span>

    <span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">con_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">precision</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">con_linear</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">feasible_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">feasible_point</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">scaling</span>

    <span class="n">objective</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="o">-</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">conjugate_arg</span><span class="p">)</span> <span class="o">+</span> <span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">precision</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span> \
                          <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span> <span class="mf">1.</span><span class="o">/</span><span class="p">((</span><span class="n">con_offset</span> <span class="o">-</span> <span class="n">con_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">/</span> <span class="n">scaling</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="o">-</span><span class="n">conjugate_arg</span> <span class="o">+</span> <span class="n">precision</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="n">con_linear</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">scaling</span> <span class="o">+</span> <span class="n">con_offset</span> <span class="o">-</span> <span class="n">con_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="o">-</span>
                                                                       <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">con_offset</span> <span class="o">-</span> <span class="n">con_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">)))</span>
    <span class="n">barrier_hessian</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="n">con_linear</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="p">((</span><span class="n">scaling</span> <span class="o">+</span> <span class="n">con_offset</span><span class="o">-</span><span class="n">con_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span>
                                                 <span class="o">+</span> <span class="mf">1.</span><span class="o">/</span><span class="p">((</span><span class="n">con_offset</span><span class="o">-</span><span class="n">con_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">**</span><span class="mf">2.</span><span class="p">)))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">con_linear</span><span class="p">)</span>

    <span class="n">current</span> <span class="o">=</span> <span class="n">feasible_point</span>
    <span class="n">current_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="k">for</span> <span class="n">itercount</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstep</span><span class="p">):</span>
        <span class="n">cur_grad</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>

        <span class="c1"># make sure proposal is feasible</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">proposal</span> <span class="o">=</span> <span class="n">current</span> <span class="o">-</span> <span class="n">step</span> <span class="o">*</span> <span class="n">cur_grad</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">con_offset</span><span class="o">-</span><span class="n">con_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">proposal</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="n">step</span> <span class="o">*=</span> <span class="mf">0.5</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">40</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;not finding a feasible point&#39;</span><span class="p">)</span>

        <span class="c1"># make sure proposal is a descent</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">proposal</span> <span class="o">=</span> <span class="n">current</span> <span class="o">-</span> <span class="n">step</span> <span class="o">*</span> <span class="n">cur_grad</span>
            <span class="n">proposed_value</span> <span class="o">=</span> <span class="n">objective</span><span class="p">(</span><span class="n">proposal</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">proposed_value</span> <span class="o">&lt;=</span> <span class="n">current_value</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">step</span> <span class="o">*=</span> <span class="mf">0.5</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">20</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">proposed_value</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">current_value</span><span class="p">)):</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;value is NaN: </span><span class="si">%f</span><span class="s1">, </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">proposed_value</span><span class="p">,</span> <span class="n">current_value</span><span class="p">))</span>

        <span class="c1"># stop if relative decrease is small</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">current_value</span> <span class="o">-</span> <span class="n">proposed_value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">current_value</span><span class="p">)</span> <span class="ow">and</span> <span class="n">itercount</span> <span class="o">&gt;=</span> <span class="n">min_its</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">proposal</span>
            <span class="n">current_value</span> <span class="o">=</span> <span class="n">proposed_value</span>
            <span class="k">break</span>

        <span class="n">current</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="n">current_value</span> <span class="o">=</span> <span class="n">proposed_value</span>

        <span class="k">if</span> <span class="n">itercount</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">*=</span> <span class="mi">2</span>

    <span class="n">hess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">precision</span> <span class="o">+</span> <span class="n">barrier_hessian</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">current_value</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">hess</span>

<span class="k">def</span> <span class="nf">_solve_barrier_nonneg</span><span class="p">(</span><span class="n">conjugate_arg</span><span class="p">,</span>
                          <span class="n">precision</span><span class="p">,</span>
                          <span class="n">feasible_point</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">nstep</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                          <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">):</span>

    <span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">precision</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">feasible_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">feasible_point</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">scaling</span>

    <span class="n">objective</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="o">-</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">conjugate_arg</span><span class="p">)</span> <span class="o">+</span> <span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">precision</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">u</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="o">-</span><span class="n">conjugate_arg</span> <span class="o">+</span> <span class="n">precision</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">scaling</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="o">/</span><span class="n">u</span><span class="p">)</span>
    <span class="n">barrier_hessian</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="p">((</span><span class="n">scaling</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mf">2.</span><span class="p">))</span>

    <span class="n">current</span> <span class="o">=</span> <span class="n">feasible_point</span>
    <span class="n">current_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="k">for</span> <span class="n">itercount</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstep</span><span class="p">):</span>
        <span class="n">cur_grad</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>

        <span class="c1"># make sure proposal is feasible</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">proposal</span> <span class="o">=</span> <span class="n">current</span> <span class="o">-</span> <span class="n">step</span> <span class="o">*</span> <span class="n">cur_grad</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">proposal</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="n">step</span> <span class="o">*=</span> <span class="mf">0.5</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">40</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;not finding a feasible point&#39;</span><span class="p">)</span>

        <span class="c1"># make sure proposal is a descent</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">proposal</span> <span class="o">=</span> <span class="n">current</span> <span class="o">-</span> <span class="n">step</span> <span class="o">*</span> <span class="n">cur_grad</span>
            <span class="n">proposed_value</span> <span class="o">=</span> <span class="n">objective</span><span class="p">(</span><span class="n">proposal</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">proposed_value</span> <span class="o">&lt;=</span> <span class="n">current_value</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">step</span> <span class="o">*=</span> <span class="mf">0.5</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">20</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">proposed_value</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">current_value</span><span class="p">)):</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;value is NaN: </span><span class="si">%f</span><span class="s1">, </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">proposed_value</span><span class="p">,</span> <span class="n">current_value</span><span class="p">))</span>

        <span class="c1"># stop if relative decrease is small</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">current_value</span> <span class="o">-</span> <span class="n">proposed_value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">current_value</span><span class="p">):</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">proposal</span>
            <span class="n">current_value</span> <span class="o">=</span> <span class="n">proposed_value</span>
            <span class="k">break</span>

        <span class="n">current</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="n">current_value</span> <span class="o">=</span> <span class="n">proposed_value</span>

        <span class="k">if</span> <span class="n">itercount</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">*=</span> <span class="mi">2</span>

    <span class="n">hess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">precision</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">barrier_hessian</span><span class="p">(</span><span class="n">current</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">current_value</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">hess</span>

<div class="viewcode-block" id="selective_MLE"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.selective_MLE">[docs]</a><span class="k">def</span> <span class="nf">selective_MLE</span><span class="p">(</span><span class="n">observed_target</span><span class="p">,</span> 
                  <span class="n">target_cov</span><span class="p">,</span> 
                  <span class="n">target_score_cov</span><span class="p">,</span> 
                  <span class="n">init_soln</span><span class="p">,</span> <span class="c1"># initial (observed) value of optimization variables -- </span>
                             <span class="c1"># used as a feasible point.</span>
                             <span class="c1"># precise value used only for independent estimator </span>
                  <span class="n">cond_mean</span><span class="p">,</span>
                  <span class="n">cond_cov</span><span class="p">,</span>
                  <span class="n">logdens_linear</span><span class="p">,</span>
                  <span class="n">linear_part</span><span class="p">,</span>
                  <span class="n">offset</span><span class="p">,</span>
                  <span class="n">solve_args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;tol&#39;</span><span class="p">:</span><span class="mf">1.e-12</span><span class="p">},</span> 
                  <span class="n">level</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                  <span class="n">useC</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selective MLE based on approximation of</span>
<span class="sd">    CGF.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    observed_target : ndarray</span>
<span class="sd">        Observed estimate of target.</span>

<span class="sd">    target_cov : ndarray</span>
<span class="sd">        Estimated covaraince of target.</span>
<span class="sd">       </span>
<span class="sd">    target_score_cov : ndarray</span>
<span class="sd">        Estimated covariance of target and score of randomized query.</span>
<span class="sd">    </span>
<span class="sd">    init_soln : ndarray</span>
<span class="sd">        Feasible point for optimization problem.</span>

<span class="sd">    cond_mean : ndarray</span>
<span class="sd">        Conditional mean of optimization variables given target.</span>

<span class="sd">    cond_cov : ndarray</span>
<span class="sd">        Conditional covariance of optimization variables given target.</span>
<span class="sd">    </span>
<span class="sd">    logdens_linear : ndarray</span>
<span class="sd">        Describes how conditional mean of optimization</span>
<span class="sd">        variables varies with target.</span>
<span class="sd">    </span>
<span class="sd">    linear_part : ndarray</span>
<span class="sd">        Linear part of affine constraints: $\{o:Ao \leq b\}$</span>

<span class="sd">    offset : ndarray</span>
<span class="sd">        Offset part of affine constraints: $\{o:Ao \leq b\}$</span>

<span class="sd">    solve_args : dict, optional</span>
<span class="sd">        Arguments passed to solver.</span>

<span class="sd">    level : float, optional</span>
<span class="sd">        Confidence level.</span>

<span class="sd">    useC : bool, optional</span>
<span class="sd">        Use python or C solver.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">observed_target</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="ow">in</span> <span class="p">[(),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no target specified&#39;</span><span class="p">)</span>

    <span class="n">observed_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">observed_target</span><span class="p">)</span>
    <span class="n">prec_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">target_cov</span><span class="p">)</span>

    <span class="c1"># target_lin determines how the conditional mean of optimization variables</span>
    <span class="c1"># vary with target</span>
    <span class="c1"># logdens_linear determines how the argument of the optimization density</span>
    <span class="c1"># depends on the score, not how the mean depends on score, hence the minus sign</span>

    <span class="n">target_lin</span> <span class="o">=</span> <span class="o">-</span> <span class="n">logdens_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_score_cov</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec_target</span><span class="p">))</span> 
    <span class="n">target_offset</span> <span class="o">=</span> <span class="n">cond_mean</span> <span class="o">-</span> <span class="n">target_lin</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">observed_target</span><span class="p">)</span>

    <span class="n">prec_opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cond_cov</span><span class="p">)</span>

    <span class="n">conjugate_arg</span> <span class="o">=</span> <span class="n">prec_opt</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cond_mean</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">useC</span><span class="p">:</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="n">solve_barrier_affine_C</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="n">solve_barrier_affine_py</span>

    <span class="n">val</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">hess</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">conjugate_arg</span><span class="p">,</span>
                             <span class="n">prec_opt</span><span class="p">,</span>
                             <span class="n">init_soln</span><span class="p">,</span>
                             <span class="n">linear_part</span><span class="p">,</span>
                             <span class="n">offset</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">solve_args</span><span class="p">)</span>

    <span class="n">final_estimator</span> <span class="o">=</span> <span class="n">observed_target</span> <span class="o">+</span> <span class="n">target_cov</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_lin</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec_opt</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cond_mean</span> <span class="o">-</span> <span class="n">soln</span><span class="p">)))</span>
    <span class="n">ind_unbiased_estimator</span> <span class="o">=</span> <span class="n">observed_target</span> <span class="o">+</span> <span class="n">target_cov</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_lin</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec_opt</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cond_mean</span>
                                                                                            <span class="o">-</span> <span class="n">init_soln</span><span class="p">)))</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">target_lin</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec_opt</span><span class="p">)</span>
    <span class="n">observed_info_natural</span> <span class="o">=</span> <span class="n">prec_target</span> <span class="o">+</span> <span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_lin</span><span class="p">)</span> <span class="o">-</span> <span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hess</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
    <span class="n">observed_info_mean</span> <span class="o">=</span> <span class="n">target_cov</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">observed_info_natural</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_cov</span><span class="p">))</span>

    <span class="n">Z_scores</span> <span class="o">=</span> <span class="n">final_estimator</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">observed_info_mean</span><span class="p">))</span>
    <span class="n">pvalues</span> <span class="o">=</span> <span class="n">ndist</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Z_scores</span><span class="p">)</span>
    <span class="n">pvalues</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">pvalues</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pvalues</span><span class="p">)</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">level</span>
    <span class="n">quantile</span> <span class="o">=</span> <span class="n">ndist</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
    <span class="n">intervals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">final_estimator</span> <span class="o">-</span> <span class="n">quantile</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">observed_info_mean</span><span class="p">)),</span>
                           <span class="n">final_estimator</span> <span class="o">+</span> <span class="n">quantile</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">observed_info_mean</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">final_estimator</span><span class="p">,</span> <span class="n">observed_info_mean</span><span class="p">,</span> <span class="n">Z_scores</span><span class="p">,</span> <span class="n">pvalues</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">ind_unbiased_estimator</span></div>


<div class="viewcode-block" id="normalizing_constant"><a class="viewcode-back" href="../../../api/generated/selectinf.randomized.query.html#selectinf.randomized.cv_view.normalizing_constant">[docs]</a><span class="k">def</span> <span class="nf">normalizing_constant</span><span class="p">(</span><span class="n">target_parameter</span><span class="p">,</span>
                         <span class="n">observed_target</span><span class="p">,</span>
                         <span class="n">target_cov</span><span class="p">,</span>
                         <span class="n">target_score_cov</span><span class="p">,</span>
                         <span class="n">feasible_point</span><span class="p">,</span>
                         <span class="n">cond_mean</span><span class="p">,</span>
                         <span class="n">cond_cov</span><span class="p">,</span>
                         <span class="n">logdens_linear</span><span class="p">,</span>
                         <span class="n">linear_part</span><span class="p">,</span>
                         <span class="n">offset</span><span class="p">,</span>
                         <span class="n">useC</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Approximation of normalizing constant</span>
<span class="sd">    in affine constrained Gaussian.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    observed_target : ndarray</span>
<span class="sd">        Observed estimate of target.</span>

<span class="sd">    target_cov : ndarray</span>
<span class="sd">        Estimated covaraince of target.</span>
<span class="sd">       </span>
<span class="sd">    target_score_cov : ndarray</span>
<span class="sd">        Estimated covariance of target and score of randomized query.</span>
<span class="sd">    </span>
<span class="sd">    init_soln : ndarray</span>
<span class="sd">        Feasible point for optimization problem.</span>

<span class="sd">    cond_mean : ndarray</span>
<span class="sd">        Conditional mean of optimization variables given target.</span>

<span class="sd">    cond_cov : ndarray</span>
<span class="sd">        Conditional covariance of optimization variables given target.</span>
<span class="sd">    </span>
<span class="sd">    logdens_linear : ndarray</span>
<span class="sd">        Describes how conditional mean of optimization</span>
<span class="sd">        variables varies with target.</span>
<span class="sd">    </span>
<span class="sd">    linear_part : ndarray</span>
<span class="sd">        Linear part of affine constraints: $\{o:Ao \leq b\}$</span>

<span class="sd">    offset : ndarray</span>
<span class="sd">        Offset part of affine constraints: $\{o:Ao \leq b\}$</span>

<span class="sd">    solve_args : dict, optional</span>
<span class="sd">        Arguments passed to solver.</span>

<span class="sd">    level : float, optional</span>
<span class="sd">        Confidence level.</span>

<span class="sd">    useC : bool, optional</span>
<span class="sd">        Use python or C solver.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">target_parameter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">target_parameter</span><span class="p">)</span>

    <span class="n">cond_precision</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cond_cov</span><span class="p">)</span>
    <span class="n">prec_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">target_cov</span><span class="p">)</span>
    <span class="n">target_linear</span> <span class="o">=</span> <span class="o">-</span><span class="n">logdens_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_score_cov</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prec_target</span><span class="p">))</span>
    <span class="n">nuisance_correction</span> <span class="o">=</span> <span class="n">target_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">observed_target</span><span class="p">)</span>
    <span class="n">corrected_mean</span> <span class="o">=</span> <span class="n">cond_mean</span> <span class="o">-</span> <span class="n">nuisance_correction</span>

    <span class="c1"># rest of the objective is the target mahalanobis distance</span>
    <span class="c1"># plus the mahalanobis distance for optimization variables</span>
    <span class="c1"># this includes a term linear in the target, i.e.</span>
    <span class="c1"># the source of `target_linear`</span>

    <span class="n">ntarget</span> <span class="o">=</span> <span class="n">target_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nopt</span> <span class="o">=</span> <span class="n">cond_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">full_Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntarget</span> <span class="o">+</span> <span class="n">nopt</span><span class="p">,</span>
                       <span class="n">ntarget</span> <span class="o">+</span> <span class="n">nopt</span><span class="p">))</span>
    <span class="n">full_Q</span><span class="p">[:</span><span class="n">ntarget</span><span class="p">][:,:</span><span class="n">ntarget</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">prec_target</span> <span class="o">+</span> <span class="n">target_linear</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cond_precision</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_linear</span><span class="p">)))</span>
    <span class="n">full_Q</span><span class="p">[:</span><span class="n">ntarget</span><span class="p">][:,</span><span class="n">ntarget</span><span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">target_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cond_precision</span><span class="p">)</span>
    <span class="n">full_Q</span><span class="p">[</span><span class="n">ntarget</span><span class="p">:][:,:</span><span class="n">ntarget</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">target_linear</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cond_precision</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">full_Q</span><span class="p">[</span><span class="n">ntarget</span><span class="p">:][:,</span><span class="n">ntarget</span><span class="p">:]</span> <span class="o">=</span> <span class="n">cond_precision</span>

    <span class="n">linear_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="o">-</span><span class="n">prec_target</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_parameter</span><span class="p">)</span> <span class="o">+</span> 
                              <span class="n">corrected_mean</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cond_precision</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_linear</span><span class="p">),</span> 
                              <span class="o">-</span><span class="n">cond_precision</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">corrected_mean</span><span class="p">)])</span>

    <span class="n">constant_term</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">target_parameter</span> <span class="o">*</span> <span class="n">prec_target</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_parameter</span><span class="p">))</span> <span class="o">+</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">corrected_mean</span> <span class="o">*</span> <span class="n">cond_precision</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">corrected_mean</span><span class="p">)))</span>

    <span class="n">full_con_linear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">linear_part</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                <span class="n">ntarget</span> <span class="o">+</span> <span class="n">nopt</span><span class="p">))</span>
    <span class="n">full_con_linear</span><span class="p">[:,</span><span class="n">ntarget</span><span class="p">:]</span> <span class="o">=</span> <span class="n">linear_part</span>
    <span class="n">full_feasible</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ntarget</span> <span class="o">+</span> <span class="n">nopt</span><span class="p">)</span>
    <span class="n">full_feasible</span><span class="p">[</span><span class="n">ntarget</span><span class="p">:]</span> <span class="o">=</span> <span class="n">feasible_point</span>

    <span class="n">solve_args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;tol&#39;</span><span class="p">:</span><span class="mf">1.e-12</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">useC</span><span class="p">:</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="n">solve_barrier_affine_C</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="n">solve_barrier_affine_py</span>

    <span class="n">value</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">hess</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="o">-</span><span class="n">linear_term</span><span class="p">,</span>
                                <span class="n">full_Q</span><span class="p">,</span>
                                <span class="n">full_feasible</span><span class="p">,</span>
                                <span class="n">full_con_linear</span><span class="p">,</span>
                                <span class="n">offset</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">solve_args</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">value</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">target_parameter</span> <span class="o">*</span> <span class="n">prec_target</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_parameter</span><span class="p">)),</span> 
             <span class="n">soln</span><span class="p">[:</span><span class="n">ntarget</span><span class="p">],</span> 
             <span class="n">hess</span><span class="p">[:</span><span class="n">ntarget</span><span class="p">][:,:</span><span class="n">ntarget</span><span class="p">])</span></div>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright J. Taylor and others
      <span class="lastupdated">
        Last updated on Sep 24, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>