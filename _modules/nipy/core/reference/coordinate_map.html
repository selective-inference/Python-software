

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Selection &mdash; Selection Documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />


</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html">
          

          
            
            <img src="../../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../algorithms/index.html">Non-randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../randomized/index.html">Randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../learning/index.html">Learning selection</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">selection</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>Selection</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for nipy.core.reference.coordinate_map</h1><div class="highlight"><pre>
<span></span><span class="c1"># emacs: -*- mode: python; py-indent-offset: 4; indent-tabs-mode: nil -*-</span>
<span class="c1"># vi: set ft=python sts=4 ts=4 sw=4 et:</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module describes two types of *mappings*:</span>

<span class="sd">* CoordinateMap: a general function from a domain to a range, with a possible</span>
<span class="sd">  inverse function;</span>
<span class="sd">* AffineTransform: an affine function from a domain to a range, not</span>
<span class="sd">  necessarily of the same dimension, hence not always invertible.</span>

<span class="sd">Each of these objects is meant to encapsulate a tuple of (domain, range,</span>
<span class="sd">function).  Each of the mapping objects contain all the details about their</span>
<span class="sd">domain CoordinateSystem, their range CoordinateSystem and the mapping between</span>
<span class="sd">them.</span>

<span class="sd">Common API</span>
<span class="sd">----------</span>

<span class="sd">They are separate classes, neither one inheriting from the other.</span>
<span class="sd">They do, however, share some parts of an API, each having methods:</span>

<span class="sd">* renamed_domain : rename on the coordinates of the domain (returns a new</span>
<span class="sd">  mapping)</span>

<span class="sd">* renamed_range : rename the coordinates of the range (returns a new mapping)</span>

<span class="sd">* reordered_domain : reorder the coordinates of the domain (returns a new</span>
<span class="sd">  mapping)</span>

<span class="sd">* reordered_range : reorder the coordinates of the range (returns a new</span>
<span class="sd">  mapping)</span>

<span class="sd">* inverse : when appropriate, return the inverse *mapping*</span>

<span class="sd">These methods are implemented by module level functions of the same name.</span>

<span class="sd">They also share some attributes:</span>

<span class="sd">* ndims : the dimensions of the domain and range, respectively</span>

<span class="sd">* function_domain : CoordinateSystem describing the domain</span>

<span class="sd">* function_range : CoordinateSystem describing the range</span>

<span class="sd">Operations on mappings (module level functions)</span>
<span class="sd">-----------------------------------------------</span>

<span class="sd">* compose : Take a sequence of mappings (either CoordinateMaps or</span>
<span class="sd">  AffineTransforms) and return their composition. If they are all</span>
<span class="sd">  AffineTransforms, an AffineTransform is returned. This checks to ensure that</span>
<span class="sd">  domains and ranges of the various mappings agree.</span>
<span class="sd">* product : Take a sequence of mappings (either CoordinateMaps or</span>
<span class="sd">  AffineTransforms) and return a new mapping that has domain and range given by</span>
<span class="sd">  the concatenation of their domains and ranges, and the mapping simply</span>
<span class="sd">  concatenates the output of each of the individual mappings. If they are all</span>
<span class="sd">  AffineTransforms, an AffineTransform is returned. If they are all</span>
<span class="sd">  AffineTransforms that are in fact linear (i.e. origin=0) then can is</span>
<span class="sd">  represented as a block matrix with the size of the blocks determined by</span>
<span class="sd">* concat : Take a mapping and prepend a coordinate to its domain and</span>
<span class="sd">  range.  For mapping ``m``, this is the same as</span>
<span class="sd">  ``product(AffineTransform.identity(&#39;concat&#39;), m)``</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">npl</span>

<span class="kn">from</span> <span class="nn">nibabel.affines</span> <span class="k">import</span> <span class="n">to_matvec</span><span class="p">,</span> <span class="n">from_matvec</span>
<span class="kn">from</span> <span class="nn">...fixes.nibabel</span> <span class="k">import</span> <span class="n">io_orientation</span>

<span class="kn">from</span> <span class="nn">.coordinate_system</span> <span class="k">import</span><span class="p">(</span><span class="n">CoordinateSystem</span><span class="p">,</span>
                               <span class="n">safe_dtype</span><span class="p">,</span>
                               <span class="n">is_coordsys</span><span class="p">,</span>
                               <span class="n">product</span> <span class="k">as</span> <span class="n">coordsys_product</span>
                               <span class="p">)</span>

<span class="c1"># Legacy repr printing from numpy.</span>
<span class="kn">from</span> <span class="nn">nipy.testing</span> <span class="k">import</span> <span class="n">legacy_printing</span> <span class="k">as</span> <span class="n">setup_module</span>  <span class="c1"># noqa</span>

<span class="c1"># shorthand</span>
<span class="n">CS</span> <span class="o">=</span> <span class="n">CoordinateSystem</span>

<span class="c1"># Tolerance for small values in affine</span>
<span class="n">TINY</span> <span class="o">=</span> <span class="mf">1e-5</span>


<div class="viewcode-block" id="CoordinateMap"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.CoordinateMap">[docs]</a><span class="k">class</span> <span class="nc">CoordinateMap</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A set of domain and range CoordinateSystems and a function between them.</span>

<span class="sd">    For example, the function may represent the mapping of a voxel (the</span>
<span class="sd">    domain of the function) to real space (the range).  The function may</span>
<span class="sd">    be an affine or non-affine transformation.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    function_domain : :class:`CoordinateSystem` instance</span>
<span class="sd">       The input coordinate system.</span>
<span class="sd">    function_range : :class:`CoordinateSystem` instance</span>
<span class="sd">       The output coordinate system.</span>
<span class="sd">    function : callable</span>
<span class="sd">       A callable that maps the function_domain to the function_range.</span>
<span class="sd">    inverse_function : None or callable</span>
<span class="sd">       A callable that maps the function_range to the function_domain.</span>
<span class="sd">       Not all functions have an inverse, in which case inverse_function</span>
<span class="sd">       is None.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; function_domain = CoordinateSystem(&#39;ijk&#39;, &#39;voxels&#39;)</span>
<span class="sd">    &gt;&gt;&gt; function_range = CoordinateSystem(&#39;xyz&#39;, &#39;world&#39;)</span>
<span class="sd">    &gt;&gt;&gt; mni_orig = np.array([-90.0, -126.0, -72.0])</span>
<span class="sd">    &gt;&gt;&gt; function = lambda x: x + mni_orig</span>
<span class="sd">    &gt;&gt;&gt; inv_function = lambda x: x - mni_orig</span>
<span class="sd">    &gt;&gt;&gt; cm = CoordinateMap(function_domain, function_range, function, inv_function)</span>

<span class="sd">    Map the first 3 voxel coordinates, along the x-axis, to mni space:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[0,0,0], [1,0,0], [2,0,0]])</span>
<span class="sd">    &gt;&gt;&gt; cm.function(x)</span>
<span class="sd">    array([[ -90., -126.,  -72.],</span>
<span class="sd">           [ -89., -126.,  -72.],</span>
<span class="sd">           [ -88., -126.,  -72.]])</span>

<span class="sd">    &gt;&gt;&gt; x = CoordinateSystem(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = CoordinateSystem(&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; m = CoordinateMap(x, y, np.exp, np.log)</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    CoordinateMap(</span>
<span class="sd">       function_domain=CoordinateSystem(coord_names=(&#39;x&#39;,), name=&#39;&#39;, coord_dtype=float64),</span>
<span class="sd">       function_range=CoordinateSystem(coord_names=(&#39;y&#39;,), name=&#39;&#39;, coord_dtype=float64),</span>
<span class="sd">       function=&lt;ufunc &#39;exp&#39;&gt;,</span>
<span class="sd">       inverse_function=&lt;ufunc &#39;log&#39;&gt;</span>
<span class="sd">      )</span>
<span class="sd">    &gt;&gt;&gt; m.inverse()</span>
<span class="sd">    CoordinateMap(</span>
<span class="sd">       function_domain=CoordinateSystem(coord_names=(&#39;y&#39;,), name=&#39;&#39;, coord_dtype=float64),</span>
<span class="sd">       function_range=CoordinateSystem(coord_names=(&#39;x&#39;,), name=&#39;&#39;, coord_dtype=float64),</span>
<span class="sd">       function=&lt;ufunc &#39;log&#39;&gt;,</span>
<span class="sd">       inverse_function=&lt;ufunc &#39;exp&#39;&gt;</span>
<span class="sd">      )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_doc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span>
    <span class="n">_doc</span><span class="p">[</span><span class="s1">&#39;function&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;The function from function_domain to function_range.&#39;</span>

    <span class="n">function_domain</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">_doc</span><span class="p">[</span><span class="s1">&#39;function_domain&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;The domain of the function, a CoordinateSystem.&#39;</span>

    <span class="n">function_range</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="n">_doc</span><span class="p">[</span><span class="s1">&#39;function_range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;The range of the function, a CoordinateSystem.&#39;</span>

    <span class="n">inverse_function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span>
    <span class="n">_doc</span><span class="p">[</span><span class="s1">&#39;inverse_function&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;The inverse function from function_range&#39;</span> <span class="o">+</span> \
                               <span class="s1">&#39;to function_domain, if supplied.&#39;</span>

    <span class="n">ndims</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_doc</span><span class="p">[</span><span class="s1">&#39;ndims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Number of dimensions of domain and range, respectively.&#39;</span>

<div class="viewcode-block" id="CoordinateMap.__init__"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.CoordinateMap.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_domain</span><span class="p">,</span>
                 <span class="n">function_range</span><span class="p">,</span>
                 <span class="n">function</span><span class="p">,</span>
                 <span class="n">inverse_function</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a CoordinateMap given function, domain and range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function_domain : :class:`CoordinateSystem`</span>
<span class="sd">           The input coordinate system.</span>
<span class="sd">        function_range : :class:`CoordinateSystem`</span>
<span class="sd">           The output coordinate system</span>
<span class="sd">        function : callable</span>
<span class="sd">           The function between function_domain and function_range.  It</span>
<span class="sd">           should be a callable that accepts arrays of shape (N,</span>
<span class="sd">           function_domain.ndim) and returns arrays of shape (N,</span>
<span class="sd">           function_range.ndim), where N is the number of points for</span>
<span class="sd">           transformation.</span>
<span class="sd">        inverse_function : None or callable, optional</span>
<span class="sd">           The optional inverse of function, with the intention being</span>
<span class="sd">           ``x = inverse_function(function(x))``.  If the function is</span>
<span class="sd">           affine and invertible, then this is true for all x.  The</span>
<span class="sd">           default is None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coordmap : CoordinateMap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># These attrs define the structure of the coordmap.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_coordsys</span><span class="p">(</span><span class="n">function_domain</span><span class="p">):</span>
            <span class="n">function_domain</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">function_domain</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span> <span class="o">=</span> <span class="n">function_domain</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_coordsys</span><span class="p">(</span><span class="n">function_range</span><span class="p">):</span>
            <span class="n">function_range</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">function_range</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_range</span> <span class="o">=</span> <span class="n">function_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inverse_function</span> <span class="o">=</span> <span class="n">inverse_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span> <span class="o">=</span> <span class="p">(</span><span class="n">function_domain</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">function_range</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The function must be callable.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inverse_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">inverse_function</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The inverse_function must be callable.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkfunction</span><span class="p">()</span></div>

    <span class="c1"># All attributes are read only</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;the value of </span><span class="si">%s</span><span class="s1"> has already been &#39;</span>
                                 <span class="s1">&#39;set and all attributes are &#39;</span>
                                 <span class="s1">&#39;read-only&#39;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1">###################################################################</span>
    <span class="c1">#</span>
    <span class="c1"># Properties</span>
    <span class="c1">#</span>
    <span class="c1">###################################################################</span>


    <span class="c1">###################################################################</span>
    <span class="c1">#</span>
    <span class="c1"># Methods</span>
    <span class="c1">#</span>
    <span class="c1">###################################################################</span>

<div class="viewcode-block" id="CoordinateMap.reordered_domain"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.CoordinateMap.reordered_domain">[docs]</a>    <span class="k">def</span> <span class="nf">reordered_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new CoordinateMap with the coordinates of function_domain reordered.</span>
<span class="sd">        Default behaviour is to reverse the order of the coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : sequence</span>
<span class="sd">           Order to use, defaults to reverse. The elements can be</span>
<span class="sd">           integers, strings or 2-tuples of strings.  If they are</span>
<span class="sd">           strings, they should be in</span>
<span class="sd">           mapping.function_domain.coord_names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newmapping : CoordinateMap</span>
<span class="sd">           A new CoordinateMap with the coordinates of function_domain</span>
<span class="sd">           reordered.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; input_cs = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">        &gt;&gt;&gt; output_cs = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cm = CoordinateMap(input_cs, output_cs, lambda x:x+1)</span>
<span class="sd">        &gt;&gt;&gt; cm.reordered_domain(&#39;ikj&#39;).function_domain</span>
<span class="sd">        CoordinateSystem(coord_names=(&#39;i&#39;, &#39;k&#39;, &#39;j&#39;), name=&#39;&#39;, coord_dtype=float64)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">reordered_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoordinateMap.reordered_range"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.CoordinateMap.reordered_range">[docs]</a>    <span class="k">def</span> <span class="nf">reordered_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Nnew CoordinateMap with function_range reordered.</span>

<span class="sd">        Defaults to reversing the coordinates of function_range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : sequence</span>
<span class="sd">           Order to use, defaults to reverse. The elements can be</span>
<span class="sd">           integers, strings or 2-tuples of strings.  If they are</span>
<span class="sd">           strings, they should be in</span>
<span class="sd">           mapping.function_range.coord_names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newmapping : CoordinateMap</span>
<span class="sd">           A new CoordinateMap with the coordinates of function_range</span>
<span class="sd">           reordered.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; input_cs = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">        &gt;&gt;&gt; output_cs = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cm = CoordinateMap(input_cs, output_cs, lambda x:x+1)</span>
<span class="sd">        &gt;&gt;&gt; cm.reordered_range(&#39;xzy&#39;).function_range</span>
<span class="sd">        CoordinateSystem(coord_names=(&#39;x&#39;, &#39;z&#39;, &#39;y&#39;), name=&#39;&#39;, coord_dtype=float64)</span>
<span class="sd">        &gt;&gt;&gt; cm.reordered_range([0,2,1]).function_range.coord_names</span>
<span class="sd">        (&#39;x&#39;, &#39;z&#39;, &#39;y&#39;)</span>

<span class="sd">        &gt;&gt;&gt; newcm = cm.reordered_range(&#39;yzx&#39;)</span>
<span class="sd">        &gt;&gt;&gt; newcm.function_range.coord_names</span>
<span class="sd">        (&#39;y&#39;, &#39;z&#39;, &#39;x&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">reordered_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoordinateMap.renamed_domain"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.CoordinateMap.renamed_domain">[docs]</a>    <span class="k">def</span> <span class="nf">renamed_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newnames</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; New CoordinateMap with function_domain renamed</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newnames : dict</span>
<span class="sd">           A dictionary whose keys are integers or are in</span>
<span class="sd">           mapping.function_domain.coord_names and whose values are the</span>
<span class="sd">           new names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newmaping : CoordinateMap</span>
<span class="sd">           A new CoordinateMap with renamed function_domain.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; domain = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">        &gt;&gt;&gt; range = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cm = CoordinateMap(domain, range, lambda x:x+1)</span>

<span class="sd">        &gt;&gt;&gt; new_cm = cm.renamed_domain({&#39;i&#39;:&#39;phase&#39;,&#39;k&#39;:&#39;freq&#39;,&#39;j&#39;:&#39;slice&#39;})</span>
<span class="sd">        &gt;&gt;&gt; new_cm.function_domain</span>
<span class="sd">        CoordinateSystem(coord_names=(&#39;phase&#39;, &#39;slice&#39;, &#39;freq&#39;), name=&#39;&#39;, coord_dtype=float64)</span>

<span class="sd">        &gt;&gt;&gt; new_cm = cm.renamed_domain({&#39;i&#39;:&#39;phase&#39;,&#39;k&#39;:&#39;freq&#39;,&#39;l&#39;:&#39;slice&#39;})</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">           ...</span>
<span class="sd">        ValueError: no domain coordinate named l</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">renamed_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newnames</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoordinateMap.renamed_range"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.CoordinateMap.renamed_range">[docs]</a>    <span class="k">def</span> <span class="nf">renamed_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newnames</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; New CoordinateMap with function_domain renamed</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newnames : dict</span>
<span class="sd">           A dictionary whose keys are integers or are in</span>
<span class="sd">           mapping.function_range.coord_names and whose values are the</span>
<span class="sd">           new names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newmapping : CoordinateMap</span>
<span class="sd">           A new CoordinateMap with renamed function_range.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; domain = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">        &gt;&gt;&gt; range = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cm = CoordinateMap(domain, range, lambda x:x+1)</span>

<span class="sd">        &gt;&gt;&gt; new_cm = cm.renamed_range({&#39;x&#39;:&#39;u&#39;})</span>
<span class="sd">        &gt;&gt;&gt; new_cm.function_range</span>
<span class="sd">        CoordinateSystem(coord_names=(&#39;u&#39;, &#39;y&#39;, &#39;z&#39;), name=&#39;&#39;, coord_dtype=float64)</span>

<span class="sd">        &gt;&gt;&gt; new_cm = cm.renamed_range({&#39;w&#39;:&#39;u&#39;})</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">           ...</span>
<span class="sd">        ValueError: no range coordinate named w</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">renamed_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newnames</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoordinateMap.inverse"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.CoordinateMap.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; New CoordinateMap with the functions reversed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">CoordinateMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">inverse_function</span><span class="p">,</span>
                             <span class="n">inverse_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return mapping evaluated at x</span>

<span class="sd">        Also, check x and the return value of self.function for</span>
<span class="sd">        compatiblity with function_domain and function_range coordinate</span>
<span class="sd">        systems respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">           Values in domain coordinate system space that will be mapped</span>
<span class="sd">           to the range coordinate system space, using ``self.mapping``.</span>
<span class="sd">           The last dimension of the array is the coordinate dimension.</span>
<span class="sd">           Thus `x` can be any array that can be reshaped to (N,</span>
<span class="sd">           self.function_domain.ndim), and that matches</span>
<span class="sd">           self.function_domain dtype.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : array</span>
<span class="sd">           Values in range coordinate system space.  If input `x` was</span>
<span class="sd">           shape S + (self.function_domain.ndim) (where S is a tuple of</span>
<span class="sd">           int and can be ()) - then the output `y` will be shape S +</span>
<span class="sd">           (self.function_range.ndim)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; input_cs = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">        &gt;&gt;&gt; output_cs = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; function = lambda x:x+1</span>
<span class="sd">        &gt;&gt;&gt; inverse = lambda x:x-1</span>
<span class="sd">        &gt;&gt;&gt; cm = CoordinateMap(input_cs, output_cs, function, inverse)</span>
<span class="sd">        &gt;&gt;&gt; cm([2., 3., 4.])</span>
<span class="sd">        array([ 3.,  4.,  5.])</span>
<span class="sd">        &gt;&gt;&gt; cmi = cm.inverse()</span>
<span class="sd">        &gt;&gt;&gt; cmi([2., 6. ,12.])</span>
<span class="sd">        array([ 1.,  5., 11.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">out_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">ndim</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out_shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">out_shape</span>
        <span class="n">in_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">_checked_values</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">out_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">in_vals</span><span class="p">)</span>
        <span class="n">final_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">_checked_values</span><span class="p">(</span><span class="n">out_vals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">final_vals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a copy of the coordmap.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coordmap : CoordinateMap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CoordinateMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span>
                             <span class="n">inverse_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inverse_function</span><span class="p">)</span>

    <span class="c1">###################################################################</span>
    <span class="c1">#</span>
    <span class="c1"># Private methods</span>
    <span class="c1">#</span>
    <span class="c1">###################################################################</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;CoordinateMap(</span><span class="se">\n</span><span class="s2">   function_domain=</span><span class="si">%s</span><span class="s2">,</span><span class="se">\n</span><span class="s2">   function_range=</span><span class="si">%s</span><span class="s2">,</span><span class="se">\n</span><span class="s2">   function=</span><span class="si">%s</span><span class="se">\n</span><span class="s2">  )&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;CoordinateMap(</span><span class="se">\n</span><span class="s2">   function_domain=</span><span class="si">%s</span><span class="s2">,</span><span class="se">\n</span><span class="s2">   function_range=</span><span class="si">%s</span><span class="s2">,</span><span class="se">\n</span><span class="s2">   function=</span><span class="si">%s</span><span class="s2">,</span><span class="se">\n</span><span class="s2">   inverse_function=</span><span class="si">%s</span><span class="se">\n</span><span class="s2">  )&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inverse_function</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_checkfunction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify that the domain and range of self.function work</span>
<span class="sd">        can be used for calling self.function.</span>

<span class="sd">        We do this by passing something that should work, through __call__</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                       <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_dtype</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="ow">or</span>
                 <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">function</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span> <span class="o">==</span>
                     <span class="n">other</span><span class="o">.</span><span class="n">function_domain</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_range</span> <span class="o">==</span>
                     <span class="n">other</span><span class="o">.</span><span class="n">function_range</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inverse_function</span> <span class="o">==</span>
                     <span class="n">other</span><span class="o">.</span><span class="n">inverse_function</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="CoordinateMap.similar_to"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.CoordinateMap.similar_to">[docs]</a>    <span class="k">def</span> <span class="nf">similar_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Does `other` have similar coordinate systems and same mappings?</span>

<span class="sd">        A &quot;similar&quot; coordinate system is one with the same coordinate names and</span>
<span class="sd">        data dtype, but ignoring the coordinate system name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">function</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">similar_to</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">function_domain</span><span class="p">))</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">similar_to</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">function_range</span><span class="p">))</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inverse_function</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">inverse_function</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="AffineTransform"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.AffineTransform">[docs]</a><span class="k">class</span> <span class="nc">AffineTransform</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Class for affine transformation from domain to a range</span>

<span class="sd">    This class has an affine attribute, which is a matrix representing</span>
<span class="sd">    the affine transformation in homogeneous coordinates.  This matrix</span>
<span class="sd">    is used to evaluate the function, rather than having an explicit</span>
<span class="sd">    function (as is the case for a CoordinateMap).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; inp_cs = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">    &gt;&gt;&gt; out_cs = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; cm = AffineTransform(inp_cs, out_cs, np.diag([1, 2, 3, 1]))</span>
<span class="sd">    &gt;&gt;&gt; cm</span>
<span class="sd">    AffineTransform(</span>
<span class="sd">       function_domain=CoordinateSystem(coord_names=(&#39;i&#39;, &#39;j&#39;, &#39;k&#39;), name=&#39;&#39;, coord_dtype=float64),</span>
<span class="sd">       function_range=CoordinateSystem(coord_names=(&#39;x&#39;, &#39;y&#39;, &#39;z&#39;), name=&#39;&#39;, coord_dtype=float64),</span>
<span class="sd">       affine=array([[ 1.,  0.,  0.,  0.],</span>
<span class="sd">                     [ 0.,  2.,  0.,  0.],</span>
<span class="sd">                     [ 0.,  0.,  3.,  0.],</span>
<span class="sd">                     [ 0.,  0.,  0.,  1.]])</span>
<span class="sd">    )</span>

<span class="sd">    &gt;&gt;&gt; cm.affine</span>
<span class="sd">    array([[ 1.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  2.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  3.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; cm([1,1,1])</span>
<span class="sd">    array([ 1.,  2.,  3.])</span>
<span class="sd">    &gt;&gt;&gt; icm = cm.inverse()</span>
<span class="sd">    &gt;&gt;&gt; icm([1,2,3])</span>
<span class="sd">    array([ 1.,  1.,  1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_doc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">_doc</span><span class="p">[</span><span class="s1">&#39;affine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;The matrix representing an affine transformation &#39;</span> <span class="o">+</span> \
                       <span class="s1">&#39;homogeneous form.&#39;</span>

    <span class="n">function_domain</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">_doc</span><span class="p">[</span><span class="s1">&#39;function_domain&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;The domain of the affine transformation, &#39;</span> <span class="o">+</span> \
                              <span class="s1">&#39;a CoordinateSystem.&#39;</span>

    <span class="n">function_range</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="n">_doc</span><span class="p">[</span><span class="s1">&#39;function_range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;The range of the affine transformation, &#39;</span> <span class="o">+</span> \
                             <span class="s1">&#39;a CoordinateSystem.&#39;</span>

    <span class="n">ndims</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">_doc</span><span class="p">[</span><span class="s1">&#39;ndims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Number of dimensions of domain and range, respectively.&#39;</span>

<div class="viewcode-block" id="AffineTransform.__init__"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.AffineTransform.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_domain</span><span class="p">,</span> <span class="n">function_range</span><span class="p">,</span> <span class="n">affine</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialize AffineTransform</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function_domain : :class:`CoordinateSystem`</span>
<span class="sd">           input coordinates</span>
<span class="sd">        function_range : :class:`CoordinateSystem`</span>
<span class="sd">           output coordinates</span>
<span class="sd">        affine : array-like</span>
<span class="sd">           affine homogenous coordinate matrix</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The dtype of the resulting matrix is determined by finding a</span>
<span class="sd">        safe typecast for the function_domain, function_range and affine.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_coordsys</span><span class="p">(</span><span class="n">function_domain</span><span class="p">):</span>
            <span class="n">function_domain</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">function_domain</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_coordsys</span><span class="p">(</span><span class="n">function_range</span><span class="p">):</span>
            <span class="n">function_range</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">function_range</span><span class="p">)</span>
        <span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">affine</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">safe_dtype</span><span class="p">(</span><span class="n">affine</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                           <span class="n">function_domain</span><span class="o">.</span><span class="n">coord_dtype</span><span class="p">,</span>
                           <span class="n">function_range</span><span class="o">.</span><span class="n">coord_dtype</span><span class="p">)</span>
        <span class="n">inaxes</span> <span class="o">=</span> <span class="n">function_domain</span><span class="o">.</span><span class="n">coord_names</span>
        <span class="n">outaxes</span> <span class="o">=</span> <span class="n">function_range</span><span class="o">.</span><span class="n">coord_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">inaxes</span><span class="p">,</span>
                                                <span class="n">function_domain</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                                <span class="n">dtype</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">function_range</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">outaxes</span><span class="p">,</span>
                                               <span class="n">function_range</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                               <span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">affine</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;coordinate lengths do not match &#39;</span>
                             <span class="s1">&#39;affine matrix shape&#39;</span><span class="p">)</span>
        <span class="c1"># Test that it is actually an affine mapping in homogeneous</span>
        <span class="c1"># form</span>
        <span class="n">bottom_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ndims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">affine</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">bottom_row</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the homogeneous transform should have bottom=&#39;</span> <span class="o">+</span> \
                             <span class="s1">&#39;row </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">bottom_row</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">affine</span> <span class="o">=</span> <span class="n">affine</span></div>

    <span class="c1">###################################################################</span>
    <span class="c1">#</span>
    <span class="c1"># Properties</span>
    <span class="c1">#</span>
    <span class="c1">###################################################################</span>

<div class="viewcode-block" id="AffineTransform.inverse"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.AffineTransform.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preserve_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return coordinate map with inverse affine transform or None</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        preserve_dtype : bool</span>
<span class="sd">            If False, return affine mapping from inverting the ``affine``.  The</span>
<span class="sd">            domain / range dtypes for the inverse may then change as a function</span>
<span class="sd">            of the dtype of the inverted ``affine``.  If True, try to invert our</span>
<span class="sd">            ``affine``, and see if it can be cast to the needed data type, which</span>
<span class="sd">            is ``self.function_domain.coord_dtype``.  We need this dtype in</span>
<span class="sd">            order for the inverse to preserve the coordinate system dtypes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        aff_cm_inv : ``AffineTransform`` instance or None</span>
<span class="sd">            ``AffineTransform`` mapping from the *range* of input `self` to the</span>
<span class="sd">            *domain* of input `self` - the inverse of `self`.  If</span>
<span class="sd">            ``self.affine`` was not invertible return None.  If `preserve_dtype`</span>
<span class="sd">            is True, and the inverse of ``self.affine`` cannot be cast to</span>
<span class="sd">            ``self.function_domain.coord_dtype``, then return None.  Otherwise</span>
<span class="sd">            return ``AffineTransform`` inverse mapping.  If `preserve_dtype` is</span>
<span class="sd">            False, the domain / range dtypes of the return inverse may well be</span>
<span class="sd">            different from those of the input `self`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; input_cs = CoordinateSystem(&#39;ijk&#39;, coord_dtype=np.int)</span>
<span class="sd">        &gt;&gt;&gt; output_cs = CoordinateSystem(&#39;xyz&#39;, coord_dtype=np.int)</span>
<span class="sd">        &gt;&gt;&gt; affine = np.array([[1,0,0,1],</span>
<span class="sd">        ...                    [0,1,0,1],</span>
<span class="sd">        ...                    [0,0,1,1],</span>
<span class="sd">        ...                    [0,0,0,1]])</span>
<span class="sd">        &gt;&gt;&gt; affine_transform = AffineTransform(input_cs, output_cs, affine)</span>
<span class="sd">        &gt;&gt;&gt; affine_transform([2,3,4]) #doctest: +IGNORE_DTYPE</span>
<span class="sd">        array([3, 4, 5])</span>

<span class="sd">        The inverse transform, by default, generates a floating point inverse</span>
<span class="sd">        matrix and therefore floating point output:</span>

<span class="sd">        &gt;&gt;&gt; affine_transform_inv = affine_transform.inverse()</span>
<span class="sd">        &gt;&gt;&gt; affine_transform_inv([2, 6, 12])</span>
<span class="sd">        array([  1.,   5.,  11.])</span>

<span class="sd">        You can force it to preserve the coordinate system dtype with the</span>
<span class="sd">        `preserve_dtype` flag:</span>

<span class="sd">        &gt;&gt;&gt; at_inv_preserved = affine_transform.inverse(preserve_dtype=True)</span>
<span class="sd">        &gt;&gt;&gt; at_inv_preserved([2, 6, 12]) #doctest: +IGNORE_DTYPE</span>
<span class="sd">        array([  1,   5,  11])</span>

<span class="sd">        If you `preserve_dtype`, and there is no inverse affine preserving the</span>
<span class="sd">        dtype, the inverse is None:</span>

<span class="sd">        &gt;&gt;&gt; affine2 = affine.copy()</span>
<span class="sd">        &gt;&gt;&gt; affine2[0, 0] = 2 # now inverse can&#39;t be integer</span>
<span class="sd">        &gt;&gt;&gt; aff_t = AffineTransform(input_cs, output_cs, affine2)</span>
<span class="sd">        &gt;&gt;&gt; aff_t.inverse(preserve_dtype=True) is None</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aff_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_dtype</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">m_inv</span> <span class="o">=</span> <span class="n">npl</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">npl</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># Try using sympy for the inverse.  This might be needed for sympy</span>
            <span class="c1"># symbols in the affine, or Float128, or complex numbers.</span>
            <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">matrix2numpy</span>
            <span class="n">sym_inv</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
            <span class="n">m_inv</span> <span class="o">=</span> <span class="n">matrix2numpy</span><span class="p">(</span><span class="n">sym_inv</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">aff_dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># linalg inverse succeeded</span>
            <span class="k">if</span> <span class="n">preserve_dtype</span> <span class="ow">and</span> <span class="n">aff_dt</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">:</span> <span class="c1"># can we cast back?</span>
                <span class="n">m_inv_orig</span> <span class="o">=</span> <span class="n">m_inv</span>
                <span class="n">m_inv</span> <span class="o">=</span> <span class="n">m_inv</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">aff_dt</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">m_inv_orig</span><span class="p">,</span> <span class="n">m_inv</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span>
                               <span class="n">m_inv</span><span class="p">)</span></div>

    <span class="c1">###################################################################</span>
    <span class="c1">#</span>
    <span class="c1"># Helper constructors</span>
    <span class="c1">#</span>
    <span class="c1">###################################################################</span>

<div class="viewcode-block" id="AffineTransform.from_params"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.AffineTransform.from_params">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_params</span><span class="p">(</span><span class="n">innames</span><span class="p">,</span> <span class="n">outnames</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">domain_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                    <span class="n">range_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create `AffineTransform` from `innames` and `outnames`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        innames : sequence of str or str</span>
<span class="sd">           The names of the axes of the domain.  If str, then names</span>
<span class="sd">           given by ``list(innames)``</span>
<span class="sd">        outnames : seqence of str or str</span>
<span class="sd">           The names of the axes of the range. If str, then names</span>
<span class="sd">           given by ``list(outnames)``</span>
<span class="sd">        params : AffineTransform, array or (array, array)</span>
<span class="sd">           An affine function between the domain and range.</span>
<span class="sd">           This can be represented either by a single</span>
<span class="sd">           ndarray (which is interpreted as the representation of the</span>
<span class="sd">           function in homogeneous coordinates) or an (A,b) tuple.</span>
<span class="sd">        domain_name : str, optional</span>
<span class="sd">           Name of domain CoordinateSystem</span>
<span class="sd">        range_name : str, optional</span>
<span class="sd">           Name of range CoordinateSystem</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        aff : ``AffineTransform``</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        :Precondition: ``len(shape) == len(names)``</span>
<span class="sd">        :Raises ValueError: ``if len(shape) != len(names)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(()):</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">params</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">from_matvec</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">innames</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">outnames</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shape and number of axis names do not agree&#39;</span><span class="p">)</span>
        <span class="n">function_domain</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">innames</span><span class="p">,</span> <span class="n">domain_name</span><span class="p">)</span>
        <span class="n">function_range</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">outnames</span><span class="p">,</span> <span class="n">range_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="n">function_domain</span><span class="p">,</span> <span class="n">function_range</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span></div>

<div class="viewcode-block" id="AffineTransform.from_start_step"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.AffineTransform.from_start_step">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_start_step</span><span class="p">(</span><span class="n">innames</span><span class="p">,</span> <span class="n">outnames</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">domain_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                        <span class="n">range_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; New `AffineTransform` from names, start and step.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        innames : sequence of str or str</span>
<span class="sd">           The names of the axes of the domain.  If str, then names</span>
<span class="sd">           given by ``list(innames)``</span>
<span class="sd">        outnames : seqence of str or str</span>
<span class="sd">           The names of the axes of the range. If str, then names</span>
<span class="sd">           given by ``list(outnames)``</span>
<span class="sd">        start : sequence of float</span>
<span class="sd">           Start vector used in constructing affine transformation</span>
<span class="sd">        step : sequence of float</span>
<span class="sd">           Step vector used in constructing affine transformation</span>
<span class="sd">        domain_name : str, optional</span>
<span class="sd">           Name of domain CoordinateSystem</span>
<span class="sd">        range_name : str, optional</span>
<span class="sd">           Name of range CoordinateSystem</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cm : `CoordinateMap`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; cm = AffineTransform.from_start_step(&#39;ijk&#39;, &#39;xyz&#39;, [1, 2, 3], [4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; cm.affine</span>
<span class="sd">        array([[ 4.,  0.,  0.,  1.],</span>
<span class="sd">               [ 0.,  5.,  0.,  2.],</span>
<span class="sd">               [ 0.,  0.,  6.,  3.],</span>
<span class="sd">               [ 0.,  0.,  0.,  1.]])</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        ``len(names) == len(start) == len(step)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">innames</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outnames</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;len(innames) != len(outnames)&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">AffineTransform</span><span class="o">.</span><span class="n">from_params</span><span class="p">(</span><span class="n">innames</span><span class="p">,</span>
                                           <span class="n">outnames</span><span class="p">,</span>
                                           <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">step</span><span class="p">),</span> <span class="n">start</span><span class="p">),</span>
                                           <span class="n">domain_name</span><span class="o">=</span><span class="n">domain_name</span><span class="p">,</span>
                                           <span class="n">range_name</span><span class="o">=</span><span class="n">range_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="AffineTransform.identity"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.AffineTransform.identity">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return an identity coordmap of the given shape</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord_names : sequence of str or str</span>
<span class="sd">           The names of the axes of the domain.  If str, then names</span>
<span class="sd">           given by ``list(coord_names)``</span>
<span class="sd">        name : str, optional</span>
<span class="sd">           Name of origin of coordinate system</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cm : `CoordinateMap`</span>
<span class="sd">           ``CoordinateMap`` with ``CoordinateSystem`` domain and an</span>
<span class="sd">           identity transform, with identical domain and range.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; cm = AffineTransform.identity(&#39;ijk&#39;, &#39;somewhere&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cm.affine</span>
<span class="sd">        array([[ 1.,  0.,  0.,  0.],</span>
<span class="sd">               [ 0.,  1.,  0.,  0.],</span>
<span class="sd">               [ 0.,  0.,  1.,  0.],</span>
<span class="sd">               [ 0.,  0.,  0.,  1.]])</span>
<span class="sd">        &gt;&gt;&gt; cm.function_domain</span>
<span class="sd">        CoordinateSystem(coord_names=(&#39;i&#39;, &#39;j&#39;, &#39;k&#39;), name=&#39;somewhere&#39;, coord_dtype=float64)</span>
<span class="sd">        &gt;&gt;&gt; cm.function_range</span>
<span class="sd">        CoordinateSystem(coord_names=(&#39;i&#39;, &#39;j&#39;, &#39;k&#39;), name=&#39;somewhere&#39;, coord_dtype=float64)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AffineTransform</span><span class="o">.</span><span class="n">from_start_step</span><span class="p">(</span><span class="n">coord_names</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">coord_names</span><span class="p">),</span>
                                      <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">coord_names</span><span class="p">),</span> <span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


    <span class="c1">###################################################################</span>
    <span class="c1">#</span>
    <span class="c1"># Methods</span>
    <span class="c1">#</span>
    <span class="c1">###################################################################</span>

<div class="viewcode-block" id="AffineTransform.reordered_domain"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.AffineTransform.reordered_domain">[docs]</a>    <span class="k">def</span> <span class="nf">reordered_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; New AffineTransform with function_domain reordered</span>

<span class="sd">        Default behaviour is to reverse the order of the coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : sequence</span>
<span class="sd">           Order to use, defaults to reverse. The elements can be</span>
<span class="sd">           integers, strings or 2-tuples of strings.  If they are</span>
<span class="sd">           strings, they should be in</span>
<span class="sd">           mapping.function_domain.coord_names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newmapping :AffineTransform</span>
<span class="sd">           A new AffineTransform with the coordinates of function_domain</span>
<span class="sd">           reordered.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; input_cs = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">        &gt;&gt;&gt; output_cs = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cm = AffineTransform(input_cs, output_cs, np.identity(4))</span>
<span class="sd">        &gt;&gt;&gt; cm.reordered_domain(&#39;ikj&#39;).function_domain</span>
<span class="sd">        CoordinateSystem(coord_names=(&#39;i&#39;, &#39;k&#39;, &#39;j&#39;), name=&#39;&#39;, coord_dtype=float64)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">reordered_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>

<div class="viewcode-block" id="AffineTransform.reordered_range"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.AffineTransform.reordered_range">[docs]</a>    <span class="k">def</span> <span class="nf">reordered_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; New AffineTransform with function_range reordered</span>

<span class="sd">        Defaults to reversing the coordinates of function_range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : sequence</span>
<span class="sd">           Order to use, defaults to reverse. The elements can be</span>
<span class="sd">           integers, strings or 2-tuples of strings.  If they are</span>
<span class="sd">           strings, they should be in</span>
<span class="sd">           mapping.function_range.coord_names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newmapping : AffineTransform</span>
<span class="sd">           A new AffineTransform with the coordinates of function_range</span>
<span class="sd">           reordered.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; input_cs = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">        &gt;&gt;&gt; output_cs = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cm = AffineTransform(input_cs, output_cs, np.identity(4))</span>
<span class="sd">        &gt;&gt;&gt; cm.reordered_range(&#39;xzy&#39;).function_range</span>
<span class="sd">        CoordinateSystem(coord_names=(&#39;x&#39;, &#39;z&#39;, &#39;y&#39;), name=&#39;&#39;, coord_dtype=float64)</span>
<span class="sd">        &gt;&gt;&gt; cm.reordered_range([0,2,1]).function_range.coord_names</span>
<span class="sd">        (&#39;x&#39;, &#39;z&#39;, &#39;y&#39;)</span>

<span class="sd">        &gt;&gt;&gt; newcm = cm.reordered_range(&#39;yzx&#39;)</span>
<span class="sd">        &gt;&gt;&gt; newcm.function_range.coord_names</span>
<span class="sd">        (&#39;y&#39;, &#39;z&#39;, &#39;x&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">reordered_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>

<div class="viewcode-block" id="AffineTransform.renamed_domain"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.AffineTransform.renamed_domain">[docs]</a>    <span class="k">def</span> <span class="nf">renamed_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newnames</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; New AffineTransform with function_domain renamed</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newnames : dict</span>
<span class="sd">           A dictionary whose keys are integers or are in</span>
<span class="sd">           mapping.function_domain.coord_names and whose values are the</span>
<span class="sd">           new names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newmapping : AffineTransform</span>
<span class="sd">           A new AffineTransform with renamed function_domain.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; affine_domain = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">        &gt;&gt;&gt; affine_range = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; affine_matrix = np.identity(4)</span>
<span class="sd">        &gt;&gt;&gt; affine_mapping = AffineTransform(affine_domain, affine_range, affine_matrix)</span>

<span class="sd">        &gt;&gt;&gt; new_affine_mapping = affine_mapping.renamed_domain({&#39;i&#39;:&#39;phase&#39;,&#39;k&#39;:&#39;freq&#39;,&#39;j&#39;:&#39;slice&#39;})</span>
<span class="sd">        &gt;&gt;&gt; new_affine_mapping.function_domain</span>
<span class="sd">        CoordinateSystem(coord_names=(&#39;phase&#39;, &#39;slice&#39;, &#39;freq&#39;), name=&#39;&#39;, coord_dtype=float64)</span>

<span class="sd">        &gt;&gt;&gt; new_affine_mapping = affine_mapping.renamed_domain({&#39;i&#39;:&#39;phase&#39;,&#39;k&#39;:&#39;freq&#39;,&#39;l&#39;:&#39;slice&#39;})</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">           ...</span>
<span class="sd">        ValueError: no domain coordinate named l</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">renamed_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newnames</span><span class="p">)</span></div>

<div class="viewcode-block" id="AffineTransform.renamed_range"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.AffineTransform.renamed_range">[docs]</a>    <span class="k">def</span> <span class="nf">renamed_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newnames</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; New AffineTransform with renamed function_domain</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newnames : dict</span>
<span class="sd">           A dictionary whose keys are integers or are in</span>
<span class="sd">           mapping.function_range.coord_names and whose values are the</span>
<span class="sd">           new names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newmapping : AffineTransform</span>
<span class="sd">           A new AffineTransform with renamed function_range.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; affine_domain = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">        &gt;&gt;&gt; affine_range = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; affine_matrix = np.identity(4)</span>
<span class="sd">        &gt;&gt;&gt; affine_mapping = AffineTransform(affine_domain, affine_range, affine_matrix)</span>

<span class="sd">        &gt;&gt;&gt; new_affine_mapping = affine_mapping.renamed_range({&#39;x&#39;:&#39;u&#39;})</span>
<span class="sd">        &gt;&gt;&gt; new_affine_mapping.function_range</span>
<span class="sd">        CoordinateSystem(coord_names=(&#39;u&#39;, &#39;y&#39;, &#39;z&#39;), name=&#39;&#39;, coord_dtype=float64)</span>

<span class="sd">        &gt;&gt;&gt; new_affine_mapping = affine_mapping.renamed_range({&#39;w&#39;:&#39;u&#39;})</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">           ...</span>
<span class="sd">        ValueError: no range coordinate named w</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">renamed_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newnames</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return mapping evaluated at x</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">           Values in domain coordinate system space that will be mapped</span>
<span class="sd">           to the range coordinate system space, using the homogeneous</span>
<span class="sd">           transform matrix self.affine.  The last dimension of the</span>
<span class="sd">           array is the coordinate dimension.  Thus `x` can be any array</span>
<span class="sd">           that can be reshaped to (N, self.function_domain.ndim), and</span>
<span class="sd">           that matches self.function_domain dtype.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : array</span>
<span class="sd">           Values in range coordinate system space. If input `x` was</span>
<span class="sd">           shape S + (self.function_domain.ndim) (where S is a tuple of</span>
<span class="sd">           int and can be ()) - then the output `y` will be shape S +</span>
<span class="sd">           (self.function_range.ndim)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; input_cs = CoordinateSystem(&#39;ijk&#39;, coord_dtype=np.int)</span>
<span class="sd">        &gt;&gt;&gt; output_cs = CoordinateSystem(&#39;xyz&#39;, coord_dtype=np.int)</span>
<span class="sd">        &gt;&gt;&gt; affine = np.array([[1,0,0,1],</span>
<span class="sd">        ...                    [0,1,0,1],</span>
<span class="sd">        ...                    [0,0,1,1],</span>
<span class="sd">        ...                    [0,0,0,1]])</span>
<span class="sd">        &gt;&gt;&gt; affine_transform = AffineTransform(input_cs, output_cs, affine)</span>
<span class="sd">        &gt;&gt;&gt; affine_transform([2,3,4]) #doctest: +IGNORE_DTYPE</span>
<span class="sd">        array([3, 4, 5])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">out_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">ndim</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out_shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">out_shape</span>
        <span class="n">in_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">_checked_values</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">to_matvec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span>
        <span class="n">out_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">in_vals</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
        <span class="n">final_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">_checked_values</span><span class="p">(</span><span class="n">out_vals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">final_vals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>

    <span class="c1">###################################################################</span>
    <span class="c1">#</span>
    <span class="c1"># Private methods</span>
    <span class="c1">#</span>
    <span class="c1">###################################################################</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a copy of the AffineTransform.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        affine_transform : AffineTransform</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import copy</span>
<span class="sd">        &gt;&gt;&gt; cm = AffineTransform(CoordinateSystem(&#39;ijk&#39;), CoordinateSystem(&#39;xyz&#39;), np.eye(4))</span>
<span class="sd">        &gt;&gt;&gt; cm_copy = copy.copy(cm)</span>
<span class="sd">        &gt;&gt;&gt; cm is cm_copy</span>
<span class="sd">        False</span>

<span class="sd">        Note that the matrix (affine) is not a pointer to the</span>
<span class="sd">        same data, it&#39;s a full independent copy</span>

<span class="sd">        &gt;&gt;&gt; cm.affine[0,0] = 2.0</span>
<span class="sd">        &gt;&gt;&gt; cm_copy.affine[0,0]</span>
<span class="sd">        1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;AffineTransform(</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;   function_domain=</span><span class="si">%s</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;   function_range=</span><span class="si">%s</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;   affine=</span><span class="si">%s</span><span class="se">\n</span><span class="s2">)&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="p">,</span>
                 <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">          &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))))</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Must be subclasses</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="ow">or</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">affine</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">affine</span><span class="p">):</span> <span class="c1"># for objects</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">affine</span><span class="p">):</span> <span class="c1"># for numerical</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">function_domain</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_range</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">function_range</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="AffineTransform.similar_to"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.AffineTransform.similar_to">[docs]</a>    <span class="k">def</span> <span class="nf">similar_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Does `other` have similar coordinate systems and same mappings?</span>

<span class="sd">        A &quot;similar&quot; coordinate system is one with the same coordinate names and</span>
<span class="sd">        data dtype, but ignoring the coordinate system name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">similar_to</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">function_domain</span><span class="p">))</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">similar_to</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">function_range</span><span class="p">))</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">affine</span><span class="p">))</span></div></div>

<span class="c1">####################################################################################</span>
<span class="c1">#</span>
<span class="c1"># Module level functions</span>
<span class="c1">#</span>
<span class="c1">####################################################################################</span>

<div class="viewcode-block" id="product"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.product">[docs]</a><span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="o">*</span><span class="n">cmaps</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; &quot;topological&quot; product of two or more mappings</span>

<span class="sd">    The mappings can be either AffineTransforms or CoordinateMaps.</span>

<span class="sd">    If they are all AffineTransforms, the result is an AffineTransform,</span>
<span class="sd">    else it is a CoordinateMap.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cmaps : sequence of CoordinateMaps or AffineTransforms</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cmap : ``CoordinateMap``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; inc1 = AffineTransform.from_params(&#39;i&#39;, &#39;x&#39;, np.diag([2,1]))</span>
<span class="sd">    &gt;&gt;&gt; inc2 = AffineTransform.from_params(&#39;j&#39;, &#39;y&#39;, np.diag([3,1]))</span>
<span class="sd">    &gt;&gt;&gt; inc3 = AffineTransform.from_params(&#39;k&#39;, &#39;z&#39;, np.diag([4,1]))</span>

<span class="sd">    &gt;&gt;&gt; cmap = product(inc1, inc3, inc2)</span>
<span class="sd">    &gt;&gt;&gt; cmap.function_domain.coord_names</span>
<span class="sd">    (&#39;i&#39;, &#39;k&#39;, &#39;j&#39;)</span>
<span class="sd">    &gt;&gt;&gt; cmap.function_range.coord_names</span>
<span class="sd">    (&#39;x&#39;, &#39;z&#39;, &#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; cmap.affine</span>
<span class="sd">    array([[ 2.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  4.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  3.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  1.]])</span>

<span class="sd">    &gt;&gt;&gt; A1 = AffineTransform.from_params(&#39;ij&#39;, &#39;xyz&#39;, np.array([[2,3,1,0],[3,4,5,0],[7,9,3,1]]).T)</span>
<span class="sd">    &gt;&gt;&gt; A2 = AffineTransform.from_params(&#39;xyz&#39;, &#39;de&#39;, np.array([[8,6,7,4],[1,-1,13,3],[0,0,0,1]]))</span>

<span class="sd">    &gt;&gt;&gt; A1.affine</span>
<span class="sd">    array([[ 2.,  3.,  7.],</span>
<span class="sd">           [ 3.,  4.,  9.],</span>
<span class="sd">           [ 1.,  5.,  3.],</span>
<span class="sd">           [ 0.,  0.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; A2.affine</span>
<span class="sd">    array([[  8.,   6.,   7.,   4.],</span>
<span class="sd">           [  1.,  -1.,  13.,   3.],</span>
<span class="sd">           [  0.,   0.,   0.,   1.]])</span>

<span class="sd">    &gt;&gt;&gt; p=product(A1, A2)</span>
<span class="sd">    &gt;&gt;&gt; p.affine</span>
<span class="sd">    array([[  2.,   3.,   0.,   0.,   0.,   7.],</span>
<span class="sd">           [  3.,   4.,   0.,   0.,   0.,   9.],</span>
<span class="sd">           [  1.,   5.,   0.,   0.,   0.,   3.],</span>
<span class="sd">           [  0.,   0.,   8.,   6.,   7.,   4.],</span>
<span class="sd">           [  0.,   0.,   1.,  -1.,  13.,   3.],</span>
<span class="sd">           [  0.,   0.,   0.,   0.,   0.,   1.]])</span>

<span class="sd">    &gt;&gt;&gt; np.allclose(p.affine[:3,:2], A1.affine[:3,:2])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(p.affine[:3,-1], A1.affine[:3,-1])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(p.affine[3:5,2:5], A2.affine[:2,:3])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(p.affine[3:5,-1], A2.affine[:2,-1])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt;</span>

<span class="sd">    &gt;&gt;&gt; A1([3,4])</span>
<span class="sd">    array([ 25.,  34.,  26.])</span>
<span class="sd">    &gt;&gt;&gt; A2([5,6,7])</span>
<span class="sd">    array([ 129.,   93.])</span>
<span class="sd">    &gt;&gt;&gt; p([3,4,5,6,7])</span>
<span class="sd">    array([  25.,   34.,   26.,  129.,   93.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First, check if they&#39;re all Affine</span>
    <span class="n">allaffine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">AffineTransform</span><span class="p">)</span> <span class="k">for</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="n">cmaps</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">allaffine</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_product_affines</span><span class="p">(</span><span class="o">*</span><span class="n">cmaps</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;product of non-affine CoordinateMaps is less robust than&quot;</span><span class="o">+</span>
                      <span class="s2">&quot;the AffineTransform&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_product_cmaps</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_as_coordinate_map</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span> <span class="k">for</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="n">cmaps</span><span class="p">],</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="compose"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.compose">[docs]</a><span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="o">*</span><span class="n">cmaps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return the composition of two or more CoordinateMaps.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cmaps : sequence of CoordinateMaps</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cmap : ``CoordinateMap``</span>
<span class="sd">       The resulting CoordinateMap has function_domain ==</span>
<span class="sd">       cmaps[-1].function_domain and function_range ==</span>
<span class="sd">       cmaps[0].function_range</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; cmap = AffineTransform.from_params(&#39;i&#39;, &#39;x&#39;, np.diag([2.,1.]))</span>
<span class="sd">    &gt;&gt;&gt; cmapi = cmap.inverse()</span>
<span class="sd">    &gt;&gt;&gt; id1 = compose(cmap,cmapi)</span>
<span class="sd">    &gt;&gt;&gt; id1.affine</span>
<span class="sd">    array([[ 1.,  0.],</span>
<span class="sd">           [ 0.,  1.]])</span>

<span class="sd">    &gt;&gt;&gt; id2 = compose(cmapi,cmap)</span>
<span class="sd">    &gt;&gt;&gt; id1.function_domain.coord_names</span>
<span class="sd">    (&#39;x&#39;,)</span>
<span class="sd">    &gt;&gt;&gt; id2.function_domain.coord_names</span>
<span class="sd">    (&#39;i&#39;,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First check if they&#39;re all affine</span>
    <span class="n">allaffine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">AffineTransform</span><span class="p">)</span> <span class="k">for</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="n">cmaps</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">allaffine</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_compose_affines</span><span class="p">(</span><span class="o">*</span><span class="n">cmaps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;composition of non-affine CoordinateMaps is &quot;</span>
                      <span class="s2">&quot;less robust than the AffineTransform&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_compose_cmaps</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_as_coordinate_map</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span> <span class="k">for</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="n">cmaps</span><span class="p">])</span></div>


<div class="viewcode-block" id="reordered_domain"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.reordered_domain">[docs]</a><span class="k">def</span> <span class="nf">reordered_domain</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; New coordmap with the coordinates of function_domain reordered</span>

<span class="sd">    Default behaviour is to reverse the order of the coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    order: sequence</span>
<span class="sd">       Order to use, defaults to reverse. The elements can be integers,</span>
<span class="sd">       strings or 2-tuples of strings.  If they are strings, they should</span>
<span class="sd">       be in mapping.function_domain.coord_names.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    newmapping : CoordinateMap or AffineTransform</span>
<span class="sd">       A new CoordinateMap with the coordinates of function_domain</span>
<span class="sd">       reordered.  If isinstance(mapping, AffineTransform), newmapping</span>
<span class="sd">       is also an AffineTransform. Otherwise, it is a CoordinateMap.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; input_cs = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">    &gt;&gt;&gt; output_cs = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; cm = AffineTransform(input_cs, output_cs, np.identity(4))</span>
<span class="sd">    &gt;&gt;&gt; cm.reordered_domain(&#39;ikj&#39;).function_domain</span>
<span class="sd">    CoordinateSystem(coord_names=(&#39;i&#39;, &#39;k&#39;, &#39;j&#39;), name=&#39;&#39;, coord_dtype=float64)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If no reordering is to be performed, it returns a copy of mapping.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">ndims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]</span>

    <span class="n">newaxes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]</span>
    <span class="n">newincoords</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">newaxes</span><span class="p">,</span>
                                   <span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                   <span class="n">coord_dtype</span><span class="o">=</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_dtype</span><span class="p">)</span>
    <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndim</span><span class="o">+</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">perm</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
        <span class="n">perm</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="c1"># If there is no reordering, return mapping</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">perm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>

    <span class="n">perm</span> <span class="o">=</span> <span class="n">perm</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_dtype</span><span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="n">newincoords</span><span class="p">,</span> <span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">AffineTransform</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_compose_affines</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_compose_cmaps</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">_as_coordinate_map</span><span class="p">(</span><span class="n">A</span><span class="p">))</span></div>


<div class="viewcode-block" id="shifted_domain_origin"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.shifted_domain_origin">[docs]</a><span class="k">def</span> <span class="nf">shifted_domain_origin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">difference_vector</span><span class="p">,</span> <span class="n">new_origin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Shift the origin of the domain</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    difference_vector : array</span>
<span class="sd">       Representing the difference shifted_origin-current_origin in the</span>
<span class="sd">       domain&#39;s basis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; A = np.random.standard_normal((5,6))</span>
<span class="sd">    &gt;&gt;&gt; A[-1] = [0,0,0,0,0,1]</span>
<span class="sd">    &gt;&gt;&gt; affine_transform = AffineTransform(CS(&#39;ijklm&#39;, &#39;oldorigin&#39;), CS(&#39;xyzt&#39;), A)</span>
<span class="sd">    &gt;&gt;&gt; affine_transform.function_domain</span>
<span class="sd">    CoordinateSystem(coord_names=(&#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;), name=&#39;oldorigin&#39;, coord_dtype=float64)</span>

<span class="sd">    A random change of origin</span>

<span class="sd">    &gt;&gt;&gt; difference = np.random.standard_normal(5)</span>

<span class="sd">    The same affine transforation with a different origin for its domain</span>

<span class="sd">    &gt;&gt;&gt; shifted_affine_transform = shifted_domain_origin(affine_transform, difference, &#39;neworigin&#39;)</span>
<span class="sd">    &gt;&gt;&gt; shifted_affine_transform.function_domain</span>
<span class="sd">    CoordinateSystem(coord_names=(&#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;), name=&#39;neworigin&#39;, coord_dtype=float64)</span>

<span class="sd">    Let&#39;s check that things work</span>

<span class="sd">    &gt;&gt;&gt; point_in_old_basis = np.random.standard_normal(5)</span>

<span class="sd">    This is the relation ship between coordinates in old and new origins</span>

<span class="sd">    &gt;&gt;&gt; np.allclose(shifted_affine_transform(point_in_old_basis), affine_transform(point_in_old_basis+difference))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(shifted_affine_transform(point_in_old_basis-difference), affine_transform(point_in_old_basis))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_function_domain</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_names</span><span class="p">,</span>
                                           <span class="n">new_origin</span><span class="p">,</span>
                                           <span class="n">coord_dtype</span><span class="o">=</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_dtype</span><span class="p">)</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">new_function_domain</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">shift_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">ndim</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                               <span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_dtype</span><span class="p">)</span>
    <span class="n">shift_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">difference_vector</span><span class="p">)</span>
    <span class="n">shift_map</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="n">new_function_domain</span><span class="p">,</span>
                                <span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span>
                                <span class="n">shift_matrix</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">AffineTransform</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_compose_affines</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">shift_map</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_compose_cmaps</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">_as_coordinate_map</span><span class="p">(</span><span class="n">shift_map</span><span class="p">))</span></div>


<div class="viewcode-block" id="shifted_range_origin"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.shifted_range_origin">[docs]</a><span class="k">def</span> <span class="nf">shifted_range_origin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">difference_vector</span><span class="p">,</span> <span class="n">new_origin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Shift the origin of the range.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    difference_vector : array</span>
<span class="sd">       Representing the difference shifted_origin-current_origin in the</span>
<span class="sd">       range&#39;s basis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; A = np.random.standard_normal((5,6))</span>
<span class="sd">    &gt;&gt;&gt; A[-1] = [0,0,0,0,0,1]</span>
<span class="sd">    &gt;&gt;&gt; affine_transform = AffineTransform(CS(&#39;ijklm&#39;), CS(&#39;xyzt&#39;, &#39;oldorigin&#39;), A)</span>
<span class="sd">    &gt;&gt;&gt; affine_transform.function_range</span>
<span class="sd">    CoordinateSystem(coord_names=(&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;t&#39;), name=&#39;oldorigin&#39;, coord_dtype=float64)</span>

<span class="sd">    Make a random shift of the origin in the range</span>

<span class="sd">    &gt;&gt;&gt; difference = np.random.standard_normal(4)</span>
<span class="sd">    &gt;&gt;&gt; shifted_affine_transform = shifted_range_origin(affine_transform, difference, &#39;neworigin&#39;)</span>
<span class="sd">    &gt;&gt;&gt; shifted_affine_transform.function_range</span>
<span class="sd">    CoordinateSystem(coord_names=(&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;t&#39;), name=&#39;neworigin&#39;, coord_dtype=float64)</span>
<span class="sd">    &gt;&gt;&gt;</span>

<span class="sd">    Evaluate the transform and verify it does as expected</span>

<span class="sd">    &gt;&gt;&gt; point_in_domain = np.random.standard_normal(5)</span>

<span class="sd">    Check that things work</span>

<span class="sd">    &gt;&gt;&gt; np.allclose(shifted_affine_transform(point_in_domain), affine_transform(point_in_domain) - difference)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(shifted_affine_transform(point_in_domain) + difference, affine_transform(point_in_domain))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_function_range</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_names</span><span class="p">,</span>
                                          <span class="n">new_origin</span><span class="p">,</span>
                                          <span class="n">coord_dtype</span><span class="o">=</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_dtype</span><span class="p">)</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">new_function_range</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">shift_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">ndim</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                               <span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_dtype</span><span class="p">)</span>
    <span class="n">shift_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">difference_vector</span><span class="p">)</span>
    <span class="n">shift_map</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="p">,</span>
                                <span class="n">new_function_range</span><span class="p">,</span>
                                <span class="n">shift_matrix</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">AffineTransform</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_compose_affines</span><span class="p">(</span><span class="n">shift_map</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_compose_cmaps</span><span class="p">(</span><span class="n">_as_coordinate_map</span><span class="p">(</span><span class="n">shift_map</span><span class="p">),</span> <span class="n">mapping</span><span class="p">)</span></div>


<div class="viewcode-block" id="renamed_domain"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.renamed_domain">[docs]</a><span class="k">def</span> <span class="nf">renamed_domain</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">newnames</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; New coordmap with the coordinates of function_domain renamed</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    newnames: dict</span>
<span class="sd">       A dictionary whose keys are integers or are in</span>
<span class="sd">       mapping.function_range.coord_names and whose values are the new</span>
<span class="sd">       names.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    newmapping : CoordinateMap or AffineTransform</span>
<span class="sd">       A new mapping with renamed function_domain. If</span>
<span class="sd">       isinstance(mapping, AffineTransform), newmapping is also an</span>
<span class="sd">       AffineTransform. Otherwise, it is a CoordinateMap.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; affine_domain = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">    &gt;&gt;&gt; affine_range = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; affine_matrix = np.identity(4)</span>
<span class="sd">    &gt;&gt;&gt; affine_mapping = AffineTransform(affine_domain, affine_range, affine_matrix)</span>

<span class="sd">    &gt;&gt;&gt; new_affine_mapping = affine_mapping.renamed_domain({&#39;i&#39;:&#39;phase&#39;,&#39;k&#39;:&#39;freq&#39;,&#39;j&#39;:&#39;slice&#39;})</span>
<span class="sd">    &gt;&gt;&gt; new_affine_mapping.function_domain</span>
<span class="sd">    CoordinateSystem(coord_names=(&#39;phase&#39;, &#39;slice&#39;, &#39;freq&#39;), name=&#39;&#39;, coord_dtype=float64)</span>

<span class="sd">    &gt;&gt;&gt; new_affine_mapping = affine_mapping.renamed_domain({&#39;i&#39;:&#39;phase&#39;,&#39;k&#39;:&#39;freq&#39;,&#39;l&#39;:&#39;slice&#39;})</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">       ...</span>
<span class="sd">    ValueError: no domain coordinate named l</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">newnames</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">newnames</span><span class="p">[</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_names</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> \
                <span class="n">newnames</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">del</span><span class="p">(</span><span class="n">newnames</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">newnames</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no domain coordinate named </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="n">new_coord_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">newnames</span><span class="p">:</span>
            <span class="n">new_coord_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newnames</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_coord_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="n">new_function_domain</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">new_coord_names</span><span class="p">,</span>
                                           <span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                           <span class="n">coord_dtype</span><span class="o">=</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_dtype</span><span class="p">)</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">ndims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ident_map</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="n">new_function_domain</span><span class="p">,</span>
                                <span class="n">mapping</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">ndim</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">AffineTransform</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_compose_affines</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">ident_map</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_compose_cmaps</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">_as_coordinate_map</span><span class="p">(</span><span class="n">ident_map</span><span class="p">))</span></div>


<div class="viewcode-block" id="renamed_range"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.renamed_range">[docs]</a><span class="k">def</span> <span class="nf">renamed_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">newnames</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; New coordmap with the coordinates of function_range renamed</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    newnames : dict</span>
<span class="sd">       A dictionary whose keys are integers or in</span>
<span class="sd">       mapping.function_range.coord_names and whose values are the new</span>
<span class="sd">       names.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    newmapping : CoordinateMap or AffineTransform</span>
<span class="sd">       A new CoordinateMap with the coordinates of function_range</span>
<span class="sd">       renamed.  If isinstance(mapping, AffineTransform), newmapping is</span>
<span class="sd">       also an AffineTransform. Otherwise, it is a CoordinateMap.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; affine_domain = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">    &gt;&gt;&gt; affine_range = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; affine_matrix = np.identity(4)</span>
<span class="sd">    &gt;&gt;&gt; affine_mapping = AffineTransform(affine_domain, affine_range, affine_matrix)</span>
<span class="sd">    &gt;&gt;&gt; new_affine_mapping = affine_mapping.renamed_range({&#39;x&#39;:&#39;u&#39;})</span>
<span class="sd">    &gt;&gt;&gt; new_affine_mapping.function_range</span>
<span class="sd">    CoordinateSystem(coord_names=(&#39;u&#39;, &#39;y&#39;, &#39;z&#39;), name=&#39;&#39;, coord_dtype=float64)</span>

<span class="sd">    &gt;&gt;&gt; new_affine_mapping = affine_mapping.renamed_range({&#39;w&#39;:&#39;u&#39;})</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">       ...</span>
<span class="sd">    ValueError: no range coordinate named w</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">newnames</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">newnames</span><span class="p">[</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_names</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> \
                <span class="n">newnames</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">del</span><span class="p">(</span><span class="n">newnames</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">newnames</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no range coordinate named </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="n">new_coord_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">newnames</span><span class="p">:</span>
            <span class="n">new_coord_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newnames</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_coord_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="n">new_function_range</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">new_coord_names</span><span class="p">,</span>
                                          <span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                          <span class="n">coord_dtype</span><span class="o">=</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_dtype</span><span class="p">)</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">ndims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ident_map</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="p">,</span>
                                <span class="n">new_function_range</span><span class="p">,</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">ndim</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">AffineTransform</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_compose_affines</span><span class="p">(</span><span class="n">ident_map</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_compose_cmaps</span><span class="p">(</span><span class="n">_as_coordinate_map</span><span class="p">(</span><span class="n">ident_map</span><span class="p">),</span> <span class="n">mapping</span><span class="p">)</span></div>


<div class="viewcode-block" id="reordered_range"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.reordered_range">[docs]</a><span class="k">def</span> <span class="nf">reordered_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; New coordmap with the coordinates of function_range reordered</span>

<span class="sd">    Defaults to reversing the coordinates of function_range.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    order: sequence</span>
<span class="sd">       Order to use, defaults to reverse. The elements can be integers,</span>
<span class="sd">       strings or 2-tuples of strings.  If they are strings, they should</span>
<span class="sd">       be in mapping.function_range.coord_names.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    newmapping : CoordinateMap or AffineTransform</span>
<span class="sd">       A new CoordinateMap with the coordinates of function_range</span>
<span class="sd">       reordered.  If isinstance(mapping, AffineTransform), newmapping</span>
<span class="sd">       is also an AffineTransform. Otherwise, it is a CoordinateMap.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; input_cs = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">    &gt;&gt;&gt; output_cs = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; cm = AffineTransform(input_cs, output_cs, np.identity(4))</span>
<span class="sd">    &gt;&gt;&gt; cm.reordered_range(&#39;xzy&#39;).function_range</span>
<span class="sd">    CoordinateSystem(coord_names=(&#39;x&#39;, &#39;z&#39;, &#39;y&#39;), name=&#39;&#39;, coord_dtype=float64)</span>
<span class="sd">    &gt;&gt;&gt; cm.reordered_range([0,2,1]).function_range.coord_names</span>
<span class="sd">    (&#39;x&#39;, &#39;z&#39;, &#39;y&#39;)</span>

<span class="sd">    &gt;&gt;&gt; newcm = cm.reordered_range(&#39;yzx&#39;)</span>
<span class="sd">    &gt;&gt;&gt; newcm.function_range.coord_names</span>
<span class="sd">    (&#39;y&#39;, &#39;z&#39;, &#39;x&#39;)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If no reordering is to be performed, it returns a copy of mapping.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">ndims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]</span>

    <span class="n">newaxes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]</span>
    <span class="n">newoutcoords</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">newaxes</span><span class="p">,</span> <span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                    <span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_dtype</span><span class="p">)</span>

    <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndim</span><span class="o">+</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">perm</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
        <span class="n">perm</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">perm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>

    <span class="n">perm</span> <span class="o">=</span> <span class="n">perm</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_dtype</span><span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">function_range</span><span class="p">,</span> <span class="n">newoutcoords</span><span class="p">,</span> <span class="n">perm</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">AffineTransform</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_compose_affines</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_compose_cmaps</span><span class="p">(</span><span class="n">_as_coordinate_map</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">mapping</span><span class="p">)</span></div>


<div class="viewcode-block" id="equivalent"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.equivalent">[docs]</a><span class="k">def</span> <span class="nf">equivalent</span><span class="p">(</span><span class="n">mapping1</span><span class="p">,</span> <span class="n">mapping2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A test to see if mapping1 is equal</span>
<span class="sd">    to mapping2 after possibly reordering the</span>
<span class="sd">    domain and range of mapping.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mapping1 : CoordinateMap or AffineTransform</span>
<span class="sd">    mapping2 : CoordinateMap or AffineTransform</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    are_they_equal : bool</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ijk = CoordinateSystem(&#39;ijk&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xyz = CoordinateSystem(&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; T = np.random.standard_normal((4,4))</span>
<span class="sd">    &gt;&gt;&gt; T[-1] = [0,0,0,1] # otherwise AffineTransform raises</span>
<span class="sd">    ...                   # an exception because</span>
<span class="sd">    ...                   # it&#39;s supposed to represent an</span>
<span class="sd">    ...                   # affine transform in homogeneous</span>
<span class="sd">    ...                   # coordinates</span>
<span class="sd">    &gt;&gt;&gt; A = AffineTransform(ijk, xyz, T)</span>
<span class="sd">    &gt;&gt;&gt; B = A.reordered_domain(&#39;ikj&#39;).reordered_range(&#39;xzy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; C = B.renamed_domain({&#39;i&#39;:&#39;slice&#39;})</span>
<span class="sd">    &gt;&gt;&gt; equivalent(A, B)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; equivalent(A, C)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; equivalent(B, C)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; D = CoordinateMap(ijk, xyz, np.exp)</span>
<span class="sd">    &gt;&gt;&gt; equivalent(D, D)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; E = D.reordered_domain(&#39;kij&#39;).reordered_range(&#39;xzy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; # no non-AffineTransform will ever be</span>
<span class="sd">    &gt;&gt;&gt; # equivalent to a reordered version of itself,</span>
<span class="sd">    &gt;&gt;&gt; # because their functions don&#39;t evaluate as equal</span>
<span class="sd">    &gt;&gt;&gt; equivalent(D, E)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; equivalent(E, E)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # This has not changed the order</span>
<span class="sd">    &gt;&gt;&gt; # of the axes, so the function is still the same</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; F = D.reordered_range(&#39;xyz&#39;).reordered_domain(&#39;ijk&#39;)</span>
<span class="sd">    &gt;&gt;&gt; equivalent(F, D)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; id(F) == id(D)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">target_dnames</span> <span class="o">=</span> <span class="n">mapping2</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_names</span>
    <span class="n">target_rnames</span> <span class="o">=</span> <span class="n">mapping2</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_names</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">mapping1</span> <span class="o">=</span> <span class="n">mapping1</span><span class="o">.</span><span class="n">reordered_domain</span><span class="p">(</span><span class="n">target_dnames</span><span class="p">)</span>\
            <span class="o">.</span><span class="n">reordered_range</span><span class="p">(</span><span class="n">target_rnames</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># impossible to rename the domain and ranges of mapping1 to match mapping2</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">mapping1</span> <span class="o">==</span> <span class="n">mapping2</span></div>

<span class="c1">###################################################################</span>
<span class="c1">#</span>
<span class="c1"># Private functions</span>
<span class="c1">#</span>
<span class="c1">###################################################################</span>

<span class="k">def</span> <span class="nf">_as_coordinate_map</span><span class="p">(</span><span class="n">cmap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return CoordinateMap from AffineTransform</span>

<span class="sd">    Take a mapping AffineTransform and return a</span>
<span class="sd">    CoordinateMap with the appropriate functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">CoordinateMap</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cmap</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">AffineTransform</span><span class="p">):</span>
        <span class="n">affine_transform</span> <span class="o">=</span> <span class="n">cmap</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">to_matvec</span><span class="p">(</span><span class="n">affine_transform</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="n">b</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="c1"># Preserve dtype check because the CoordinateMap expects to generate the</span>
        <span class="c1"># expected dtype and checks this on object creation</span>
        <span class="n">affine_transform_inv</span> <span class="o">=</span> <span class="n">affine_transform</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">preserve_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">affine_transform_inv</span><span class="p">:</span>
            <span class="n">Ainv</span><span class="p">,</span> <span class="n">binv</span> <span class="o">=</span> <span class="n">to_matvec</span><span class="p">(</span><span class="n">affine_transform_inv</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">_inverse_function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Ainv</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">binv</span>
                <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_inverse_function</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">CoordinateMap</span><span class="p">(</span><span class="n">affine_transform</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span>
                             <span class="n">affine_transform</span><span class="o">.</span><span class="n">function_range</span><span class="p">,</span>
                             <span class="n">_function</span><span class="p">,</span>
                             <span class="n">_inverse_function</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;all mappings should be instances of &#39;</span>
                         <span class="s1">&#39;either CoordinateMap or AffineTransform&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_compose_affines</span><span class="p">(</span><span class="o">*</span><span class="n">affines</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Composition of sequence of affines</span>

<span class="sd">    Compose hecking the domains and ranges.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="n">affines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span>
                          <span class="n">affines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">affines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ndims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                      <span class="n">dtype</span><span class="o">=</span><span class="n">affines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">affine</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="n">affines</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">cmap</span><span class="o">.</span><span class="n">function_domain</span> <span class="o">==</span> <span class="n">cur</span><span class="o">.</span><span class="n">function_range</span><span class="p">:</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span>
                                  <span class="n">cmap</span><span class="o">.</span><span class="n">function_range</span><span class="p">,</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cmap</span><span class="o">.</span><span class="n">affine</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">affine</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;domains and ranges don&#39;t match up correctly&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cur</span>


<span class="k">def</span> <span class="nf">_compose_cmaps</span><span class="p">(</span><span class="o">*</span><span class="n">cmaps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute the composition of a sequence of cmaps</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_compose2</span><span class="p">(</span><span class="n">cmap1</span><span class="p">,</span> <span class="n">cmap2</span><span class="p">):</span>
        <span class="n">forward</span> <span class="o">=</span> <span class="k">lambda</span> <span class="nb">input</span><span class="p">:</span> <span class="n">cmap1</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">cmap2</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="nb">input</span><span class="p">))</span>
        <span class="n">cmap1i</span> <span class="o">=</span> <span class="n">cmap1</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
        <span class="n">cmap2i</span> <span class="o">=</span> <span class="n">cmap2</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cmap1i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cmap2i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">backward</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">output</span><span class="p">:</span> <span class="n">cmap2i</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">cmap1i</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">backward</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">forward</span><span class="p">,</span> <span class="n">backward</span>

    <span class="c1"># the identity coordmap</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">CoordinateMap</span><span class="p">(</span><span class="n">cmaps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span>
                        <span class="n">cmaps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span>
                        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span>
                        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="n">cmaps</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">cmap</span><span class="o">.</span><span class="n">function_domain</span> <span class="o">==</span> <span class="n">cur</span><span class="o">.</span><span class="n">function_range</span><span class="p">:</span>
            <span class="n">forward</span><span class="p">,</span> <span class="n">backward</span> <span class="o">=</span> <span class="n">_compose2</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">cur</span><span class="p">)</span>
            <span class="n">cur</span> <span class="o">=</span>  <span class="n">CoordinateMap</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">function_domain</span><span class="p">,</span>
                                 <span class="n">cmap</span><span class="o">.</span><span class="n">function_range</span><span class="p">,</span>
                                 <span class="n">forward</span><span class="p">,</span>
                                 <span class="n">inverse_function</span><span class="o">=</span><span class="n">backward</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;domain and range coordinates do not match: &#39;</span>
                <span class="s1">&#39;domain=</span><span class="si">%s</span><span class="s1">, range=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">cmap</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">cur</span>


<span class="k">def</span> <span class="nf">_product_cmaps</span><span class="p">(</span><span class="o">*</span><span class="n">cmaps</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">input_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;input_name&#39;</span><span class="p">,</span> <span class="s1">&#39;product&#39;</span><span class="p">)</span>
    <span class="n">output_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;output_name&#39;</span><span class="p">,</span> <span class="s1">&#39;product&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unexpected kwargs </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ndimin</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmap</span><span class="o">.</span><span class="n">ndims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="n">cmaps</span><span class="p">]</span>
    <span class="n">ndimin</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ndimin</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ndimin</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ndimin</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">yy</span> <span class="o">=</span> <span class="n">cmaps</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">[:,</span><span class="n">ndimin</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">ndimin</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">yy</span><span class="p">)</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">yy</span>

    <span class="n">incoords</span> <span class="o">=</span> <span class="n">coordsys_product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">cmap</span><span class="o">.</span><span class="n">function_domain</span> <span class="k">for</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="n">cmaps</span><span class="p">],</span>
                                <span class="o">**</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">input_name</span><span class="p">})</span>
    <span class="n">outcoords</span> <span class="o">=</span> <span class="n">coordsys_product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">cmap</span><span class="o">.</span><span class="n">function_range</span> <span class="k">for</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="n">cmaps</span><span class="p">],</span>
                                <span class="o">**</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">output_name</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">CoordinateMap</span><span class="p">(</span><span class="n">incoords</span><span class="p">,</span> <span class="n">outcoords</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_product_affines</span><span class="p">(</span><span class="o">*</span><span class="n">affine_mappings</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Product of affine_mappings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">input_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;input_name&#39;</span><span class="p">,</span> <span class="s1">&#39;product&#39;</span><span class="p">)</span>
    <span class="n">output_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;output_name&#39;</span><span class="p">,</span> <span class="s1">&#39;product&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unexpected kwargs </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">input_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">input_name</span> <span class="o">=</span> <span class="s1">&#39;product&#39;</span>
    <span class="k">if</span> <span class="n">output_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_name</span> <span class="o">=</span> <span class="s1">&#39;product&#39;</span>
    <span class="n">ndimin</span> <span class="o">=</span> <span class="p">[</span><span class="n">affine</span><span class="o">.</span><span class="n">ndims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">affine</span> <span class="ow">in</span> <span class="n">affine_mappings</span><span class="p">]</span>
    <span class="n">ndimout</span> <span class="o">=</span> <span class="p">[</span><span class="n">affine</span><span class="o">.</span><span class="n">ndims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">affine</span> <span class="ow">in</span> <span class="n">affine_mappings</span><span class="p">]</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ndimout</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ndimin</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                 <span class="n">dtype</span><span class="o">=</span><span class="n">safe_dtype</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">affine</span><span class="o">.</span><span class="n">affine</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">affine</span> <span class="ow">in</span> <span class="n">affine_mappings</span><span class="p">]))</span>
    <span class="n">M</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="c1"># Fill in the block matrix</span>
    <span class="n">product_domain</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">product_range</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">affine</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">affine_mappings</span><span class="p">):</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">to_matvec</span><span class="p">(</span><span class="n">affine</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="n">ndimout</span><span class="p">[</span><span class="n">l</span><span class="p">]),</span><span class="n">j</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="n">ndimin</span><span class="p">[</span><span class="n">l</span><span class="p">])]</span> <span class="o">=</span> <span class="n">A</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="n">ndimout</span><span class="p">[</span><span class="n">l</span><span class="p">]),</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">product_domain</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">affine</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_names</span><span class="p">)</span>
        <span class="n">product_range</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">affine</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_names</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="n">ndimout</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="n">ndimin</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">AffineTransform</span><span class="p">(</span>
        <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">product_domain</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">input_name</span><span class="p">,</span> <span class="n">coord_dtype</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
        <span class="n">CoordinateSystem</span><span class="p">(</span><span class="n">product_range</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">output_name</span><span class="p">,</span> <span class="n">coord_dtype</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
        <span class="n">M</span><span class="p">)</span>


<div class="viewcode-block" id="AxisError"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.AxisError">[docs]</a><span class="k">class</span> <span class="nc">AxisError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Error for incorrect axis selection &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="drop_io_dim"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.drop_io_dim">[docs]</a><span class="k">def</span> <span class="nf">drop_io_dim</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">axis_id</span><span class="p">,</span> <span class="n">fix0</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Drop dimensions `axis_id` from coordinate map, if orthogonal to others</span>

<span class="sd">    If you specify an input dimension, drop that dimension and any corresponding</span>
<span class="sd">    output dimension, as long as all other outputs are orthogonal to dropped</span>
<span class="sd">    input.  If you specify an output dimension, drop that dimension and any</span>
<span class="sd">    corresponding input dimension, as long as all other inputs are orthogonal</span>
<span class="sd">    to dropped output.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cm : class:`AffineTransform`</span>
<span class="sd">        Affine coordinate map instance</span>
<span class="sd">    axis_id : int or str</span>
<span class="sd">        If int, gives index of *input* axis to drop.  If str, gives name of</span>
<span class="sd">        input *or* output axis to drop. When specifying an input axis: if given</span>
<span class="sd">        input axis does not affect any output axes, just drop input axis.  If</span>
<span class="sd">        input axis affects only one output axis, drop both input and</span>
<span class="sd">        corresponding output.  Similarly when specifying an output axis.  If</span>
<span class="sd">        `axis_id` is a str, it must be unambiguous - if the named axis exists in</span>
<span class="sd">        both input and output, and they do not correspond, raises a AxisError.</span>
<span class="sd">        See Raises section for checks</span>
<span class="sd">    fix0: bool, optional</span>
<span class="sd">        Whether to fix potential 0 TR in affine</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cm_redux : Affine</span>
<span class="sd">        Affine coordinate map with orthogonal input + output dimension dropped</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AxisError: if `axis_id` is a str and does not match any no input or output</span>
<span class="sd">        coordinate names.</span>
<span class="sd">    AxisError: if specified `axis_id` affects more than a single input / output</span>
<span class="sd">        axis.</span>
<span class="sd">    AxisError: if the named `axis_id` exists in both input and output, and they</span>
<span class="sd">        do not correspond.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Typical use is in getting a 3D coordinate map from 4D</span>

<span class="sd">    &gt;&gt;&gt; cm4d = AffineTransform.from_params(&#39;ijkl&#39;, &#39;xyzt&#39;, np.diag([1,2,3,4,1]))</span>
<span class="sd">    &gt;&gt;&gt; cm3d = drop_io_dim(cm4d, &#39;t&#39;)</span>
<span class="sd">    &gt;&gt;&gt; cm3d.affine</span>
<span class="sd">    array([[ 1.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  2.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  3.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  1.]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Implicit check for affine-type coordinate map</span>
    <span class="n">aff</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">affine</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># What dimensions did you ask for?</span>
    <span class="n">in_dim</span><span class="p">,</span> <span class="n">out_dim</span> <span class="o">=</span> <span class="n">io_axis_indices</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">axis_id</span><span class="p">,</span> <span class="n">fix0</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">(</span><span class="n">in_dim</span><span class="p">,</span> <span class="n">out_dim</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">orth_axes</span><span class="p">(</span><span class="n">in_dim</span><span class="p">,</span> <span class="n">out_dim</span><span class="p">,</span> <span class="n">aff</span><span class="p">,</span> <span class="n">allow_zero</span><span class="o">=</span><span class="n">fix0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">AxisError</span><span class="p">(</span><span class="s1">&#39;Input and output dimensions not orthogonal to &#39;</span>
                            <span class="s1">&#39;rest of affine&#39;</span><span class="p">)</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">aff</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">))</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
    <span class="n">in_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_names</span><span class="p">)</span>
    <span class="n">out_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_names</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">in_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">in_dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">in_dim</span><span class="p">)</span>
        <span class="n">cols</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">in_dim</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">out_dim</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">out_dim</span><span class="p">)</span>
    <span class="n">aff</span> <span class="o">=</span> <span class="n">aff</span><span class="p">[</span><span class="n">rows</span><span class="p">]</span>
    <span class="n">aff</span> <span class="o">=</span> <span class="n">aff</span><span class="p">[:,</span><span class="n">cols</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">AffineTransform</span><span class="o">.</span><span class="n">from_params</span><span class="p">(</span><span class="n">in_dims</span><span class="p">,</span> <span class="n">out_dims</span><span class="p">,</span> <span class="n">aff</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_fix0</span><span class="p">(</span><span class="n">aff</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Fix possible 0 time scaling from 0 TR</span>

<span class="sd">    Look in matrix part of affine (3, 3) in a (4, 4) affine).  If there is</span>
<span class="sd">    exactly one row and exactly one column in this part of the affine that are</span>
<span class="sd">    all exactly zero, assume this is a 0 scaling from a 0 TR in the header, and</span>
<span class="sd">    fix corresponding row, column index to 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    aff : (M, N) array-like</span>
<span class="sd">        affine</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fixed_aff : (M, N) affine</span>
<span class="sd">        which will be `aff` if no fix, and a new affine if fixed, with a 1</span>
<span class="sd">        instead of the zero in the offending row and column</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; _fix0(np.diag([1, 2, 3, 0]))</span>
<span class="sd">    array([[1, 0, 0, 0],</span>
<span class="sd">           [0, 2, 0, 0],</span>
<span class="sd">           [0, 0, 3, 0],</span>
<span class="sd">           [0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; _fix0(np.diag([1, 0, 3, 0]))</span>
<span class="sd">    array([[1, 0, 0, 0],</span>
<span class="sd">           [0, 1, 0, 0],</span>
<span class="sd">           [0, 0, 3, 0],</span>
<span class="sd">           [0, 0, 0, 0]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">aff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">aff</span><span class="p">)</span>
    <span class="n">zeros</span> <span class="o">=</span> <span class="n">aff</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">zrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">zcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zrs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">zcs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">aff</span>
    <span class="n">fixed_aff</span> <span class="o">=</span> <span class="n">aff</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">fixed_aff</span><span class="p">[</span><span class="n">zrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">fixed_aff</span>


<div class="viewcode-block" id="append_io_dim"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.append_io_dim">[docs]</a><span class="k">def</span> <span class="nf">append_io_dim</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">in_name</span><span class="p">,</span> <span class="n">out_name</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Append input and output dimension to coordmap</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cm : Affine</span>
<span class="sd">       Affine coordinate map instance to which to append dimension</span>
<span class="sd">    in_name : str</span>
<span class="sd">       Name for new input dimension</span>
<span class="sd">    out_name : str</span>
<span class="sd">       Name for new output dimension</span>
<span class="sd">    start : float, optional</span>
<span class="sd">       Offset for transformed values in new dimension</span>
<span class="sd">    step : float, optional</span>
<span class="sd">       Step, or scale factor for transformed values in new dimension</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cm_plus : Affine</span>
<span class="sd">       New coordinate map with appended dimension</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Typical use is creating a 4D coordinate map from a 3D</span>

<span class="sd">    &gt;&gt;&gt; cm3d = AffineTransform.from_params(&#39;ijk&#39;, &#39;xyz&#39;, np.diag([1,2,3,1]))</span>
<span class="sd">    &gt;&gt;&gt; cm4d = append_io_dim(cm3d, &#39;l&#39;, &#39;t&#39;, 9, 5)</span>
<span class="sd">    &gt;&gt;&gt; cm4d.affine</span>
<span class="sd">    array([[ 1.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  2.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  3.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  5.,  9.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  1.]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">extra_aff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">step</span><span class="p">,</span> <span class="n">start</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="n">extra_cmap</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="o">.</span><span class="n">from_params</span><span class="p">([</span><span class="n">in_name</span><span class="p">],</span> <span class="p">[</span><span class="n">out_name</span><span class="p">],</span> <span class="n">extra_aff</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">product</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">extra_cmap</span><span class="p">)</span></div>


<div class="viewcode-block" id="axmap"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.axmap">[docs]</a><span class="k">def</span> <span class="nf">axmap</span><span class="p">(</span><span class="n">coordmap</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;in2out&#39;</span><span class="p">,</span> <span class="n">fix0</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return mapping between input and output axes</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coordmap : Affine</span>
<span class="sd">        Affine coordinate map instance for which to get axis mappings</span>
<span class="sd">    direction : {&#39;in2out&#39;, &#39;out2in&#39;, &#39;both&#39;}</span>
<span class="sd">        direction to find mapping.  If &#39;in2out&#39;, returned mapping will have keys</span>
<span class="sd">        from the input axis (names and indices) and values of corresponding</span>
<span class="sd">        output axes.  If &#39;out2in&#39; the keys will be output axis names, indices</span>
<span class="sd">        and the values will be input axis indices.  If both, return both</span>
<span class="sd">        mappings.</span>
<span class="sd">    fix0: bool, optional</span>
<span class="sd">        Whether to fix potential 0 TR in affine</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    map : dict or tuple</span>
<span class="sd">        * if `direction` == &#39;in2out&#39; - mapping with keys of input names and</span>
<span class="sd">          input indices, values of output indices. Mapping is to closest</span>
<span class="sd">          matching axis.  None means there appears to be no matching axis</span>
<span class="sd">        * if `direction` == &#39;out2in&#39; - mapping with keys of output names and</span>
<span class="sd">          input indices, values of input indices, as above.</span>
<span class="sd">        * if `direction` == &#39;both&#39; - tuple of (input to output mapping, output</span>
<span class="sd">          to input mapping)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">in2out</span> <span class="o">=</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;in2out&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">)</span>
    <span class="n">out2in</span> <span class="o">=</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;out2in&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="kc">True</span> <span class="ow">in</span> <span class="p">(</span><span class="n">in2out</span><span class="p">,</span> <span class="n">out2in</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Direction must be one of &quot;in2out&quot;, &quot;out2in&quot;, &quot;both&quot;&#39;</span><span class="p">)</span>
    <span class="n">affine</span> <span class="o">=</span> <span class="n">coordmap</span><span class="o">.</span><span class="n">affine</span>
    <span class="n">affine</span> <span class="o">=</span> <span class="n">_fix0</span><span class="p">(</span><span class="n">affine</span><span class="p">)</span> <span class="k">if</span> <span class="n">fix0</span> <span class="k">else</span> <span class="n">affine</span>
    <span class="n">ornts</span> <span class="o">=</span> <span class="n">io_orientation</span><span class="p">(</span><span class="n">affine</span><span class="p">)</span>
    <span class="n">ornts</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">ornts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">in2out</span><span class="p">:</span>
        <span class="n">in2out_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coordmap</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_names</span><span class="p">):</span>
            <span class="n">in2out_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ornts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">in2out_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ornts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">out2in</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">in2out_map</span>
    <span class="k">if</span> <span class="n">out2in</span><span class="p">:</span>
        <span class="n">out2in_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coordmap</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_names</span><span class="p">):</span>
            <span class="n">in_i</span> <span class="o">=</span> <span class="n">ornts</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ornts</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">out2in_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_i</span>
            <span class="n">out2in_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_i</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in2out</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out2in_map</span>
    <span class="k">return</span> <span class="n">in2out_map</span><span class="p">,</span> <span class="n">out2in_map</span></div>


<div class="viewcode-block" id="input_axis_index"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.input_axis_index">[docs]</a><span class="k">def</span> <span class="nf">input_axis_index</span><span class="p">(</span><span class="n">coordmap</span><span class="p">,</span> <span class="n">axis_id</span><span class="p">,</span> <span class="n">fix0</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return input axis index for `axis_id`</span>

<span class="sd">    `axis_id` can be integer, or a name of an input axis, or it can be the name</span>
<span class="sd">    of an output axis which maps to an input axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coordmap : AffineTransform</span>
<span class="sd">    axis_id : int or str</span>
<span class="sd">        If int, then an index of an input axis.  Can be negative, so that -2</span>
<span class="sd">        refers to the second to last input axis.  If a str can be the name of an</span>
<span class="sd">        input axis, or the name of an output axis that should have a</span>
<span class="sd">        corresponding input axis (see Raises section).</span>
<span class="sd">    fix0: bool, optional</span>
<span class="sd">        Whether to fix potential single 0 on diagonal of affine.  This often</span>
<span class="sd">        happens when loading nifti images with TR set to 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    inax : int</span>
<span class="sd">        index of matching input axis. If `axis_id` is the name of an output</span>
<span class="sd">        axis, then `inax` will be the input axis that had a &#39;best&#39; match with</span>
<span class="sd">        this output axis.  The &#39;best&#39; match algorithm ensures that there can</span>
<span class="sd">        only be one input axis paired with one output axis.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AxisError: if no matching name found</span>
<span class="sd">    AxisError : if name exists in both input and output and they do not map to</span>
<span class="sd">        each other</span>
<span class="sd">    AxisError : if name present in output but no matching input</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Lists for .index in python &lt; 2.6</span>
    <span class="n">in_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coordmap</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_names</span><span class="p">)</span>
    <span class="n">out_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coordmap</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_names</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis_id</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">axis_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axis_id</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_names</span><span class="p">)</span> <span class="o">+</span> <span class="n">axis_id</span>
        <span class="k">return</span> <span class="n">axis_id</span>
    <span class="n">in_in</span> <span class="o">=</span> <span class="n">axis_id</span> <span class="ow">in</span> <span class="n">in_names</span>
    <span class="n">in_out</span> <span class="o">=</span> <span class="n">axis_id</span> <span class="ow">in</span> <span class="n">out_names</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_in</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">in_out</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">AxisError</span><span class="p">(</span><span class="s1">&#39;Name &quot;</span><span class="si">%s</span><span class="s1">&quot; not in input or output names&#39;</span> <span class="o">%</span> <span class="n">axis_id</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">in_in</span><span class="p">:</span>
        <span class="n">in_no</span> <span class="o">=</span> <span class="n">in_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_out</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">in_no</span>
        <span class="n">out2in</span> <span class="o">=</span> <span class="n">axmap</span><span class="p">(</span><span class="n">coordmap</span><span class="p">,</span> <span class="s1">&#39;out2in&#39;</span><span class="p">,</span> <span class="n">fix0</span><span class="o">=</span><span class="n">fix0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">out2in</span><span class="p">[</span><span class="n">axis_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">in_no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AxisError</span><span class="p">(</span><span class="s1">&#39;Name &quot;</span><span class="si">%s</span><span class="s1">&quot; present in input and output but &#39;</span>
                            <span class="s1">&#39;they do not appear to match&#39;</span> <span class="o">%</span> <span class="n">axis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">in_no</span>
    <span class="n">in_no</span> <span class="o">=</span> <span class="n">axmap</span><span class="p">(</span><span class="n">coordmap</span><span class="p">,</span> <span class="s1">&#39;out2in&#39;</span><span class="p">,</span> <span class="n">fix0</span><span class="o">=</span><span class="n">fix0</span><span class="p">)[</span><span class="n">axis_id</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">in_no</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">AxisError</span><span class="p">(</span><span class="s1">&#39;Name &quot;</span><span class="si">%s</span><span class="s1">&quot; present in output but this output axis &#39;</span>
                        <span class="s1">&#39;does not have the best match with any input axis&#39;</span>
                        <span class="o">%</span> <span class="n">axis_id</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">in_no</span></div>


<div class="viewcode-block" id="io_axis_indices"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.io_axis_indices">[docs]</a><span class="k">def</span> <span class="nf">io_axis_indices</span><span class="p">(</span><span class="n">coordmap</span><span class="p">,</span> <span class="n">axis_id</span><span class="p">,</span> <span class="n">fix0</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return input and output axis index for id `axis_id` in `coordmap`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cm : class:`AffineTransform`</span>
<span class="sd">        Affine coordinate map instance</span>
<span class="sd">    axis_id : int or str</span>
<span class="sd">        If int, gives index of *input* axis.  Can be negative, so that -2 refers</span>
<span class="sd">        to the second from last input axis. If str, gives name of input *or*</span>
<span class="sd">        output axis.   If `axis_id` is a str, it must be unambiguous - if the</span>
<span class="sd">        named axis exists in both input and output, and they do not correspond,</span>
<span class="sd">        raises a AxisError.  See Raises section for checks</span>
<span class="sd">    fix0: bool, optional</span>
<span class="sd">        Whether to fix potential 0 column / row in affine</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    in_index : None or int</span>
<span class="sd">        index of input axis that corresponds to `axis_id`</span>
<span class="sd">    out_index : None or int</span>
<span class="sd">        index of output axis that corresponds to `axis_id`</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AxisError: if `axis_id` is a str and does not match any input or output</span>
<span class="sd">        coordinate names.</span>
<span class="sd">    AxisError: if the named `axis_id` exists in both input and output, and they</span>
<span class="sd">        do not correspond.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aff = [[0, 1, 0, 10], [1, 0, 0, 11], [0, 0, 1, 12], [0, 0, 0, 1]]</span>
<span class="sd">    &gt;&gt;&gt; cmap = AffineTransform(&#39;ijk&#39;, &#39;xyz&#39;, aff)</span>
<span class="sd">    &gt;&gt;&gt; io_axis_indices(cmap, 0)</span>
<span class="sd">    (0, 1)</span>
<span class="sd">    &gt;&gt;&gt; io_axis_indices(cmap, 1)</span>
<span class="sd">    (1, 0)</span>
<span class="sd">    &gt;&gt;&gt; io_axis_indices(cmap, -1)</span>
<span class="sd">    (2, 2)</span>
<span class="sd">    &gt;&gt;&gt; io_axis_indices(cmap, &#39;j&#39;)</span>
<span class="sd">    (1, 0)</span>
<span class="sd">    &gt;&gt;&gt; io_axis_indices(cmap, &#39;y&#39;)</span>
<span class="sd">    (0, 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">in_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coordmap</span><span class="o">.</span><span class="n">function_domain</span><span class="o">.</span><span class="n">coord_names</span><span class="p">)</span>
    <span class="n">out_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coordmap</span><span class="o">.</span><span class="n">function_range</span><span class="o">.</span><span class="n">coord_names</span><span class="p">)</span>
    <span class="n">in_dim</span><span class="p">,</span> <span class="n">out_dim</span><span class="p">,</span> <span class="n">is_str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis_id</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span> <span class="c1"># Integer axis, always input axis</span>
        <span class="c1"># Integers are always input indices</span>
        <span class="n">in_dim</span> <span class="o">=</span> <span class="n">axis_id</span> <span class="k">if</span> <span class="n">axis_id</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_dims</span><span class="p">)</span> <span class="o">+</span> <span class="n">axis_id</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># Let&#39;s hope they are strings</span>
        <span class="k">if</span> <span class="n">axis_id</span> <span class="ow">in</span> <span class="n">in_dims</span><span class="p">:</span>
            <span class="n">in_dim</span> <span class="o">=</span> <span class="n">in_dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis_id</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis_id</span> <span class="ow">in</span> <span class="n">out_dims</span><span class="p">:</span>
            <span class="n">out_dim</span> <span class="o">=</span> <span class="n">out_dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis_id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AxisError</span><span class="p">(</span><span class="s1">&#39;No input or output dimension with name (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span>
                            <span class="n">axis_id</span><span class="p">)</span>
        <span class="n">is_str</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">out_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_dim</span> <span class="o">=</span> <span class="n">axmap</span><span class="p">(</span><span class="n">coordmap</span><span class="p">,</span> <span class="s1">&#39;in2out&#39;</span><span class="p">,</span> <span class="n">fix0</span><span class="o">=</span><span class="n">fix0</span><span class="p">)[</span><span class="n">in_dim</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_str</span> <span class="ow">and</span>
            <span class="n">axis_id</span> <span class="ow">in</span> <span class="n">out_dims</span> <span class="ow">and</span>
            <span class="n">out_dim</span> <span class="o">!=</span> <span class="n">out_dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis_id</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">AxisError</span><span class="p">(</span><span class="s1">&#39;Input and output axes with the same name but &#39;</span>
                            <span class="s1">&#39;the axes do not appear to correspond&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">in_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">in_dim</span> <span class="o">=</span> <span class="n">axmap</span><span class="p">(</span><span class="n">coordmap</span><span class="p">,</span> <span class="s1">&#39;out2in&#39;</span><span class="p">,</span> <span class="n">fix0</span><span class="o">=</span><span class="n">fix0</span><span class="p">)[</span><span class="n">out_dim</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">in_dim</span><span class="p">,</span> <span class="n">out_dim</span></div>


<div class="viewcode-block" id="orth_axes"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.orth_axes">[docs]</a><span class="k">def</span> <span class="nf">orth_axes</span><span class="p">(</span><span class="n">in_ax</span><span class="p">,</span> <span class="n">out_ax</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">allow_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">TINY</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; True if `in_ax` related only to `out_ax` in `affine` and vice versa</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in_ax : int</span>
<span class="sd">        Input axis index</span>
<span class="sd">    out_ax : int</span>
<span class="sd">        Output axis index</span>
<span class="sd">    affine :  array-like</span>
<span class="sd">        Affine transformation matrix</span>
<span class="sd">    allow_zero : bool, optional</span>
<span class="sd">        Whether to allow zero in ``affine[out_ax, in_ax]``.  This means that the</span>
<span class="sd">        two axes are not related, but nor is this pair related to any other</span>
<span class="sd">        part of the affine.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tf : bool</span>
<span class="sd">        True if in_ax, out_ax pair are orthogonal to the rest of `affine`,</span>
<span class="sd">        unless `allow_zero` is False, in which case require in addition that</span>
<span class="sd">        ``affine[out_ax, in_ax] != 0``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aff = np.eye(4)</span>
<span class="sd">    &gt;&gt;&gt; orth_axes(1, 1, aff)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; orth_axes(1, 2, aff)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rzs</span><span class="p">,</span> <span class="n">trans</span> <span class="o">=</span> <span class="n">to_matvec</span><span class="p">(</span><span class="n">affine</span><span class="p">)</span>
    <span class="n">nzs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rzs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_zero</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">nzs</span><span class="p">[</span><span class="n">out_ax</span><span class="p">,</span> <span class="n">in_ax</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">nzs</span><span class="p">[</span><span class="n">out_ax</span><span class="p">,</span> <span class="n">in_ax</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nzs</span><span class="p">[</span><span class="n">out_ax</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nzs</span><span class="p">[:,</span> <span class="n">in_ax</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="CoordMapMakerError"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.CoordMapMakerError">[docs]</a><span class="k">class</span> <span class="nc">CoordMapMakerError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="CoordMapMaker"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.CoordMapMaker">[docs]</a><span class="k">class</span> <span class="nc">CoordMapMaker</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Class to create coordinate maps of different dimensions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">generic_maker</span> <span class="o">=</span> <span class="n">CoordinateMap</span>
    <span class="n">affine_maker</span> <span class="o">=</span> <span class="n">AffineTransform</span>

<div class="viewcode-block" id="CoordMapMaker.__init__"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.CoordMapMaker.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain_maker</span><span class="p">,</span> <span class="n">range_maker</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create coordinate map maker</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domain_maker : callable</span>
<span class="sd">            A coordinate system maker, returning a coordinate system with input</span>
<span class="sd">            argument only ``N``, an integer giving the length of the coordinate</span>
<span class="sd">            map.</span>
<span class="sd">        range_maker : callable</span>
<span class="sd">            A coordinate system maker, returning a coordinate system with input</span>
<span class="sd">            argument only ``N``, an integer giving the length of the coordinate</span>
<span class="sd">            map.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from nipy.core.reference.coordinate_system import CoordSysMaker</span>
<span class="sd">        &gt;&gt;&gt; dmaker = CoordSysMaker(&#39;ijkl&#39;, &#39;generic-array&#39;)</span>
<span class="sd">        &gt;&gt;&gt; rmaker = CoordSysMaker(&#39;xyzt&#39;, &#39;generic-scanner&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cm_maker = CoordMapMaker(dmaker, rmaker)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain_maker</span> <span class="o">=</span> <span class="n">domain_maker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_maker</span> <span class="o">=</span> <span class="n">range_maker</span></div>

<div class="viewcode-block" id="CoordMapMaker.make_affine"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.CoordMapMaker.make_affine">[docs]</a>    <span class="k">def</span> <span class="nf">make_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">append_zooms</span><span class="o">=</span><span class="p">(),</span> <span class="n">append_offsets</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot; Create affine coordinate map</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        affine : (M, N) array-like</span>
<span class="sd">            Array expressing the affine tranformation</span>
<span class="sd">        append_zooms : scalar or sequence length E</span>
<span class="sd">            If scalar, converted to sequence length E==1. Append E entries to</span>
<span class="sd">            the diagonal of `affine` (see examples)</span>
<span class="sd">        append_offsets : scalar or sequence length F</span>
<span class="sd">            If scalar, converted to sequence length F==1. If F==0, and E!=0, use</span>
<span class="sd">            sequence of zeros length E.  Append E entries to the translations</span>
<span class="sd">            (final column) of `affine` (see examples).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        affmap : ``AffineTransform`` coordinate map</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from nipy.core.reference.coordinate_system import CoordSysMaker</span>
<span class="sd">        &gt;&gt;&gt; dmaker = CoordSysMaker(&#39;ijkl&#39;, &#39;generic-array&#39;)</span>
<span class="sd">        &gt;&gt;&gt; rmaker = CoordSysMaker(&#39;xyzt&#39;, &#39;generic-scanner&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cm_maker = CoordMapMaker(dmaker, rmaker)</span>
<span class="sd">        &gt;&gt;&gt; cm_maker.make_affine(np.diag([2,3,4,1]))</span>
<span class="sd">        AffineTransform(</span>
<span class="sd">           function_domain=CoordinateSystem(coord_names=(&#39;i&#39;, &#39;j&#39;, &#39;k&#39;), name=&#39;generic-array&#39;, coord_dtype=float64),</span>
<span class="sd">           function_range=CoordinateSystem(coord_names=(&#39;x&#39;, &#39;y&#39;, &#39;z&#39;), name=&#39;generic-scanner&#39;, coord_dtype=float64),</span>
<span class="sd">           affine=array([[ 2.,  0.,  0.,  0.],</span>
<span class="sd">                         [ 0.,  3.,  0.,  0.],</span>
<span class="sd">                         [ 0.,  0.,  4.,  0.],</span>
<span class="sd">                         [ 0.,  0.,  0.,  1.]])</span>
<span class="sd">        )</span>

<span class="sd">        We can add extra orthogonal dimensions, by specifying the diagonal</span>
<span class="sd">        elements:</span>

<span class="sd">        &gt;&gt;&gt; cm_maker.make_affine(np.diag([2,3,4,1]), 6)</span>
<span class="sd">        AffineTransform(</span>
<span class="sd">           function_domain=CoordinateSystem(coord_names=(&#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;), name=&#39;generic-array&#39;, coord_dtype=float64),</span>
<span class="sd">           function_range=CoordinateSystem(coord_names=(&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;t&#39;), name=&#39;generic-scanner&#39;, coord_dtype=float64),</span>
<span class="sd">           affine=array([[ 2.,  0.,  0.,  0.,  0.],</span>
<span class="sd">                         [ 0.,  3.,  0.,  0.,  0.],</span>
<span class="sd">                         [ 0.,  0.,  4.,  0.,  0.],</span>
<span class="sd">                         [ 0.,  0.,  0.,  6.,  0.],</span>
<span class="sd">                         [ 0.,  0.,  0.,  0.,  1.]])</span>
<span class="sd">        )</span>

<span class="sd">        Or the diagonal elements and the offset elements:</span>

<span class="sd">        &gt;&gt;&gt; cm_maker.make_affine(np.diag([2,3,4,1]), [6], [9])</span>
<span class="sd">        AffineTransform(</span>
<span class="sd">           function_domain=CoordinateSystem(coord_names=(&#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;), name=&#39;generic-array&#39;, coord_dtype=float64),</span>
<span class="sd">           function_range=CoordinateSystem(coord_names=(&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;t&#39;), name=&#39;generic-scanner&#39;, coord_dtype=float64),</span>
<span class="sd">           affine=array([[ 2.,  0.,  0.,  0.,  0.],</span>
<span class="sd">                         [ 0.,  3.,  0.,  0.,  0.],</span>
<span class="sd">                         [ 0.,  0.,  4.,  0.,  0.],</span>
<span class="sd">                         [ 0.,  0.,  0.,  6.,  9.],</span>
<span class="sd">                         [ 0.,  0.,  0.,  0.,  1.]])</span>
<span class="sd">        )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">affine</span><span class="p">)</span>
        <span class="n">append_zooms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">append_zooms</span><span class="p">)</span>
        <span class="n">append_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">append_offsets</span><span class="p">)</span>
        <span class="n">extra_N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">append_zooms</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">append_offsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">append_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">extra_N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">append_zooms</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">append_offsets</span><span class="p">)</span> <span class="o">!=</span> <span class="n">extra_N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CoordMapMakerError</span><span class="p">(</span><span class="s1">&#39;Need same number of offsets as zooms&#39;</span><span class="p">)</span>
        <span class="n">o_n_domain</span> <span class="o">=</span> <span class="n">affine</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">o_n_range</span> <span class="o">=</span> <span class="n">affine</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain_maker</span><span class="p">(</span><span class="n">o_n_domain</span> <span class="o">+</span> <span class="n">extra_N</span><span class="p">)</span>
        <span class="nb">range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_maker</span><span class="p">(</span><span class="n">o_n_range</span> <span class="o">+</span> <span class="n">extra_N</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extra_N</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine_maker</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">affine</span><span class="p">)</span>
        <span class="c1"># Combine original and added affine using product</span>
        <span class="n">cmap0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine_maker</span><span class="p">(</span><span class="n">CS</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">coord_names</span><span class="p">[:</span><span class="n">o_n_domain</span><span class="p">]),</span>
                                  <span class="n">CS</span><span class="p">(</span><span class="nb">range</span><span class="o">.</span><span class="n">coord_names</span><span class="p">[:</span><span class="n">o_n_range</span><span class="p">]),</span>
                                  <span class="n">affine</span><span class="p">)</span>
        <span class="n">affine1</span> <span class="o">=</span> <span class="n">from_matvec</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">append_zooms</span><span class="p">),</span> <span class="n">append_offsets</span><span class="p">)</span>
        <span class="n">cmap1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine_maker</span><span class="p">(</span><span class="n">CS</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">coord_names</span><span class="p">[</span><span class="n">o_n_domain</span><span class="p">:]),</span>
                                  <span class="n">CS</span><span class="p">(</span><span class="nb">range</span><span class="o">.</span><span class="n">coord_names</span><span class="p">[</span><span class="n">o_n_range</span><span class="p">:]),</span>
                                  <span class="n">affine1</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="n">cmap0</span><span class="p">,</span> <span class="n">cmap1</span><span class="p">)</span>
        <span class="c1"># Return with original coordinate system names</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine_maker</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">cmap</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoordMapMaker.make_cmap"><a class="viewcode-back" href="../../../../api/generated/nipy.core.reference.coordinate_map.html#nipy.core.image.image.CoordMapMaker.make_cmap">[docs]</a>    <span class="k">def</span> <span class="nf">make_cmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain_N</span><span class="p">,</span> <span class="n">xform</span><span class="p">,</span> <span class="n">inv_xform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Coordinate map with transform function `xform`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domain_N : int</span>
<span class="sd">            Number of domain coordinates</span>
<span class="sd">        xform : callable</span>
<span class="sd">            Function that transforms points of dimension `domain_N`</span>
<span class="sd">        inv_xform : None or callable, optional</span>
<span class="sd">            Function, such that ``inv_xform(xform(pts))`` returns ``pts``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cmap : ``CoordinateMap``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from nipy.core.reference.coordinate_system import CoordSysMaker</span>
<span class="sd">        &gt;&gt;&gt; dmaker = CoordSysMaker(&#39;ijkl&#39;, &#39;generic-array&#39;)</span>
<span class="sd">        &gt;&gt;&gt; rmaker = CoordSysMaker(&#39;xyzt&#39;, &#39;generic-scanner&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cm_maker = CoordMapMaker(dmaker, rmaker)</span>
<span class="sd">        &gt;&gt;&gt; cm_maker.make_cmap(4, lambda x : x+1) #doctest: +ELLIPSIS</span>
<span class="sd">        CoordinateMap(</span>
<span class="sd">           function_domain=CoordinateSystem(coord_names=(&#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;), name=&#39;generic-array&#39;, coord_dtype=float64),</span>
<span class="sd">           function_range=CoordinateSystem(coord_names=(&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;t&#39;), name=&#39;generic-scanner&#39;, coord_dtype=float64),</span>
<span class="sd">           function=&lt;function &lt;lambda&gt; at ...&gt;</span>
<span class="sd">          )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">domain_cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain_maker</span><span class="p">(</span><span class="n">domain_N</span><span class="p">)</span>
        <span class="n">ex_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">domain_N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">domain_cs</span><span class="o">.</span><span class="n">coord_dtype</span><span class="p">)</span>
        <span class="n">xformed_pt</span> <span class="o">=</span> <span class="n">xform</span><span class="p">(</span><span class="n">ex_pt</span><span class="p">)</span>
        <span class="n">range_N</span> <span class="o">=</span> <span class="n">xformed_pt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_maker</span><span class="p">(</span><span class="n">domain_cs</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">range_maker</span><span class="p">(</span><span class="n">range_N</span><span class="p">),</span>
                                  <span class="n">xform</span><span class="p">,</span>
                                  <span class="n">inv_xform</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create affine or non-affine coordinate map</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        \\*args :</span>
<span class="sd">            Arguments to ``make_affine`` or ``make_cmap`` methods. We check the</span>
<span class="sd">            first argument to see if it is a scalar or an affine, and pass the</span>
<span class="sd">            \\*args, \\*\\*kwargs to ``make_cmap`` or ``make_affine``</span>
<span class="sd">            respectively</span>
<span class="sd">        \\*\\*kwargs:</span>
<span class="sd">            See above</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cmap : ``CoordinateMap`` or ``AffineTransform``</span>
<span class="sd">            Affine if the first \\*arg was an affine array, otherwise a</span>
<span class="sd">            Coordinate Map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arg0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">arg0</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_cmap</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_affine</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright J. Taylor and others
      <span class="lastupdated">
        Last updated on Sep 25, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>