

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Selection &mdash; Selection Documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />


</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html">
          

          
            
            <img src="../../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../algorithms/index.html">Non-randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../randomized/index.html">Randomized algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../learning/index.html">Learning selection</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">selection</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>Selection</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for nipy.modalities.fmri.utils</h1><div class="highlight"><pre>
<span></span><span class="c1"># emacs: -*- mode: python; py-indent-offset: 4; indent-tabs-mode: nil -*-</span>
<span class="c1"># vi: set ft=python sts=4 ts=4 sw=4 et:</span>
<span class="sd">&quot;&quot;&quot; This module defines some convenience functions of time.</span>

<span class="sd">interp : an expresion for a interpolated function of time</span>

<span class="sd">linear_interp : an expression for a linearly interpolated function of</span>
<span class="sd">   time</span>

<span class="sd">step_function : an expression for a step function of time</span>

<span class="sd">events : a convenience function to generate sums of events</span>

<span class="sd">blocks : a convenience function to generate sums of blocks</span>

<span class="sd">convolve_functions : numerically convolve two functions of time</span>

<span class="sd">fourier_basis : a convenience function to generate a Fourier basis</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">interp1d</span>

<span class="kn">import</span> <span class="nn">sympy</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">DiracDelta</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.lambdify</span> <span class="k">import</span> <span class="n">implemented_function</span><span class="p">,</span> <span class="n">lambdify</span>

<span class="kn">from</span> <span class="nn">nipy.algorithms.statistics.formula.formulae</span> <span class="k">import</span> <span class="n">Term</span><span class="p">,</span> <span class="n">Formula</span>

<span class="c1"># Legacy repr printing from numpy.</span>
<span class="kn">from</span> <span class="nn">nipy.testing</span> <span class="k">import</span> <span class="n">legacy_printing</span> <span class="k">as</span> <span class="n">setup_module</span>  <span class="c1"># noqa</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Interp1dNumeric"><a class="viewcode-back" href="../../../../api/generated/nipy.modalities.fmri.utils.html#nipy.modalities.fmri.utils.Interp1dNumeric">[docs]</a><span class="k">class</span> <span class="nc">Interp1dNumeric</span><span class="p">(</span><span class="n">interp1d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Wrapper for interp1 to raise TypeError for object array input</span>

<span class="sd">    We need this because sympy will try to evaluate interpolated functions when</span>
<span class="sd">    constructing expressions involving floats.  At least sympy 1.0 only accepts</span>
<span class="sd">    TypeError or AttributeError as indication that the implemented value cannot</span>
<span class="sd">    be sampled with the sympy expression.  Therefore, raise a TypeError</span>
<span class="sd">    directly for an input giving an object array (such as a sympy expression),</span>
<span class="sd">    rather than letting interp1d raise a ValueError.</span>

<span class="sd">    See:</span>

<span class="sd">    * https://github.com/nipy/nipy/issues/395</span>
<span class="sd">    * https://github.com/sympy/sympy/issues/10810</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Object arrays not supported&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Interp1dNumeric</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="lambdify_t"><a class="viewcode-back" href="../../../../api/generated/nipy.modalities.fmri.utils.html#nipy.modalities.fmri.utils.lambdify_t">[docs]</a><span class="k">def</span> <span class="nf">lambdify_t</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return sympy function of t `expr` lambdified as function of t</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    expr : sympy expr</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : callable</span>
<span class="sd">       Numerical implementation of function</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="define"><a class="viewcode-back" href="../../../../api/generated/nipy.modalities.fmri.utils.html#nipy.modalities.fmri.utils.define">[docs]</a><span class="k">def</span> <span class="nf">define</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create function of t expression from arbitrary expression `expr`</span>

<span class="sd">    Take an arbitrarily complicated expression `expr` of &#39;t&#39; and make it</span>
<span class="sd">    an expression that is a simple function of t, of form ``&#39;%s(t)&#39; %</span>
<span class="sd">    name`` such that when it evaluates (via ``lambdify``) it has the</span>
<span class="sd">    right values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    expr : sympy expression</span>
<span class="sd">       with only &#39;t&#39; as a Symbol</span>
<span class="sd">    name : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nexpr: sympy expression</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; t = Term(&#39;t&#39;)</span>
<span class="sd">    &gt;&gt;&gt; expr = t**2 + 3*t</span>
<span class="sd">    &gt;&gt;&gt; print(expr)  #doctest: +SYMPY_EQUAL</span>
<span class="sd">    3*t + t**2</span>
<span class="sd">    &gt;&gt;&gt; newexpr = define(&#39;f&#39;, expr)</span>
<span class="sd">    &gt;&gt;&gt; print(newexpr)</span>
<span class="sd">    f(t)</span>
<span class="sd">    &gt;&gt;&gt; f = lambdify_t(newexpr)</span>
<span class="sd">    &gt;&gt;&gt; f(4)</span>
<span class="sd">    28</span>
<span class="sd">    &gt;&gt;&gt; 3*4+4**2</span>
<span class="sd">    28</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make numerical implementation of expression</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
    <span class="c1"># convert numerical implementation to sympy function</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">implemented_function</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="c1"># Return expression that is function of time</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></div>


<div class="viewcode-block" id="fourier_basis"><a class="viewcode-back" href="../../../../api/generated/nipy.modalities.fmri.utils.html#nipy.modalities.fmri.utils.fourier_basis">[docs]</a><span class="k">def</span> <span class="nf">fourier_basis</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; sin and cos Formula for Fourier drift</span>

<span class="sd">    The Fourier basis consists of sine and cosine waves of given</span>
<span class="sd">    frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    freq : sequence of float</span>
<span class="sd">        Frequencies for the terms in the Fourier basis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : Formula</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; f=fourier_basis([1,2,3])</span>
<span class="sd">    &gt;&gt;&gt; f.terms</span>
<span class="sd">    array([cos(2*pi*t), sin(2*pi*t), cos(4*pi*t), sin(4*pi*t), cos(6*pi*t),</span>
<span class="sd">           sin(6*pi*t)], dtype=object)</span>
<span class="sd">    &gt;&gt;&gt; f.mean</span>
<span class="sd">    _b0*cos(2*pi*t) + _b1*sin(2*pi*t) + _b2*cos(4*pi*t) + _b3*sin(4*pi*t) + _b4*cos(6*pi*t) + _b5*sin(6*pi*t)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">freq</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">sympy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">T</span><span class="p">)),</span>
              <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">sympy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">T</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">Formula</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></div>


<div class="viewcode-block" id="interp"><a class="viewcode-back" href="../../../../api/generated/nipy.modalities.fmri.utils.html#nipy.modalities.fmri.utils.interp">[docs]</a><span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Generic interpolation function of t given `times` and `values`</span>

<span class="sd">    Imterpolator such that:</span>

<span class="sd">    f(times[i]) = values[i]</span>

<span class="sd">    if t &lt; times[0] or t &gt; times[-1]:</span>
<span class="sd">        f(t) = fill</span>

<span class="sd">    See ``scipy.interpolate.interp1d`` for details of interpolation</span>
<span class="sd">    types and other keyword arguments.  Default is &#39;kind&#39; is linear,</span>
<span class="sd">    making this function, by default, have the same behavior as</span>
<span class="sd">    ``linear_interp``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : array-like</span>
<span class="sd">        Increasing sequence of times</span>
<span class="sd">    values : array-like</span>
<span class="sd">        Values at the specified times</span>
<span class="sd">    fill : None or float, optional</span>
<span class="sd">        Value on the interval (-np.inf, times[0]). Default 0. If None, raises</span>
<span class="sd">        error outside bounds</span>
<span class="sd">    name : None or str, optional</span>
<span class="sd">        Name of symbolic expression to use. If None, a default is used.</span>
<span class="sd">    \*\*kw : keyword args, optional</span>
<span class="sd">        passed to ``interp1d``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : sympy expression</span>
<span class="sd">        A Function of t.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s = interp([0,4,5.],[2.,4,6])</span>
<span class="sd">    &gt;&gt;&gt; tval = np.array([-0.1,0.1,3.9,4.1,5.1])</span>
<span class="sd">    &gt;&gt;&gt; res = lambdify_t(s)(tval)</span>

<span class="sd">    0 outside bounds by default</span>

<span class="sd">    &gt;&gt;&gt; np.allclose(res, [0, 2.05, 3.95, 4.2, 0])</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fill</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bounds_error&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fill conflicts with bounds error&#39;</span><span class="p">)</span>
        <span class="n">fv</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill_value&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">fv</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">fv</span> <span class="ow">is</span> <span class="n">fill</span> <span class="ow">or</span> <span class="n">fv</span> <span class="o">==</span> <span class="n">fill</span><span class="p">):</span> <span class="c1"># allow for fill=np.nan</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fill conflicts with fill_value&#39;</span><span class="p">)</span>
        <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;bounds_error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;fill_value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill</span>
    <span class="n">interpolator</span> <span class="o">=</span> <span class="n">Interp1dNumeric</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="c1"># make a new name if none provided</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;interp</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">interp</span><span class="o">.</span><span class="n">counter</span>
        <span class="n">interp</span><span class="o">.</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">implemented_function</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">interpolator</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></div>

<span class="n">interp</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>


<div class="viewcode-block" id="linear_interp"><a class="viewcode-back" href="../../../../api/generated/nipy.modalities.fmri.utils.html#nipy.modalities.fmri.utils.linear_interp">[docs]</a><span class="k">def</span> <span class="nf">linear_interp</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Linear interpolation function of t given `times` and `values`</span>

<span class="sd">    Imterpolator such that:</span>

<span class="sd">    f(times[i]) = values[i]</span>

<span class="sd">    if t &lt; times[0] or t &gt; times[-1]:</span>
<span class="sd">        f(t) = fill</span>

<span class="sd">    This version of the function enforces the &#39;linear&#39; kind of interpolation</span>
<span class="sd">    (argument to ``scipy.interpolate.interp1d``).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : array-like</span>
<span class="sd">        Increasing sequence of times</span>
<span class="sd">    values : array-like</span>
<span class="sd">        Values at the specified times</span>
<span class="sd">    fill : None or float, optional</span>
<span class="sd">        Value on the interval (-np.inf, times[0]). Default 0. If None, raises</span>
<span class="sd">        error outside bounds</span>
<span class="sd">    name : None or str, optional</span>
<span class="sd">        Name of symbolic expression to use. If None, a default is used.</span>
<span class="sd">    \*\*kw : keyword args, optional</span>
<span class="sd">        passed to ``interp1d``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : sympy expression</span>
<span class="sd">        A Function of t.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s = linear_interp([0,4,5.],[2.,4,6])</span>
<span class="sd">    &gt;&gt;&gt; tval = np.array([-0.1,0.1,3.9,4.1,5.1])</span>
<span class="sd">    &gt;&gt;&gt; res = lambdify_t(s)(tval)</span>

<span class="sd">    0 outside bounds by default</span>

<span class="sd">    &gt;&gt;&gt; np.allclose(res, [0, 2.05, 3.95, 4.2, 0])</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kind</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;kind&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
    <span class="k">elif</span> <span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only linear interpolation supported&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">interp</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span></div>


<div class="viewcode-block" id="step_function"><a class="viewcode-back" href="../../../../api/generated/nipy.modalities.fmri.utils.html#nipy.modalities.fmri.utils.step_function">[docs]</a><span class="k">def</span> <span class="nf">step_function</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Right-continuous step function of time t</span>

<span class="sd">    Function of t such that</span>

<span class="sd">    f(times[i]) = values[i]</span>

<span class="sd">    if t &lt; times[0]:</span>
<span class="sd">        f(t) = fill</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : (N,) sequence</span>
<span class="sd">       Increasing sequence of times</span>
<span class="sd">    values : (N,) sequence</span>
<span class="sd">       Values at the specified times</span>
<span class="sd">    fill : float</span>
<span class="sd">       Value on the interval (-np.inf, times[0])</span>
<span class="sd">    name : str</span>
<span class="sd">       Name of symbolic expression to use. If None, a default is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f_t : sympy expr</span>
<span class="sd">       Sympy expression f(t) where f is a sympy implemented anonymous</span>
<span class="sd">       function of time that implements the step function.  To get the</span>
<span class="sd">       numerical version of the function, use ``lambdify_t(f_t)``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s = step_function([0,4,5],[2,4,6])</span>
<span class="sd">    &gt;&gt;&gt; tval = np.array([-0.1,3.9,4.1,5.1])</span>
<span class="sd">    &gt;&gt;&gt; lam = lambdify_t(s)</span>
<span class="sd">    &gt;&gt;&gt; lam(tval)</span>
<span class="sd">    array([ 0.,  2.,  4.,  6.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;step</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">step_function</span><span class="o">.</span><span class="n">counter</span>
        <span class="n">step_function</span><span class="o">.</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_imp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">fill</span>
        <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="n">f</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">time</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">implemented_function</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_imp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></div>

<span class="c1"># Initialize counter for step function</span>
<span class="n">step_function</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>


<div class="viewcode-block" id="events"><a class="viewcode-back" href="../../../../api/generated/nipy.modalities.fmri.utils.html#nipy.modalities.fmri.utils.events">[docs]</a><span class="k">def</span> <span class="nf">events</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">amplitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">DiracDelta</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot; Return a sum of functions based on a sequence of times.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : sequence</span>
<span class="sd">       vector of onsets length $N$</span>
<span class="sd">    amplitudes : None or sequence length $N$, optional</span>
<span class="sd">       Optional sequence of amplitudes. None (default) results in</span>
<span class="sd">       sequence length $N$ of 1s</span>
<span class="sd">    f : sympy.Function, optional</span>
<span class="sd">       Optional function. Defaults to DiracDelta, can be replaced with</span>
<span class="sd">       another function, f, in which case the result is the convolution</span>
<span class="sd">       with f.</span>
<span class="sd">    g : sympy.Basic, optional</span>
<span class="sd">       Optional sympy expression function of amplitudes.  The</span>
<span class="sd">       amplitudes, should be represented by the symbol &#39;a&#39;, which will</span>
<span class="sd">       be substituted, by the corresponding value in `amplitudes`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sum_expression : Sympy.Add</span>
<span class="sd">       Sympy expression of time $t$, where onsets, as a function of $t$,</span>
<span class="sd">       have been symbolically convolved with function `f`, and any</span>
<span class="sd">       function `g` of corresponding amplitudes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    We import some sympy stuff so we can test if we&#39;ve got what we</span>
<span class="sd">    expected</span>

<span class="sd">    &gt;&gt;&gt; from sympy import DiracDelta, Symbol, Function</span>
<span class="sd">    &gt;&gt;&gt; from nipy.modalities.fmri.utils import T</span>
<span class="sd">    &gt;&gt;&gt; evs = events([3,6,9])</span>
<span class="sd">    &gt;&gt;&gt; evs == DiracDelta(-9 + T) + DiracDelta(-6 + T) + DiracDelta(-3 + T)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; hrf = Function(&#39;hrf&#39;)</span>
<span class="sd">    &gt;&gt;&gt; evs = events([3,6,9], f=hrf)</span>
<span class="sd">    &gt;&gt;&gt; evs == hrf(-9 + T) + hrf(-6 + T) + hrf(-3 + T)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; evs = events([3,6,9], amplitudes=[2,1,-1])</span>
<span class="sd">    &gt;&gt;&gt; evs == -DiracDelta(-9 + T) + 2*DiracDelta(-3 + T) + DiracDelta(-6 + T)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">e</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">asymb</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">amplitudes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">amplitudes</span><span class="p">):</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">e</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">asymb</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">-</span><span class="n">time</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">e</span></div>


<div class="viewcode-block" id="blocks"><a class="viewcode-back" href="../../../../api/generated/nipy.modalities.fmri.utils.html#nipy.modalities.fmri.utils.blocks">[docs]</a><span class="k">def</span> <span class="nf">blocks</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">amplitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Step function based on a sequence of intervals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    intervals : (S,) sequence of (2,) sequences</span>
<span class="sd">       Sequence (S0, S1, ... S(N-1)) of sequences, where S0 (etc) are</span>
<span class="sd">       sequences of length 2, giving &#39;on&#39; and &#39;off&#39; times of block</span>
<span class="sd">    amplitudes : (S,) sequence of float, optional</span>
<span class="sd">       Optional amplitudes for each block. Defaults to 1.</span>
<span class="sd">    name : None or str, optional</span>
<span class="sd">       Name of the convolved function in the resulting expression.</span>
<span class="sd">       Defaults to one created by ``utils.interp``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b_of_t : sympy expr</span>
<span class="sd">       Sympy expression b(t) where b is a sympy anonymous function of</span>
<span class="sd">       time that implements the block step function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; on_off = [[1,2],[3,4]]</span>
<span class="sd">    &gt;&gt;&gt; tval = np.array([0.4,1.4,2.4,3.4])</span>
<span class="sd">    &gt;&gt;&gt; b = blocks(on_off)</span>
<span class="sd">    &gt;&gt;&gt; lam = lambdify_t(b)</span>
<span class="sd">    &gt;&gt;&gt; lam(tval)</span>
<span class="sd">    array([ 0.,  1.,  0.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; b = blocks(on_off, amplitudes=[3,5])</span>
<span class="sd">    &gt;&gt;&gt; lam = lambdify_t(b)</span>
<span class="sd">    &gt;&gt;&gt; lam(tval)</span>
<span class="sd">    array([ 0.,  3.,  0.,  5.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">amplitudes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">_t</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">amplitudes</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_t</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">+=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="n">v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">step_function</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_eval_for</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return x and y for function `f` over `interval` and delta `dt`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">real_f</span> <span class="o">=</span> <span class="n">lambdify_t</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">f_mn</span><span class="p">,</span> <span class="n">f_mx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">f_mn</span><span class="p">,</span> <span class="n">f_mx</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">))</span> <span class="c1"># time values with support for g</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">real_f</span><span class="p">(</span><span class="n">time</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vals</span>


<span class="k">def</span> <span class="nf">_conv_fx_gx</span><span class="p">(</span><span class="n">f_vals</span><span class="p">,</span> <span class="n">g_vals</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">min_f</span><span class="p">,</span> <span class="n">min_g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Numerical convolution given f(x), min(x) for two functions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">f_vals</span><span class="p">,</span> <span class="n">g_vals</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="c1"># Full by default</span>
    <span class="c1"># f and g have been implicitly translated by -f_mn and -g_mn respectively,</span>
    <span class="c1"># because in terms of array indices, they both now start at 0.</span>
    <span class="c1"># Translate by f and g offsets</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">))</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span> <span class="n">min_f</span> <span class="o">+</span> <span class="n">min_g</span>
    <span class="k">return</span> <span class="n">time</span><span class="p">,</span> <span class="n">vals</span>


<div class="viewcode-block" id="TimeConvolver"><a class="viewcode-back" href="../../../../api/generated/nipy.modalities.fmri.utils.html#nipy.modalities.fmri.utils.TimeConvolver">[docs]</a><span class="k">class</span> <span class="nc">TimeConvolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Make a convolution kernel from a symbolic function of t</span>

<span class="sd">    A convolution kernel is a function with extra attributes to allow it to</span>
<span class="sd">    function as a kernel for numerical convolution (see</span>
<span class="sd">    :func:`convolve_functions`).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    expr : sympy expression</span>
<span class="sd">        An expression that is a function of t only.</span>
<span class="sd">    support : 2 sequence</span>
<span class="sd">        Sequence is ``(low, high)`` where expression is defined between ``low``</span>
<span class="sd">        and ``high``, and can be assumed to be `fill` otherwise</span>
<span class="sd">    delta : float</span>
<span class="sd">        smallest change in domain of `expr` to use for numerical evaluation of</span>
<span class="sd">        `expr`</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="TimeConvolver.__init__"><a class="viewcode-back" href="../../../../api/generated/nipy.modalities.fmri.utils.html#nipy.modalities.fmri.utils.TimeConvolver.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">support</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">support</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">=</span> <span class="n">_eval_for</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">support</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeConvolver.convolve"><a class="viewcode-back" href="../../../../api/generated/nipy.modalities.fmri.utils.html#nipy.modalities.fmri.utils.TimeConvolver.convolve">[docs]</a>    <span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">g_interval</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convolve sympy expression `g` with this kernel</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        g : sympy expr</span>
<span class="sd">            An expression that is a function of t only.</span>
<span class="sd">        g_interval : (2,) sequence of floats</span>
<span class="sd">            Start and end of the interval of t over which to convolve g</span>
<span class="sd">        name : None or str, optional</span>
<span class="sd">            Name of the convolved function in the resulting expression.</span>
<span class="sd">            Defaults to one created by ``utils.interp``.</span>
<span class="sd">        \*\*kwargs : keyword args, optional</span>
<span class="sd">            Any other arguments to pass to the ``interp1d`` function in creating</span>
<span class="sd">            the numerical function for `fg`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fg : sympy expr</span>
<span class="sd">            An symbolic expression that is a function of t only, and that can be</span>
<span class="sd">            lambdified to produce a function returning the convolved series from</span>
<span class="sd">            an input array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g_vals</span> <span class="o">=</span> <span class="n">_eval_for</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g_interval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">fg_time</span><span class="p">,</span> <span class="n">fg_vals</span> <span class="o">=</span> <span class="n">_conv_fx_gx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">,</span>
                                       <span class="n">g_vals</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span>
                                       <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">support</span><span class="p">),</span>
                                       <span class="nb">min</span><span class="p">(</span><span class="n">g_interval</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">interp</span><span class="p">(</span><span class="n">fg_time</span><span class="p">,</span> <span class="n">fg_vals</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="convolve_functions"><a class="viewcode-back" href="../../../../api/generated/nipy.modalities.fmri.utils.html#nipy.modalities.fmri.utils.convolve_functions">[docs]</a><span class="k">def</span> <span class="nf">convolve_functions</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">f_interval</span><span class="p">,</span> <span class="n">g_interval</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span>
                       <span class="n">fill</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Expression containing numerical convolution of `fn1` with `fn2`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : sympy expr</span>
<span class="sd">       An expression that is a function of t only.</span>
<span class="sd">    g : sympy expr</span>
<span class="sd">       An expression that is a function of t only.</span>
<span class="sd">    f_interval : (2,) sequence of float</span>
<span class="sd">       The start and end of the interval of t over which to convolve values of f</span>
<span class="sd">    g_interval : (2,) sequence of floats</span>
<span class="sd">       Start and end of the interval of t over which to convolve g</span>
<span class="sd">    dt : float</span>
<span class="sd">       Time step for discretization.  We use this for creating the</span>
<span class="sd">       interpolator to form the numerical implementation</span>
<span class="sd">    fill : None or float</span>
<span class="sd">       Value to return from sampling output `fg` function outside range.</span>
<span class="sd">    name : None or str, optional</span>
<span class="sd">       Name of the convolved function in the resulting expression.</span>
<span class="sd">       Defaults to one created by ``utils.interp``.</span>
<span class="sd">    \*\*kwargs : keyword args, optional</span>
<span class="sd">       Any other arguments to pass to the ``interp1d`` function in creating the</span>
<span class="sd">       numerical function for `fg`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fg : sympy expr</span>
<span class="sd">       An symbolic expression that is a function of t only, and that can be</span>
<span class="sd">       lambdified to produce a function returning the convolved series from an</span>
<span class="sd">       input array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from nipy.algorithms.statistics.formula.formulae import Term</span>
<span class="sd">    &gt;&gt;&gt; t = Term(&#39;t&#39;)</span>

<span class="sd">    This is a square wave on [0,1]</span>

<span class="sd">    &gt;&gt;&gt; f1 = (t &gt; 0) * (t &lt; 1)</span>

<span class="sd">    The convolution of ``f1`` with itself is a triangular wave on [0, 2],</span>
<span class="sd">    peaking at 1 with height 1</span>

<span class="sd">    &gt;&gt;&gt; tri = convolve_functions(f1, f1, [0, 2], [0, 2], 1.0e-3, name=&#39;conv&#39;)</span>

<span class="sd">    The result is a symbolic function</span>

<span class="sd">    &gt;&gt;&gt; print(tri)</span>
<span class="sd">    conv(t)</span>

<span class="sd">    Get the numerical values for a time vector</span>

<span class="sd">    &gt;&gt;&gt; ftri = lambdify(t, tri)</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(0, 2, 0.2)</span>
<span class="sd">    &gt;&gt;&gt; y = ftri(x)</span>

<span class="sd">    The peak is at 1</span>
<span class="sd">    &gt;&gt;&gt; x[np.argmax(y)]</span>
<span class="sd">    1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note that - from the doctest above - y is</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    array([ -3.90255908e-16,   1.99000000e-01,   3.99000000e-01,</span>
<span class="sd">           5.99000000e-01,   7.99000000e-01,   9.99000000e-01,</span>
<span class="sd">           7.99000000e-01,   5.99000000e-01,   3.99000000e-01,</span>
<span class="sd">           1.99000000e-01,   6.74679706e-16])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># - so the peak value is 1-dt - rather than 1 - but we get the same</span>
    <span class="c1"># result from using np.convolve - see tests.</span>
    <span class="n">f_vals</span> <span class="o">=</span> <span class="n">_eval_for</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f_interval</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">g_vals</span> <span class="o">=</span> <span class="n">_eval_for</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g_interval</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">fg_time</span><span class="p">,</span> <span class="n">fg_vals</span> <span class="o">=</span> <span class="n">_conv_fx_gx</span><span class="p">(</span><span class="n">f_vals</span><span class="p">,</span>
                                   <span class="n">g_vals</span><span class="p">,</span>
                                   <span class="n">dt</span><span class="p">,</span>
                                   <span class="nb">min</span><span class="p">(</span><span class="n">f_interval</span><span class="p">),</span>
                                   <span class="nb">min</span><span class="p">(</span><span class="n">g_interval</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">interp</span><span class="p">(</span><span class="n">fg_time</span><span class="p">,</span> <span class="n">fg_vals</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">fill</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright J. Taylor and others
      <span class="lastupdated">
        Last updated on Sep 25, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>